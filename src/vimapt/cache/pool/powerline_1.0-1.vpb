- [vimapt/copyright/powerline.yaml, 4]
- [vimapt/control/powerline.yaml, 5]
- [autoload/Pl.vim, 184]
- [autoload/Pl/Segment.vim, 188]
- [autoload/Pl/Parser.vim, 371]
- [autoload/Pl/Match.vim, 43]
- [autoload/Pl/Mod.vim, 40]
- [autoload/Pl/Theme.vim, 100]
- [autoload/Pl/Hi.vim, 140]
- [autoload/Pl/Colorscheme.vim, 145]
- [autoload/Powerline/Functions.vim, 141]
- [autoload/Powerline/Segments.vim, 30]
- [autoload/Powerline/Matches.vim, 13]
- [autoload/Powerline/Segments/fugitive.vim, 5]
- [autoload/Powerline/Segments/virtualenv.vim, 5]
- [autoload/Powerline/Segments/ft_man.vim, 3]
- [autoload/Powerline/Segments/ctrlp.vim, 20]
- [autoload/Powerline/Segments/syntastic.vim, 5]
- [autoload/Powerline/Segments/hgrev.vim, 4]
- [autoload/Powerline/Segments/tagbar.vim, 6]
- [autoload/Powerline/Segments/rvm.vim, 6]
- [autoload/Powerline/Colorschemes/solarized16.vim, 195]
- [autoload/Powerline/Colorschemes/solarized256.vim, 195]
- [autoload/Powerline/Colorschemes/solarized.vim, 154]
- [autoload/Powerline/Colorschemes/default.vim, 166]
- [autoload/Powerline/Themes/solarized16.vim, 114]
- [autoload/Powerline/Themes/solarized256.vim, 119]
- [autoload/Powerline/Themes/default.vim, 116]
- [autoload/Powerline/Functions/fugitive.vim, 7]
- [autoload/Powerline/Functions/ft_man.vim, 12]
- [autoload/Powerline/Functions/syntastic.vim, 16]
- [autoload/Powerline/Functions/hgrev.vim, 17]
- [doc/Powerline.txt, 439]
- [fontpatcher/PowerlineSymbols.sfd, 319]
- [fontpatcher/README.rst, 164]
- [fontpatcher/fontpatcher, 240]
- [vimrc/powerline.vimrc, 0]
- [plugin/Powerline.vim, 78]

author: 'Kim Silkebækken <kim.silkebaekken+github@gmail.com>'
license: ''
maintiner: 'Howl Anderson <u1mail2me@gmail.com>'
source: 'https://github.com/Lokaltog/vim-powerline'
depends: ''
section: ''
version: '1.0'
short-description: ''
long-description: ''
" Powerline - The ultimate statusline utility
"
" Author: Kim Silkebækken <kim.silkebaekken+vim@gmail.com>
" Source repository: https://github.com/Lokaltog/vim-powerline

" Script variables {{{
	let g:Pl#OLD_STL = ''
	let g:Pl#THEME = []
	let g:Pl#THEME_CALLBACKS = []
	let g:Pl#HL = []

	" Cache revision, this must be incremented whenever the cache format is changed
	let s:CACHE_REVISION = 7
" }}}
" Script initialization {{{
	function! Pl#LoadCache() " {{{
		if filereadable(g:Powerline_cache_file) && g:Powerline_cache_enabled
			exec 'source' escape(g:Powerline_cache_file, ' \')

			if ! exists('g:Powerline_cache_revision') || g:Powerline_cache_revision != s:CACHE_REVISION
				" Cache revision differs, cache is invalid
				unlet! g:Powerline_cache_revision

				return 0
			endif

			" Create highlighting groups
			for hi_cmd in g:Pl#HL
				exec hi_cmd
			endfor

			" Run theme callbacks
			for callback in g:Pl#THEME_CALLBACKS
				" Substitute {{NEWLINE}} with newlines (strings must be
				" stored without newlines characters to avoid vim errors)
				exec substitute(callback[0], "{{NEWLINE}}", "\n", 'g')
				exec substitute(callback[1], "{{NEWLINE}}", "\n", 'g')
			endfor

			return 1
		endif

		return 0
	endfunction " }}}
	function! Pl#ClearCache() " {{{
		if filereadable(g:Powerline_cache_file)
			" Delete the cache file
			call delete(g:Powerline_cache_file)
		endif

		echo 'Powerline cache cleared. Please restart vim for the changes to take effect.'
	endfunction " }}}
	function! Pl#ReloadColorscheme() " {{{
		call Pl#ClearCache()

		" The colorscheme and theme files must be manually sourced because
		" vim won't reload previously autoloaded files
		"
		" This is a bit hackish, but it works
		unlet! g:Powerline#Colorschemes#{g:Powerline_colorscheme}#colorscheme
		exec "source" split(globpath(&rtp, 'autoload/Powerline/Colorschemes/'. g:Powerline_colorscheme .'.vim', 1), '\n')[0]

		unlet! g:Powerline#Themes#{g:Powerline_theme}#theme
		exec "source" split(globpath(&rtp, 'autoload/Powerline/Themes/'. g:Powerline_theme .'.vim', 1), '\n')[0]

		let g:Pl#THEME = []

		call Pl#Load()
	endfunction " }}}
	function! Pl#Load() " {{{
		if empty(g:Pl#OLD_STL)
			" Store old statusline
			let g:Pl#OLD_STL = &statusline
		endif

		if ! Pl#LoadCache()
			try
				" Autoload the theme dict first
				let raw_theme = g:Powerline#Themes#{g:Powerline_theme}#theme
			catch
				echom 'Invalid Powerline theme! Please check your theme and colorscheme settings.'

				return
			endtry

			" Create list with parsed statuslines
			for buffer_statusline in raw_theme
				unlet! mode_statuslines
				let mode_statuslines = Pl#Parser#GetStatusline(buffer_statusline.segments)

				if ! empty(buffer_statusline.callback)
					" The callback function passes its arguments on to
					" Pl#StatuslineCallback along with the normal/current mode
					" statusline.
					let s:cb_func  = "function! PowerlineStatuslineCallback_". buffer_statusline.callback[1] ."(...)\n"
					let s:cb_func .= "return Pl#StatuslineCallback(". string(mode_statuslines['n']) .", a:000)\n"
					let s:cb_func .= "endfunction"

					" The callback expression should be used to initialize any
					" variables that will use the callback function. The
					" expression requires a %s which will be replaced by the
					" callback function name.
					let s:cb_expr  = printf(buffer_statusline.callback[2], 'PowerlineStatuslineCallback_'. buffer_statusline.callback[1])

					exec s:cb_func
					exec s:cb_expr

					" Newlines must be substituted with another character
					" because vim doesn't like newlines in strings
					call add(g:Pl#THEME_CALLBACKS, [substitute(s:cb_func, "\n", "{{NEWLINE}}", 'g'), substitute(s:cb_expr, "\n", "{{NEWLINE}}", 'g')])

					unlet! s:cb_func s:cb_expr

					continue
				endif

				" Store the statuslines for matching specific buffers
				call add(g:Pl#THEME, {
					\ 'matches': buffer_statusline.matches,
					\ 'mode_statuslines': mode_statuslines
					\ })
			endfor

			if ! g:Powerline_cache_enabled
				" Don't cache anything if caching is disabled or cache file isn't writeable
				return
			endif

			" Prepare commands and statuslines for caching
			let cache = [
				\ 'let g:Powerline_cache_revision = '. string(s:CACHE_REVISION),
				\ 'let g:Pl#HL = '. string(g:Pl#HL),
				\ 'let g:Pl#THEME  = '. string(g:Pl#THEME),
				\ 'let g:Pl#THEME_CALLBACKS  = '. string(g:Pl#THEME_CALLBACKS),
			\ ]

			call writefile(cache, g:Powerline_cache_file)
		endif
	endfunction " }}}
" }}}
" Statusline updater {{{
	function! Pl#Statusline(statusline, current) " {{{
		let mode = mode()

		if ! a:current
			let mode = 'N' " Normal (non-current)
		elseif mode =~# '\v(v|V|)'
			let mode = 'v' " Visual mode
		elseif mode =~# '\v(s|S|)'
			let mode = 's' " Select mode
		elseif mode =~# '\vi'
			let mode = 'i' " Insert mode
		elseif mode =~# '\v(R|Rv)'
			let mode = 'r' " Replace mode
		else
			" Fallback to normal mode
			let mode = 'n' " Normal (current)
		endif

		return g:Pl#THEME[a:statusline].mode_statuslines[mode]
	endfunction " }}}
	function! Pl#StatuslineCallback(statusline, args) " {{{
		" Replace %1, %2, etc. in the statusline with the callback args
		return substitute(
			\ a:statusline,
			\ '\v\%(\d+)',
			\ '\=a:args[submatch(1)]',
			\ 'g')
	endfunction " }}}
	function! Pl#UpdateStatusline(current, ...) " {{{
		if empty(g:Pl#THEME)
			" Load statuslines if they aren't loaded yet
			call Pl#Load()
		endif

		for i in range(len(g:Pl#THEME))
			if Pl#Match#Validate(g:Pl#THEME[i], a:0 ? a:1 : 0)
				" Update window-local statusline
				call setwinvar(a:0 ? a:1 : 0, '&statusline',
				            \  '%!Pl#Statusline('. i .','. a:current .')')
			endif
		endfor
	endfunction " }}}
" }}}
let s:default_modes = ['n', 'N', 'v', 'i', 'r', 's']

function! s:CheckConditions(params) " {{{
	" Check conditions for a segment/group
	" Integer parameters are always conditions
	for param in a:params
		if type(param) == type(0) && param == 0
			" Break here if it's an integer parameter and it's false (0)
			return 0
		endif
		unlet! param
	endfor

	return 1
endfunction " }}}
function! Pl#Segment#Create(name, ...) " {{{
	" Check condition parameters
	if ! s:CheckConditions(a:000)
		return {}
	endif

	let name = a:name
	let modes = s:default_modes
	let padding = 1
	let segments = []

	for param in a:000
		" Lookup modes for this segment/group
		if type(param) == type([]) && param[0] == 'modes'
			let modes = param[1]
		elseif type(param) == type([]) && param[0] == 'nopadding'
			let padding = 0
		elseif type(a:1) == type([]) && a:1[0] == 'segment'
			call add(segments, param[1])
		endif

		unlet! param
	endfor

	if type(a:1) == type([]) && a:1[0] == 'segment'
		" This is a segment group
		return ['segment_group', {
			\   'type': 'segment_group'
			\ , 'name': name
			\ , 'segments': segments
			\ , 'modes': modes
			\ , 'padding': padding
			\ }]
	else
		" This is a single segment
		let text = a:1

		" Search/replace symbols
		for [key, symbol] in items(g:Pl#Parser#Symbols[g:Powerline_symbols].symbols)
			let text = substitute(
				\ text,
				\ '\v\$('. key .')',
				\ '\=Pl#Parser#ParseChars(g:Pl#Parser#Symbols[g:Powerline_symbols].symbols[submatch(1)])',
				\ 'g')

			unlet! key symbol
		endfor

		return ['segment', {
			\   'type': 'segment'
			\ , 'name': name
			\ , 'text': text
			\ , 'modes': modes
			\ , 'padding': padding
			\ }]
	endif

endfunction " }}}
function! Pl#Segment#Init(params) " {{{
	" Check condition parameters
	if ! s:CheckConditions(a:params)
		return {}
	endif

	let segments = {}
	let ns = ''

	for param in a:params
		if type(param) == type('')
			" String parameters is the namespace
			let ns = param
		elseif type(param) == type([])
			" The data dict is in param[1]
			" By default we don't have a namespace for the segment
			let segment = param[1]

			if ! empty(ns)
				" Update segment so that it includes the namespace
				" Add the namespace to the segment dict key
				let segment.ns = ns
				let segment.name = join([segment.ns, segment.name], ':')
			endif

			let key = segment.name

			let segments[key] = segment
		endif

		unlet! param
	endfor

	return segments
endfunction " }}}
function! Pl#Segment#Modes(modes) " {{{
	" Handle modes for both segments and groups
	let modes = split(a:modes, '\zs')

	if modes[0] == '!'
		" Filter modes (e.g. "!nr" will ignore the segment in normal and replace modes)
		let modes = filter(deepcopy(s:default_modes), 'v:val !~# "['. join(modes[1:]) .']"')
	endif

	return ['modes', modes]
endfunction " }}}
function! Pl#Segment#NoPadding() " {{{
	return ['nopadding']
endfunction " }}}
function! Pl#Segment#Split(...) " {{{
	return a:0 ? a:1 .':SPLIT' : 'SPLIT'
endfunction " }}}
function! Pl#Segment#Truncate() " {{{
	return 'TRUNCATE'
endfunction " }}}
function! Pl#Segment#Get(name) " {{{
	" Return a segment data dict
	let args = []

	" Check for printf segments (lists)
	if type(a:name) == type([])
		" We're dealing with a segment with printf arguments
		let seg_orig_name = a:name[0]
		let args = a:name[1:]
	else
		let seg_orig_name = a:name
	endif

	" Fetch namespace and variants for storing in the segment dict
	let seg_ns = ''
	let seg_variants = []

	" Retrieve color scheme variants
	let seg_name_split = split(seg_orig_name, '\v\.')
	if len(seg_name_split) > 1
		let seg_variants = seg_name_split[1:]
	endif

	" Retrieve segment name and namespace
	" Use the first piece of the split string, we can't have variants in the final segment name
	let seg_name_split = split(seg_name_split[0], '\v:')
	let seg_name = seg_name_split[0]

	if len(seg_name_split) > 1
		let seg_ns = seg_name_split[0]
		let seg_name = seg_name_split[-1]
	endif

	try
		" If we have a namespace, try to use the namespaced segment first (i.e. search for the segment in the namespaced file first)
		let return_segment = deepcopy(g:Powerline#Segments#{seg_ns}#segments[seg_ns .':'. seg_name])
	catch
		try
			" We didn't find a namespaced segment, fall back to common segments
			let return_segment = deepcopy(g:Powerline#Segments#segments[seg_name])
		catch
			" Didn't find the segment among the common segments either, just skip it
			return {}
		endtry
	endtry

	if len(args) && has_key(return_segment, 'text')
		" Handle segment printf arguments
		" printf doesn't accept lists as its second argument, so we have to work around that
		let return_segment.text = call('printf', [ return_segment.text ] + args)
	endif

	" Assign namespace, name and variants
	let return_segment.ns = seg_ns
	let return_segment.name = seg_name
	let return_segment.orig_name = seg_orig_name
	let return_segment.variants = seg_variants

	return return_segment
endfunction " }}}
let g:Pl#Parser#Symbols = {
	\ 'compatible': {
		\   'dividers': [ '', [0x2502], '', [0x2502] ]
		\ , 'symbols' : {
			\   'BRANCH': 'BR:'
			\ , 'RO'    : 'RO'
			\ , 'FT'    : 'FT'
			\ , 'LINE'  : 'LN'
		\ }
	\ },
	\ 'unicode': {
		\   'dividers': [ [0x25b6], [0x276f], [0x25c0], [0x276e]  ]
		\ , 'symbols' : {
			\   'BRANCH': [0x26a1]
			\ , 'RO'    : [0x2613]
			\ , 'FT'    : [0x2691]
			\ , 'LINE'  : [0x204b]
		\ },
	\ },
	\ 'fancy': {
		\   'dividers': [ [0x2b80], [0x2b81], [0x2b82], [0x2b83] ]
		\ , 'symbols' : {
			\   'BRANCH': [0x2b60]
			\ , 'RO'    : [0x2b64]
			\ , 'FT'    : [0x2b62, 0x2b63]
			\ , 'LINE'  : [0x2b61]
		\ }
	\ }
\ }

" Handle symbol overrides
for [s:key, s:value] in items(g:Powerline_symbols_override)
	let g:Pl#Parser#Symbols[g:Powerline_symbols].symbols[s:key] = s:value

	unlet! s:key s:value
endfor

" Handle divider overrides
if len(g:Powerline_dividers_override) == 4
	let g:Pl#Parser#Symbols[g:Powerline_symbols].dividers = g:Powerline_dividers_override
endif

let s:LEFT_SIDE = 0
let s:RIGHT_SIDE = 2

let s:PADDING = 1

let s:EMPTY_SEGMENT = { 'type': 'empty' }

let s:HARD_DIVIDER = 0
let s:SOFT_DIVIDER = 1

function! Pl#Parser#GetStatusline(segments) " {{{
	let statusline = {
		\   'n': ''
		\ , 'N': ''
		\ , 'v': ''
		\ , 'i': ''
		\ , 'r': ''
		\ , 's': ''
		\ }

	" Run through the different modes and create the statuslines
	for mode in keys(statusline)
		" Create an empty statusline list
		let stl = []

		call extend(stl, s:ParseSegments(mode, s:LEFT_SIDE, a:segments))

		let statusline[mode] .= join(stl, '')
	endfor

	return statusline
endfunction " }}}
function! Pl#Parser#ParseChars(arg) " {{{
	" Handles symbol arrays which can be either an array of hex values,
	" or a string. Will convert the hex array to a string, or return the
	" string as-is.
	let arg = a:arg

	if type(arg) == type([])
		" Hex array
		call map(arg, 'nr2char(v:val)')

		return join(arg, '')
	endif

	" Anything else, just return it as it is
	return arg
endfunction " }}}
function! s:ParseSegments(mode, side, segments, ...) " {{{
	let mode     = a:mode
	let side     = a:side
	let segments = a:segments

	let level      = exists('a:1') ? a:1 : 0
	let base_color = exists('a:2') ? a:2 : {}

	let ret = []

	for i in range(0, len(segments) - 1)
		unlet! seg_prev seg_curr seg_next

		" Prepare some resources (fetch previous, current and next segment)
		let seg_curr = deepcopy(get(segments, i))

		" Find previous segment
		let seg_prev = s:EMPTY_SEGMENT

		" If we're currently at i = 0 we have to start on 0 or else we will start on the last segment (list[-1])
		let range_start = (i == 0 ? i : i - 1)
		for j in range(range_start, 0, -1)
			let seg = deepcopy(get(segments, j))
			if get(seg, 'name') ==# 'TRUNCATE'
				" Skip truncate segments
				continue
			endif

			" Look ahead for another segment that's visible in this mode
			if index(get(seg, 'modes'), mode) != -1
				" Use this segment
				let seg_prev = seg

				break
			endif
		endfor

		"" Find next segment
		let seg_next = s:EMPTY_SEGMENT

		" If we're currently at i = len(segments) - 1 we have to start on i or else we will get an error because the index doesn't exist
		let range_start = (i == len(segments) - 1 ? i : i + 1)
		for j in range(range_start, len(segments) - 1, 1)
			let seg = deepcopy(get(segments, j))
			if get(seg, 'name') ==# 'TRUNCATE'
				" Skip truncate segments
				continue
			endif

			" Look ahead for another segment that's visible in this mode
			if index(get(seg, 'modes'), mode) != -1
				" Use this segment
				let seg_next = seg

				break
			endif
		endfor

		if index(get(seg_curr, 'modes', []), mode) == -1
			" The segment is invisible in this mode, skip it
			" FIXME When two segments after each other are hidden, a gap appears where the segments would be, this is probably due to segment padding
			continue
		endif

		" Handle the different segment types
		if seg_curr.type == 'segment'
			if seg_curr.name ==# 'TRUNCATE'
				" Truncate statusline
				call add(ret, '%<')
			elseif seg_curr.name ==# 'SPLIT'
				" Split statusline

				" Switch sides
				let side = s:RIGHT_SIDE

				" Handle highlighting
				let mode_colors = get(seg_curr.colors, mode, seg_curr.colors['n'])
				let hl_group = s:HlCreate(mode_colors)

				" Add segment text
				call add(ret, '%#'. hl_group .'#%=')
			else
				" Add segment text
				let text = seg_curr.text

				" Decide on whether to use the group's colors or the segment's colors
				let colors = get(seg_curr, 'colors', base_color)

				" Fallback to normal (current) highlighting if we don't have mode-specific highlighting
				let mode_colors = get(colors, mode, get(colors, 'n', {}))

				if empty(mode_colors)
					echom 'Segment doesn''t have any colors! NS: "'. seg_curr.ns .'" SEG: "'. seg_curr.name .'"'

					continue
				endif

				" Check if we're in a group (level > 0)
				if level > 0
					" If we're in a group we don't have dividers between
					" segments, so we should only pad one side, but only pad
					" if the segment doesn't have Pl#Segment#NoPadding() set
					let padding_right = (seg_curr.padding && side == s:LEFT_SIDE  ? repeat(' ', s:PADDING) : '')
					let padding_left  = (seg_curr.padding && side == s:RIGHT_SIDE ? repeat(' ', s:PADDING) : '')

					" Check if we lack a bg/fg color for this segment
					" If we do, use the bg/fg color from base_color
					let base_color_mode = ! has_key(base_color, mode) ? base_color['n'] : base_color[mode]

					for col in ['ctermbg', 'ctermfg', 'guibg', 'guifg']
						if empty(mode_colors[col])
							let mode_colors[col] = base_color_mode[col]
						endif
					endfor
				else
					"" If we're outside a group we have dividers and must pad both sides
					let padding_left  = repeat(' ', s:PADDING)
					let padding_right = repeat(' ', s:PADDING)
				endif

				" Get main hl group for segment
				let hl_group = s:HlCreate(mode_colors)

				" Prepare segment text
				let text = '%(%#'. hl_group .'#'. padding_left . text . padding_right . '%)'

				if level == 0
					" Add divider to single segments
					let text = s:AddDivider(text, side, mode, colors, seg_prev, seg_curr, seg_next)
				endif

				call add(ret, text)
			endif
		elseif seg_curr.type == 'segment_group'
			" Recursively parse segment group
			let func_params = [mode, side, seg_curr.segments, level + 1]

			if has_key(seg_curr, 'colors')
				" Pass the base colors on to the child segments
				call add(func_params, seg_curr.colors)
			endif

			" Get segment group string
			let text = join(call('s:ParseSegments', func_params), '')

			" Pad on the opposite side of the divider
			let padding_right = (side == s:RIGHT_SIDE ? repeat(' ', s:PADDING) : '')
			let padding_left  = (side == s:LEFT_SIDE  ? repeat(' ', s:PADDING) : '')

			let text = s:AddDivider(padding_left . text . padding_right, side, mode, seg_curr.colors, seg_prev, seg_curr, seg_next)

			call add(ret, text)
		endif
	endfor

	return ret
endfunction " }}}
function! s:HlCreate(hl) " {{{
	" Create a short and unique highlighting group name
	" It uses the hex values of all the color properties and an attribute flag at the end
	" NONE colors are translated to NN for cterm and NNNNNN for gui colors
	let hi_group = printf('Pl%s%s%s%s%s'
		\ , (a:hl['ctermfg'] == 'NONE' ? 'NN'     : printf('%02x', a:hl['ctermfg']))
		\ , (a:hl['guifg']   == 'NONE' ? 'NNNNNN' : printf('%06x', a:hl['guifg']  ))
		\ , (a:hl['ctermbg'] == 'NONE' ? 'NN'     : printf('%02x', a:hl['ctermbg']))
		\ , (a:hl['guibg']   == 'NONE' ? 'NNNNNN' : printf('%06x', a:hl['guibg']  ))
		\ , substitute(a:hl['attr'], '\v([a-zA-Z])[a-zA-Z]*,?', '\1', 'g')
		\ )

	if ! s:HlExists(hi_group)
		let ctermbg = a:hl['ctermbg'] == 'NONE' ? 'NONE' : printf('%d', a:hl['ctermbg'])
		if (has('win32') || has('win64')) && !has('gui_running') && ctermbg != 'NONE' && ctermbg > 128
			let ctermbg -= 128
		endif
		let hi_cmd = printf('hi %s ctermfg=%s ctermbg=%s cterm=%s guifg=%s guibg=%s gui=%s'
			\ , hi_group
			\ , a:hl['ctermfg'] == 'NONE' ? 'NONE' : printf('%d', a:hl['ctermfg'])
			\ , ctermbg
			\ , a:hl['attr']
			\ , (a:hl['guifg'] == 'NONE' ? 'NONE' : printf('#%06x', a:hl['guifg']))
			\ , (a:hl['guibg'] == 'NONE' ? 'NONE' : printf('#%06x', a:hl['guibg']))
			\ , a:hl['attr']
			\ )

		exec hi_cmd

		" Add command to Pl#HL list for caching
		call add(g:Pl#HL, hi_cmd)
	endif

	" Return only the highlighting group name
	return hi_group
endfunction " }}}
function! s:HlExists(hl) " {{{
	if ! hlexists(a:hl)
		return 0
	endif

	redir => hlstatus
	silent exec 'hi' a:hl
	redir END

	return (hlstatus !~ 'cleared')
endfunction " }}}
function! s:AddDivider(text, side, mode, colors, prev, curr, next) " {{{
	let seg_prev = a:prev
	let seg_curr = a:curr
	let seg_next = a:next

	" Set default color/type for the divider
	let div_colors = get(a:colors, a:mode, a:colors['n'])
	let div_type = s:SOFT_DIVIDER

	" Define segment to compare
	let cmp_seg = a:side == s:LEFT_SIDE ? seg_next : seg_prev

	let cmp_all_colors = get(cmp_seg, 'colors', {})
	let cmp_colors = get(cmp_all_colors, a:mode, get(cmp_all_colors, 'n', {}))

	if ! empty(cmp_colors)
		" Compare the highlighting groups
		"
		" If the background color for cterm is equal, use soft divider with the current segment's highlighting
		" If not, use hard divider with a new highlighting group
		"
		" Note that if the previous/next segment is the split, a hard divider is always used
		if get(div_colors, 'ctermbg') != get(cmp_colors, 'ctermbg') || get(seg_next, 'name') ==# 'SPLIT' || get(seg_prev, 'name') ==# 'SPLIT'
			let div_type = s:HARD_DIVIDER

			" Create new highlighting group
			if div_colors['attr'] =~ 'reverse' && cmp_colors['attr'] =~ 'reverse'
				" Use FG = CURRENT FG, BG = CMP FG
				let div_colors['ctermbg'] = get(cmp_colors, 'ctermfg')
				let div_colors['guibg']   = get(cmp_colors, 'guifg')

				let div_colors['attr']    = div_colors['attr'] =~ 'bold' ? 'bold' : 'NONE'
			elseif div_colors['attr'] =~ 'reverse'
				" Use FG = CURRENT FG, BG = CMP BG
				let div_colors['ctermbg'] = get(cmp_colors, 'ctermbg')
				let div_colors['guibg']   = get(cmp_colors, 'guibg')

				let div_colors['attr']    = div_colors['attr'] =~ 'bold' ? 'bold' : 'NONE'
			elseif cmp_colors['attr'] =~ 'reverse'
				" Use FG = CMP FG, BG = CURRENT BG : reversed
				let div_colors['ctermfg'] = get(cmp_colors, 'ctermfg')
				let div_colors['guifg']   = get(cmp_colors, 'guifg')

				let div_colors['attr']    = 'reverse'

			else
				" Use FG = CURRENT BG, BG = CMP BG
				let div_colors['ctermfg'] = get(div_colors, 'ctermbg')
				let div_colors['guifg']   = get(div_colors, 'guibg')

				let div_colors['ctermbg'] = get(cmp_colors, 'ctermbg')
				let div_colors['guibg']   = get(cmp_colors, 'guibg')

				let div_colors['attr']    = 'NONE'
			endif
		endif
	endif

	" Prepare divider
	let divider_raw = deepcopy(g:Pl#Parser#Symbols[g:Powerline_symbols].dividers[a:side + div_type])
	let divider = Pl#Parser#ParseChars(divider_raw)

	" Don't add dividers for segments adjacent to split (unless it's a hard divider)
	if ((get(seg_next, 'name') ==# 'SPLIT' || get(seg_prev, 'name') ==# 'SPLIT') && div_type != s:HARD_DIVIDER)
		return ''
	endif

	if a:side == s:LEFT_SIDE
		" Left side
		" Divider to the right
		return printf('%%(%s%%#%s#%s%%)', a:text, s:HlCreate(div_colors), divider)
	else
		" Right side
		" Divider to the left
		return printf('%%(%%#%s#%s%s%%)', s:HlCreate(div_colors), divider, a:text)
	endif
endfunction " }}}
function! Pl#Match#Add(pat, expr) " {{{
	return [a:pat, a:expr]
endfunction " }}}
function! Pl#Match#Any(...) " {{{
	let matches = []

	for match_name in a:000
		if empty(match_name)
			" Skip empty match parameters
			continue
		endif

		if has_key(g:Powerline#Matches#matches, match_name)
			call add(matches, g:Powerline#Matches#matches[match_name])
		endif

		unlet! match_name
	endfor

	return ['match', 'any', matches]
endfunction " }}}
function! Pl#Match#Validate(theme, window) " {{{
	let match = a:theme.matches[1]

	if match == 'none'
		return 0
	elseif match == 'any'
		let matches = a:theme.matches[2]

		if ! len(matches)
			" Empty match array matches everything
			return 1
		endif

		for [eval, re] in matches
			if match(eval(eval), '\v\C'. re) != -1
				return 1
			endif
		endfor

		return 0
	endif
endfunction " }}}
let s:segment_mods = []

function! Pl#Mod#AddSegmentMod(action, properties) " {{{
	call add(s:segment_mods, [a:action, a:properties])
endfunction " }}}
function! Pl#Mod#ApplySegmentMods(theme) " {{{
	let theme = deepcopy(a:theme)

	for mod in s:segment_mods
		let [action, properties] = mod

		" We have to loop through the segments instead of using index() because some
		" segments are lists!
		let target_seg_idx = -1

		for i in range(0, len(theme) - 1)
			unlet! segment
			let segment = theme[i]

			if type(segment) == type(properties.target_segment) && segment == properties.target_segment
				let target_seg_idx = i
				break
			endif
		endfor

		if action == 'insert_segment'
			" Insert segment
			if target_seg_idx != -1
				call insert(theme, properties.new_segment, (properties.where == 'before' ? target_seg_idx : target_seg_idx + 1))
			endif
		elseif action == 'remove_segment'
			" Remove segment
			if target_seg_idx != -1
				call remove(theme, target_seg_idx)
			endif
		endif
	endfor

	return theme
endfunction " }}}
function! Pl#Theme#Create(...) " {{{
	let buffer_segments = []

	for buffer_segment in a:000
		" Remove empty segments (e.g. 'Pl#Theme#Function's)
		if empty(buffer_segment)
			continue
		endif

		call add(buffer_segments, buffer_segment)
	endfor

	let buffer_segments = Pl#Colorscheme#Apply(g:Powerline_colorscheme, buffer_segments)

	return buffer_segments
endfunction " }}}
function! Pl#Theme#Callback(name, expr) " {{{
	return ['callback', a:name, a:expr]
endfunction " }}}
function! Pl#Theme#Buffer(ns, ...) " {{{
	let segments = []
	let ns = ! empty(a:ns) ? a:ns .':' : ''

	" Match namespace parameter by default
	let matches = Pl#Match#Any(a:ns)
	let callback = []

	let args = a:000
	let args = Pl#Mod#ApplySegmentMods(args)

	" Fetch segment data dicts
	for item in args
		if type(item) == type([])
			if item[0] == 'match'
				" Match item, overrides default namespace match
				let matches = item

				unlet! item
				continue
			elseif item[0] == 'callback'
				" Store the item as a callback expression
				let matches = ['match', 'none']
				let callback = [a:ns, item[1], item[2]]

				unlet! item
				continue
			endif

			" printf segment, append ns to first item in list
			let item[0] = ns . item[0]
		else
			let item = ns . item
		endif

		let segment = Pl#Segment#Get(item)

		if ! empty(segment)
			" Skip empty (possible disabled) segments
			call add(segments, segment)
		endif

		unlet! item
	endfor

	return {
		\   'matches': matches
		\ , 'callback': callback
		\ , 'segments': segments
		\ }
endfunction " }}}
function! Pl#Theme#InsertSegment(new_segment, where, target_segment) " {{{
	" It's very important to NOT refer to the theme dict until everything's loaded!
	"
	" Because these functions are called from the vimrc, we need to put the
	" actions in a list which will be parsed later.
	"
	" These functions don't accept a name parameter, because they work on the
	" currently selected theme (will change any selected theme)
	call Pl#Mod#AddSegmentMod('insert_segment', {
		\ 'new_segment': a:new_segment,
		\ 'where': a:where,
		\ 'target_segment': a:target_segment
		\ })
endfunction " }}}
function! Pl#Theme#RemoveSegment(target_segment) " {{{
	" It's very important to NOT refer to the theme dict until everything's loaded!
	"
	" Because these functions are called from the vimrc, we need to put the
	" actions in a list which will be parsed later.
	"
	" These functions don't accept a name parameter, because they work on the
	" currently selected theme (will change any selected theme)
	call Pl#Mod#AddSegmentMod('remove_segment', {
		\ 'target_segment': a:target_segment
		\ })
endfunction " }}}
function! Pl#Theme#ReplaceSegment(old_segment, new_segment) " {{{
	call Pl#Theme#InsertSegment(a:new_segment, 'after', a:old_segment)
	call Pl#Theme#RemoveSegment(a:old_segment)
endfunction " }}}
" cterm -> gui color dict {{{
let s:cterm2gui_dict = {
	\ 16:  0x000000, 17:  0x00005f, 18:  0x000087, 19:  0x0000af, 20:  0x0000d7, 21:  0x0000ff,
	\ 22:  0x005f00, 23:  0x005f5f, 24:  0x005f87, 25:  0x005faf, 26:  0x005fd7, 27:  0x005fff,
	\ 28:  0x008700, 29:  0x00875f, 30:  0x008787, 31:  0x0087af, 32:  0x0087d7, 33:  0x0087ff,
	\ 34:  0x00af00, 35:  0x00af5f, 36:  0x00af87, 37:  0x00afaf, 38:  0x00afd7, 39:  0x00afff,
	\ 40:  0x00d700, 41:  0x00d75f, 42:  0x00d787, 43:  0x00d7af, 44:  0x00d7d7, 45:  0x00d7ff,
	\ 46:  0x00ff00, 47:  0x00ff5f, 48:  0x00ff87, 49:  0x00ffaf, 50:  0x00ffd7, 51:  0x00ffff,
	\ 52:  0x5f0000, 53:  0x5f005f, 54:  0x5f0087, 55:  0x5f00af, 56:  0x5f00d7, 57:  0x5f00ff,
	\ 58:  0x5f5f00, 59:  0x5f5f5f, 60:  0x5f5f87, 61:  0x5f5faf, 62:  0x5f5fd7, 63:  0x5f5fff,
	\ 64:  0x5f8700, 65:  0x5f875f, 66:  0x5f8787, 67:  0x5f87af, 68:  0x5f87d7, 69:  0x5f87ff,
	\ 70:  0x5faf00, 71:  0x5faf5f, 72:  0x5faf87, 73:  0x5fafaf, 74:  0x5fafd7, 75:  0x5fafff,
	\ 76:  0x5fd700, 77:  0x5fd75f, 78:  0x5fd787, 79:  0x5fd7af, 80:  0x5fd7d7, 81:  0x5fd7ff,
	\ 82:  0x5fff00, 83:  0x5fff5f, 84:  0x5fff87, 85:  0x5fffaf, 86:  0x5fffd7, 87:  0x5fffff,
	\ 88:  0x870000, 89:  0x87005f, 90:  0x870087, 91:  0x8700af, 92:  0x8700d7, 93:  0x8700ff,
	\ 94:  0x875f00, 95:  0x875f5f, 96:  0x875f87, 97:  0x875faf, 98:  0x875fd7, 99:  0x875fff,
	\ 100: 0x878700, 101: 0x87875f, 102: 0x878787, 103: 0x8787af, 104: 0x8787d7, 105: 0x8787ff,
	\ 106: 0x87af00, 107: 0x87af5f, 108: 0x87af87, 109: 0x87afaf, 110: 0x87afd7, 111: 0x87afff,
	\ 112: 0x87d700, 113: 0x87d75f, 114: 0x87d787, 115: 0x87d7af, 116: 0x87d7d7, 117: 0x87d7ff,
	\ 118: 0x87ff00, 119: 0x87ff5f, 120: 0x87ff87, 121: 0x87ffaf, 122: 0x87ffd7, 123: 0x87ffff,
	\ 124: 0xaf0000, 125: 0xaf005f, 126: 0xaf0087, 127: 0xaf00af, 128: 0xaf00d7, 129: 0xaf00ff,
	\ 130: 0xaf5f00, 131: 0xaf5f5f, 132: 0xaf5f87, 133: 0xaf5faf, 134: 0xaf5fd7, 135: 0xaf5fff,
	\ 136: 0xaf8700, 137: 0xaf875f, 138: 0xaf8787, 139: 0xaf87af, 140: 0xaf87d7, 141: 0xaf87ff,
	\ 142: 0xafaf00, 143: 0xafaf5f, 144: 0xafaf87, 145: 0xafafaf, 146: 0xafafd7, 147: 0xafafff,
	\ 148: 0xafd700, 149: 0xafd75f, 150: 0xafd787, 151: 0xafd7af, 152: 0xafd7d7, 153: 0xafd7ff,
	\ 154: 0xafff00, 155: 0xafff5f, 156: 0xafff87, 157: 0xafffaf, 158: 0xafffd7, 159: 0xafffff,
	\ 160: 0xd70000, 161: 0xd7005f, 162: 0xd70087, 163: 0xd700af, 164: 0xd700d7, 165: 0xd700ff,
	\ 166: 0xd75f00, 167: 0xd75f5f, 168: 0xd75f87, 169: 0xd75faf, 170: 0xd75fd7, 171: 0xd75fff,
	\ 172: 0xd78700, 173: 0xd7875f, 174: 0xd78787, 175: 0xd787af, 176: 0xd787d7, 177: 0xd787ff,
	\ 178: 0xd7af00, 179: 0xd7af5f, 180: 0xd7af87, 181: 0xd7afaf, 182: 0xd7afd7, 183: 0xd7afff,
	\ 184: 0xd7d700, 185: 0xd7d75f, 186: 0xd7d787, 187: 0xd7d7af, 188: 0xd7d7d7, 189: 0xd7d7ff,
	\ 190: 0xd7ff00, 191: 0xd7ff5f, 192: 0xd7ff87, 193: 0xd7ffaf, 194: 0xd7ffd7, 195: 0xd7ffff,
	\ 196: 0xff0000, 197: 0xff005f, 198: 0xff0087, 199: 0xff00af, 200: 0xff00d7, 201: 0xff00ff,
	\ 202: 0xff5f00, 203: 0xff5f5f, 204: 0xff5f87, 205: 0xff5faf, 206: 0xff5fd7, 207: 0xff5fff,
	\ 208: 0xff8700, 209: 0xff875f, 210: 0xff8787, 211: 0xff87af, 212: 0xff87d7, 213: 0xff87ff,
	\ 214: 0xffaf00, 215: 0xffaf5f, 216: 0xffaf87, 217: 0xffafaf, 218: 0xffafd7, 219: 0xffafff,
	\ 220: 0xffd700, 221: 0xffd75f, 222: 0xffd787, 223: 0xffd7af, 224: 0xffd7d7, 225: 0xffd7ff,
	\ 226: 0xffff00, 227: 0xffff5f, 228: 0xffff87, 229: 0xffffaf, 230: 0xffffd7, 231: 0xffffff,
	\ 232: 0x080808, 233: 0x121212, 234: 0x1c1c1c, 235: 0x262626, 236: 0x303030, 237: 0x3a3a3a,
	\ 238: 0x444444, 239: 0x4e4e4e, 240: 0x585858, 241: 0x626262, 242: 0x6c6c6c, 243: 0x767676,
	\ 244: 0x808080, 245: 0x8a8a8a, 246: 0x949494, 247: 0x9e9e9e, 248: 0xa8a8a8, 249: 0xb2b2b2,
	\ 250: 0xbcbcbc, 251: 0xc6c6c6, 252: 0xd0d0d0, 253: 0xdadada, 254: 0xe4e4e4, 255: 0xeeeeee
\ }
" }}}
" Allocated color dict {{{
let s:allocated_colors = {
	\ 'NONE': 'NONE',
	\ }
" }}}
function! s:Cterm2GUI(cterm) " {{{
	if toupper(a:cterm) == 'NONE'
		return 'NONE'
	endif

	if ! has_key(s:cterm2gui_dict, a:cterm)
		return 0xff0000
	endif

	return s:cterm2gui_dict[a:cterm]
endfunction " }}}
function! Pl#Hi#Segments(segments, mode_colors) " {{{
	let mode_translate = {
		\ 'normal':     'n',
		\ 'noncurrent': 'N',
		\ 'insert':     'i',
		\ 'visual':     'v',
		\ 'replace':    'r',
		\ 'select':     's',
		\ }

	let attributes = ['bold', 'italic', 'underline']

	let segments = a:segments
	let mode_hi_dict = {}

	" Mode dict
	for [mode, colors] in items(a:mode_colors)
		if has_key(mode_translate, mode)
			let mode = mode_translate[mode]
		endif

		unlet! fg
		let fg = s:allocated_colors[colors[0]]

		let hi = {
			\ 'cterm': [fg['cterm'], ''],
			\ 'gui'  : [fg['gui'], ''],
			\ 'attr' : []
			\ }

		if exists('colors[1]')
			if type(colors[1]) == type([])
				" We don't have a BG color, but we have attributes
				let hi.attr = colors[1]
			else
				" The second parameter is the background color
				unlet! bg
				let bg = s:allocated_colors[colors[1]]

				let hi.cterm[1] = bg['cterm']
				let hi.gui[1] = bg['gui']
			endif
		endif

		if exists('colors[2]') && type(colors[2]) == type([])
			" The third parameter is always an attribute list
			let hi.attr = colors[2]
		endif

		let mode_hi_dict[mode] = {
			\ 'ctermfg': (empty(hi['cterm'][0]) ? '' : (string(hi['cterm'][0]) == 'NONE' ? 'NONE' : hi['cterm'][0])),
			\ 'ctermbg': (empty(hi['cterm'][1]) ? '' : (string(hi['cterm'][1]) == 'NONE' ? 'NONE' : hi['cterm'][1])),
			\ 'guifg'  : (empty(hi['gui'][0]) ? '' : (string(hi['gui'][0]) == 'NONE' ? 'NONE' : hi['gui'][0])),
			\ 'guibg'  : (empty(hi['gui'][1]) ? '' : (string(hi['gui'][1]) == 'NONE' ? 'NONE' : hi['gui'][1])),
			\ 'attr'   : (! len(hi['attr']) ? 'NONE' : join(hi['attr'], ','))
			\ }
	endfor

	return [segments, mode_hi_dict]
endfunction " }}}
function! Pl#Hi#Allocate(colors) " {{{
	for [key, color] in items(a:colors)
		if type(color) == type(0)
			" Only terminal color
			let cterm = color
			let gui = s:Cterm2GUI(color)
		elseif type(color) == type([]) && len(color) == 2
			" Terminal and GUI colors
			let cterm = color[0]
			let gui = color[1]
		endif

		let s:allocated_colors[key] = {
			\ 'cterm': cterm,
			\ 'gui': gui,
			\ }

		unlet! color
	endfor
endfunction " }}}
function! Pl#Colorscheme#Init(hi) " {{{
	let colorscheme = {}

	for hi in a:hi
		" Ensure that the segments are a list
		let segments = type(hi[0]) == type('') ? [ hi[0] ] : hi[0]
		let mode_hi_dict = hi[1]

		for segment in segments
			let colorscheme[segment] = mode_hi_dict
		endfor
	endfor

	return colorscheme
endfunction " }}}
function! Pl#Colorscheme#Apply(colorscheme, buffer_segments) " {{{
	" Set color parameters for all segments in a:buffer_segments

	" TODO This function should be recursive and work on both segments and groups
	" TODO We could probably handle the NS stuff here...

	try
		let colorscheme = g:Powerline#Colorschemes#{a:colorscheme}#colorscheme
	catch
		echom 'Color scheme "'. a:colorscheme .'" doesn''t exist!'

		return
	endtry

	let buffer_segments = a:buffer_segments

	" This is a bit complex, I'll walk you through exactly what happens here...
	"
	" First of all we loop through the buffer_segments, which are the segments that
	" this specific buffer will have.
	for buffer_segment in buffer_segments
		" The buffer_segment consists of a 'matches' list and a 'segments' list.
		" The 'matches' list has conditions to limit this statusline to specific buffers/windows.
		" The 'segments' list has each segment and segment group for this buffer
		for segment in buffer_segment.segments
			let type = get(segment, 'type', '')

			if type == 'segment_group'
				" We're going to handle segment groups different from single segments. Segment groups
				" have child segments which may have their own highlighting (e.g. fileinfo.flags),
				" and these child segments may be grouped (e.g. fileinfo.flags.ro) to provide very
				" specific highlighting. So here we'll handle all that:

				" Set the default/fallback colors for this group
				for i in range(len(segment.variants), 0, -1)
					" Check for available highlighting for the main group segment
					"
					" This works like the segment highlighting below
					" TODO Create a function for this
					let seg_variants = join(segment.variants[0:i], '.')

					let seg_name = i > 0 ? segment.name .'.'. seg_variants : segment.name
					let seg_ns_name = len(segment.ns) > 0 ? segment.ns .':'. seg_name : seg_name

					if has_key(colorscheme, seg_ns_name)
						" We have a namespaced highlight group
						let segment.colors = colorscheme[seg_ns_name]
						break
					elseif has_key(colorscheme, seg_name)
						" We have a non-namespaced group
						let segment.colors = colorscheme[seg_name]
						break
					endif
				endfor

				" The reason why we need to deepcopy the group's segments is that the child segments
				" all point to the same base segments and that screws up highlighting if we highlight
				" some child segments with different namespaced colors
				let segment.segments = deepcopy(segment.segments)

				" Apply colors to each child segment
				for child_segment in segment.segments
					" Check if this child segment is grouped (e.g. fileinfo.flags.group.subgroup)
					" We're going to prioritize the most specific grouping and then work back to the
					" most common group (e.g. fileinfo.flags)

					" FIXME We don't have the variants from before because group children aren't run through Pl#Segment#Get
					let child_segment.variants = [seg_name] + split(child_segment.name, '\.')

					" Use the parent group's namespace
					let child_segment.ns = segment.ns

					for i in range(len(child_segment.variants), 0, -1)
						" Check for available highlighting for the main group segment
						let child_seg_name = join(child_segment.variants[0:i], '.')

						let child_seg_ns_name = len(child_segment.ns) > 0 ? child_segment.ns .':'. child_seg_name : child_seg_name

						if has_key(colorscheme, child_seg_ns_name)
							" We have a namespaced highlight group
							let child_segment.colors = colorscheme[child_seg_ns_name]
							break
						elseif has_key(colorscheme, child_seg_name)
							" We have a non-namespaced group
							let child_segment.colors = colorscheme[child_seg_name]
							break
						endif
					endfor
				endfor
			elseif type == 'segment'
				for i in range(len(segment.variants), 0, -1)
					" Check for available highlighting
					"
					" This is done in the following manner, using the segment gundo:static_filename.text.buffer as an example:
					"
					" * Look for the hl group: gundo:static_filename.text.buffer
					" * Look for the hl group:       static_filename.text.buffer
					" * Look for the hl group: gundo:static_filename.text
					" * Look for the hl group:       static_filename.text
					" * Look for the hl group: gundo:static_filename
					" * Look for the hl group:       static_filename
					" * Return the segment without highlighting, causing an error in the parser
					let seg_variants = join(segment.variants[0:i], '.')

					let seg_name = i > 0 ? segment.name .'.'. seg_variants : segment.name
					let seg_ns_name = len(segment.ns) > 0 ? segment.ns .':'. seg_name : seg_name

					if has_key(colorscheme, seg_ns_name)
						" We have a namespaced highlight group
						let segment.colors = colorscheme[seg_ns_name]
						break
					elseif has_key(colorscheme, seg_name)
						" We have a non-namespaced group
						let segment.colors = colorscheme[seg_name]
						break
					endif
				endfor
			endif

			unlet! segment
		endfor
	endfor

	" Good luck parsing this return value
	"
	" It's a huge dict with all segments for all buffers with their respective syntax highlighting.
	" It will be parsed by the main Powerline code, where all the data will be shortened to a simple
	" array consiting of a statusline for each mode, with generated highlighting groups and dividers.
	return buffer_segments
endfunction " }}}
" Recalculate the trailing whitespace warning when idle, and after saving
autocmd CursorHold,BufWritePost,InsertLeave * unlet! b:statusline_trailing_space_warning

function! Powerline#Functions#GetFilepath() " {{{
	" Recalculate the filepath when cwd changes.
	let cwd = getcwd()
	if exists("b:Powerline_cwd") && cwd != b:Powerline_cwd
		unlet! b:Powerline_filepath
	endif
	let b:Powerline_cwd = cwd

	if exists('b:Powerline_filepath')
		return b:Powerline_filepath
	endif

	let dirsep = has('win32') && ! &shellslash ? '\' : '/'
	let filepath = expand('%:p')

	if empty(filepath)
		return ''
	endif

	let ret = ''

	if g:Powerline_stl_path_style == 'short'
		" Display a short path where the first directory is displayed with its
		" full name, and the subsequent directories are shortened to their
		" first letter, i.e. "/home/user/foo/foo/bar/baz.vim" becomes
		" "~/foo/f/b/baz.vim"
		"
		" This displays the shortest possible path, relative to ~ or the
		" current directory.
		let mod = (exists('+acd') && &acd) ? ':~:h' : ':~:.:h'
		let fpath = split(fnamemodify(filepath, mod), dirsep)
		let fpath_shortparts = map(fpath[1:], 'v:val[0]')
		let ret = join(extend([fpath[0]], fpath_shortparts), dirsep) . dirsep
	elseif g:Powerline_stl_path_style == 'relative'
		" Display a relative path, similar to the %f statusline item
		let ret = fnamemodify(filepath, ':~:.:h') . dirsep
	elseif g:Powerline_stl_path_style == 'full'
		" Display the full path, similar to the %F statusline item
		let ret = fnamemodify(filepath, ':h') . dirsep
	endif

	if ret == ('.' . dirsep)
		let ret = ''
	endif

	let b:Powerline_filepath = ret
	return ret
endfunction " }}}
function! Powerline#Functions#GetShortPath(threshold) " {{{
	let fullpath = split(expand('%:~'), '[/\\]')

	if len(fullpath) > a:threshold
		let fullpath = [fullpath[0], '…'] +  fullpath[-a:threshold + 1 :]
	endif

	return join(fullpath, '/')
endfunction " }}}
function! Powerline#Functions#GetMode() " {{{
	let mode = mode()

	if mode ==# 'v'
		let mode = get(g:, "Powerline_mode_v", "VISUAL")
	elseif mode ==# 'V'
		let mode = get(g:, "Powerline_mode_V", "V⋅LINE")
	elseif mode ==# ''
		let mode = get(g:, "Powerline_mode_cv", "V⋅BLOCK")
	elseif mode ==# 's'
		let mode = get(g:, "Powerline_mode_s", "SELECT")
	elseif mode ==# 'S'
		let mode = get(g:, "Powerline_mode_S", "S⋅LINE")
	elseif mode ==# ''
		let mode = get(g:, "Powerline_mode_cs", "S⋅BLOCK")
	elseif mode =~# '\vi'
		let mode = get(g:, "Powerline_mode_i", "INSERT")
	elseif mode =~# '\v(R|Rv)'
		let mode = get(g:, "Powerline_mode_R", "REPLACE")
	else
		" Fallback to normal mode
		let mode = get(g:, "Powerline_mode_n", "NORMAL")
	endif

	return mode
endfunction " }}}
function! Powerline#Functions#GetFilesize() " {{{
	let bytes = getfsize(expand("%:p"))

	if bytes <= 0
		return ''
	endif

	if bytes < 1024
		return bytes . 'B'
	else
		return (bytes / 1024) . 'kB'
	endif
endfunction "}}}
function! Powerline#Functions#GetCharCode() " {{{
	" Get the output of :ascii
	redir => ascii
	silent! ascii
	redir END

	if match(ascii, 'NUL') != -1
		return 'NUL'
	endif

	" Zero pad hex values
	let nrformat = '0x%02x'

	let encoding = (&fenc == '' ? &enc : &fenc)

	if encoding == 'utf-8'
		" Zero pad with 4 zeroes in unicode files
		let nrformat = '0x%04x'
	endif

	" Get the character and the numeric value from the return value of :ascii
	" This matches the two first pieces of the return value, e.g.
	" "<F>  70" => char: 'F', nr: '70'
	let [str, char, nr; rest] = matchlist(ascii, '\v\<(.{-1,})\>\s*([0-9]+)')

	" Format the numeric value
	let nr = printf(nrformat, nr)

	return "'". char ."' ". nr
endfunction "}}}
function! Powerline#Functions#GetWSMarker() " {{{
	" Return '...' if trailing white space is detected
	" Return '' otherwise
	if ! exists("b:statusline_trailing_space_warning")
		if search('\s$', 'nw') != 0
			let b:statusline_trailing_space_warning = ' … '
		else
			let b:statusline_trailing_space_warning = ''
		endif
	endif
	return b:statusline_trailing_space_warning
endfunction " }}}
let g:Powerline#Segments#segments = Pl#Segment#Init([
	\ Pl#Segment#Create('SPLIT'   , '__split__'),
	\ Pl#Segment#Create('TRUNCATE', '__truncate__'),
	\
	\ Pl#Segment#Create('paste_indicator' , '%{&paste ? "PASTE" : ""}', Pl#Segment#Modes('!N')),
	\ Pl#Segment#Create('mode_indicator'  , '%{Powerline#Functions#GetMode()}', Pl#Segment#Modes('!N')),
	\ Pl#Segment#Create('fileinfo',
		\ Pl#Segment#Create('flags.ro'    , '%{&readonly ? "$RO" : ""}'),
		\ Pl#Segment#Create('filepath'    , '%{Powerline#Functions#GetFilepath()}', Pl#Segment#NoPadding()),
		\ Pl#Segment#Create('filename'    , '%t'),
		\ Pl#Segment#Create('flags.mod'   , '%M'),
		\ Pl#Segment#Create('flags.type'  , '%H%W'),
	\ ),
	\ Pl#Segment#Create('filename'        , '%t'),
	\ Pl#Segment#Create('filesize'        , '%{Powerline#Functions#GetFilesize()}', Pl#Segment#Modes('!N')),
	\ Pl#Segment#Create('pwd'             , '%{substitute(getcwd(), expand("$HOME"), "~", "g")}'),
	\ Pl#Segment#Create('static_str'      , '%%{"%s"}'),
	\ Pl#Segment#Create('raw'             , '%s'),
	\ Pl#Segment#Create('fileformat'      , '%{&fileformat}', Pl#Segment#Modes('!N')),
	\ Pl#Segment#Create('fileencoding'    , '%{(&fenc == "" ? &enc : &fenc)}', Pl#Segment#Modes('!N')),
	\ Pl#Segment#Create('filetype'        , '%{strlen(&ft) ? &ft : "no ft"}', Pl#Segment#Modes('!N')),
	\ Pl#Segment#Create('scrollpercent'   , '%3p%%'),
	\ Pl#Segment#Create('lineinfo',
		\ Pl#Segment#Create('line.cur'    , '$LINE %3l'),
		\ Pl#Segment#Create('line.tot'    , ':%-2v', Pl#Segment#NoPadding()),
	\ ),
	\ Pl#Segment#Create('charcode'        , '%{Powerline#Functions#GetCharCode()}', Pl#Segment#Modes('!N')),
	\ Pl#Segment#Create('currhigroup'     , '%{synIDattr(synID(line("."), col("."), 1), "name")}', Pl#Segment#Modes('!N')),
	\ Pl#Segment#Create('ws_marker'       , '%{Powerline#Functions#GetWSMarker()}', Pl#Segment#Modes('!N')),
\ ])
let g:Powerline#Matches#matches = {
	\ 'command_t'       : Pl#Match#Add('bufname(winbufnr(a:window))', '^GoToFile$'),
	\ 'bt_help'         : Pl#Match#Add('getwinvar(a:window, "&bt")' , '^help$'),
	\ 'ft_man'          : Pl#Match#Add('getwinvar(a:window, "&ft")' , '^man$'),
	\ 'ft_qf'           : Pl#Match#Add('getwinvar(a:window, "&ft")' , '^qf$'),
	\ 'ft_vimpager'     : Pl#Match#Add('getwinvar(a:window, "&ft")' , 'vimpager'),
	\ 'gundo_preview'   : Pl#Match#Add('bufname(winbufnr(a:window))', '^__Gundo_Preview__$'),
	\ 'gundo_tree'      : Pl#Match#Add('bufname(winbufnr(a:window))', '^__Gundo__$'),
	\ 'lustyexplorer'   : Pl#Match#Add('bufname(winbufnr(a:window))', '\[LustyExplorer\-Buffers\]'),
	\ 'minibufexplorer' : Pl#Match#Add('bufname(winbufnr(a:window))', '^\-MiniBufExplorer\-$'),
	\ 'tagbar'          : Pl#Match#Add('getwinvar(a:window, "&ft")' , '^tagbar$'),
	\ 'nerdtree'        : Pl#Match#Add('getwinvar(a:window, "&ft")' , '^nerdtree$'),
\ }
let g:Powerline#Segments#fugitive#segments = Pl#Segment#Init(['fugitive',
	\ (exists('g:loaded_fugitive') && g:loaded_fugitive == 1),
	\
	\ Pl#Segment#Create('branch', '%{Powerline#Functions#fugitive#GetBranch("$BRANCH")}')
\ ])
let g:Powerline#Segments#virtualenv#segments = Pl#Segment#Init(['virtualenv',
	\ has('python') && (exists('g:virtualenv_loaded') && g:virtualenv_loaded == 1),
	\
	\ Pl#Segment#Create('statusline', '%{virtualenv#statusline()}')
\ ])
let g:Powerline#Segments#ft_man#segments = Pl#Segment#Init(['ft_man',
	\ Pl#Segment#Create('filename', '%{Powerline#Functions#ft_man#GetName()}')
\ ])
if !exists("g:Powerline#Segments#ctrlp#segments#focus ")
	let g:Powerline#Segments#ctrlp#segments#focus = '%{"%0"}'
endif
if !exists("g:Powerline#Segments#ctrlp#segments#prev ")
	let g:Powerline#Segments#ctrlp#segments#prev = '%-3{"%3"}'
endif
if !exists("g:Powerline#Segments#ctrlp#segments#next ")
	let g:Powerline#Segments#ctrlp#segments#next = '%-3{"%5"}'
endif

let g:Powerline#Segments#ctrlp#segments = Pl#Segment#Init(['ctrlp'
	\ , Pl#Segment#Create('focus', g:Powerline#Segments#ctrlp#segments#focus)
	\ , Pl#Segment#Create('byfname', '%{"%1"}')
	\ , Pl#Segment#Create('prev', g:Powerline#Segments#ctrlp#segments#prev)
	\ , Pl#Segment#Create('item', '%-9{"%4"}')
	\ , Pl#Segment#Create('next', g:Powerline#Segments#ctrlp#segments#next)
	\ , Pl#Segment#Create('marked', '%{"%6" == " <+>" ? "" : strpart("%6", 2, len("%6") - 3)}')
	\
	\ , Pl#Segment#Create('count', '%-6{"%0"}')
\ ])
let g:Powerline#Segments#syntastic#segments = Pl#Segment#Init(['syntastic',
	\ (exists('g:loaded_syntastic_plugin') && g:loaded_syntastic_plugin == 1),
	\
	\ Pl#Segment#Create('errors', '%{Powerline#Functions#syntastic#GetErrors("$LINE")}', Pl#Segment#Modes('!N'))
\ ])
let g:Powerline#Segments#hgrev#segments = Pl#Segment#Init(['hgrev',
	\ (exists('hgrev_loaded')),
	\ Pl#Segment#Create('branch', '%{Powerline#Functions#hgrev#Status("$BRANCH")}')
  \ ])
let g:Powerline#Segments#tagbar#segments = Pl#Segment#Init(['tagbar',
	\ (exists(':Tagbar') > 0),
	\
	\ Pl#Segment#Create('currenttag', '%{tagbar#currenttag("%s", "")}', Pl#Segment#Modes('!N')),
	\ Pl#Segment#Create('fullcurrenttag', '%{tagbar#currenttag("%s", "", "f")}', Pl#Segment#Modes('!N'))
\ ])
let g:Powerline#Segments#rvm#segments = Pl#Segment#Init(['rvm',
	\ (exists('g:loaded_rvm') && g:loaded_rvm == 1),
	\
	\ Pl#Segment#Create('string', '%{rvm#string()}'),
	\ Pl#Segment#Create('statusline', '%{rvm#statusline()}')
\ ])
" Authors:
"   @stephenmckinney
"
" This colorscheme is based on Solarized-dark colors, setting the specific
" values for the Solarized palette, using the terminal's 16 ansi
" color values. It combines Solarized with Powerline native colors.
call Pl#Hi#Allocate({
	\ 'black'          : 16,
	\ 'white'          : 231,
	\
	\ 'darkestgreen'   : 22,
	\ 'darkgreen'      : 28,
	\ 'mediumgreen'    : 70,
	\ 'brightgreen'    : 148,
	\
	\ 'darkestcyan'    : 23,
	\ 'mediumcyan'     : 117,
	\
	\ 'darkestblue'    : 24,
	\ 'darkblue'       : 31,
	\
	\ 'darkestred'     : 52,
	\ 'darkred'        : 88,
	\ 'mediumred'      : 124,
	\ 'brightred'      : 160,
	\ 'brightestred'   : 196,
	\
	\ 'darkestpurple'  : 55,
	\ 'mediumpurple'   : 98,
	\ 'brightpurple'   : 189,
	\
	\ 'brightorange'   : 208,
	\ 'brightestorange': 214,
	\
	\ 'gray0'          : 233,
	\ 'gray1'          : 235,
	\ 'gray2'          : 236,
	\ 'gray3'          : 239,
	\ 'gray4'          : 240,
	\ 'gray5'          : 241,
	\ 'gray6'          : 244,
	\ 'gray7'          : 245,
	\ 'gray8'          : 247,
	\ 'gray9'          : 250,
	\ 'gray10'         : 252,
	\
	\ 'base03'         : [8, 0x002b36],
	\ 'base02'         : [0, 0x073642],
	\ 'base01'         : [10, 0x586e75],
	\ 'base00'         : [11, 0x657b83],
	\ 'base0'          : [12, 0x839496],
	\ 'base1'          : [14, 0x93a1a1],
	\ 'base2'          : [7, 0xeee8d5],
	\ 'base3'          : [15, 0xfdf6e3],
	\ 'yellow'         : [3, 0xb58900],
	\ 'orange'         : [9, 0xcb4b16],
	\ 'red'            : [1, 0xdc322f],
	\ 'magenta'        : [5, 0xd33682],
	\ 'violet'         : [13, 0x6c71c4],
	\ 'blue'           : [4, 0x268bd2],
	\ 'cyan'           : [6, 0x2aa198],
	\ 'green'          : [2, 0x859900],
	\ })

let g:Powerline#Colorschemes#solarized16#colorscheme= Pl#Colorscheme#Init([
	\ Pl#Hi#Segments(['SPLIT'], {
		\ 'n': ['white', 'base02'],
		\ 'N': ['white', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['mode_indicator'], {
		\ 'n': ['darkestgreen', 'brightgreen', ['bold']],
		\ 'i': ['darkestcyan', 'white', ['bold']],
		\ 'v': ['red', 'brightorange', ['bold']],
		\ 'r': ['white', 'violet', ['bold']],
		\ 's': ['white', 'gray5', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['branch', 'raw', 'filesize'], {
		\ 'n': ['base03', 'blue'],
		\ 'N': ['base00', 'base03'],
		\ }),
	\
	\ Pl#Hi#Segments(['fileinfo', 'filename', 'filepath'], {
		\ 'n': ['base3', 'darkestblue', ['bold']],
		\ 'N': ['base0', 'base02', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['fileinfo.filepath'], {
		\ 'n': ['base2'],
		\ 'N': ['base00'],
		\ }),
	\
	\ Pl#Hi#Segments(['static_str'], {
		\ 'n': ['base3', 'violet'],
		\ 'N': ['base1', 'base02'],
		\ 'i': ['white', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['fileinfo.flags'], {
		\ 'n': ['base03', ['bold']],
		\ 'N': ['gray5'],
		\ 'i': ['base03', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['currenttag', 'fullcurrenttag', 'fileformat', 'fileencoding', 'pwd', 'filetype', 'rvm:string', 'rvm:statusline', 'virtualenv:statusline', 'charcode', 'currhigroup'], {
		\ 'n': ['base1', 'base02'],
		\ 'N': ['base00', 'base03'],
		\ }),
	\
	\ Pl#Hi#Segments(['scrollpercent'], {
		\ 'n': ['base1', 'base02', ['bold']],
		\ 'N': ['base00', 'base03'],
		\ }),
	\
	\ Pl#Hi#Segments(['lineinfo'], {
		\ 'n': ['gray2', 'gray10', ['bold']],
		\ 'N': ['gray7', 'gray1', ['bold']],
		\ 'i': ['darkestcyan', 'mediumcyan', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['errors'], {
		\ 'n': ['orange', 'base02', ['bold']],
		\ 'N': ['gray5', 'base03', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['lineinfo.line.tot'], {
		\ 'n': ['gray6'],
		\ 'N': ['gray5'],
		\ 'i': ['darkestcyan'],
		\ }),
	\
	\ Pl#Hi#Segments(['paste_indicator', 'ws_marker'], {
		\ 'n': ['base3', 'red', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['gundo:static_str.name', 'command_t:static_str.name'], {
		\ 'n': ['base3', 'darkblue', ['bold']],
		\ 'N': ['base1', 'base03', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['gundo:static_str.buffer', 'command_t:raw.line'], {
		\ 'n': ['white', 'base02'],
		\ 'N': ['gray5', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['gundo:SPLIT', 'command_t:SPLIT'], {
		\ 'n': ['white', 'base02'],
		\ 'N': ['white', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['lustyexplorer:static_str.name', 'minibufexplorer:static_str.name', 'nerdtree:raw.name', 'tagbar:static_str.name'], {
		\ 'n': ['base3', 'darkestblue', ['bold']],
		\ 'N': ['base01', 'base02', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['lustyexplorer:static_str.buffer', 'tagbar:static_str.buffer'], {
		\ 'n': ['base3', 'blue'],
		\ 'N': ['gray5', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['lustyexplorer:SPLIT', 'minibufexplorer:SPLIT', 'nerdtree:SPLIT', 'tagbar:SPLIT'], {
		\ 'n': ['gray3', 'base02'],
		\ 'N': ['gray3', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:focus', 'ctrlp:byfname'], {
		\ 'n': ['green', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:prev', 'ctrlp:next'], {
		\ 'n': ['green', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:item', 'ctrlp:pwd'], {
		\ 'n': ['base2', 'darkestblue', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:marked'], {
		\ 'n': ['green', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:count'], {
		\ 'n': ['base0', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:SPLIT'], {
		\ 'n': ['white', 'base02'],
		\ }),
  \
  \ Pl#Hi#Segments(['status'], {
		\ 'n': ['green', 'base02'],
		\ 'N': ['gray5', 'base02'],
    \ }),
\ ])
" Authors:
"   @skwp
"
" This colorscheme is based on Solarized-dark colors, combined
" with Powerline native colors
call Pl#Hi#Allocate({
	\ 'black'          : 16,
	\ 'white'          : 231,
	\
	\ 'darkestgreen'   : 22,
	\ 'darkgreen'      : 28,
	\ 'mediumgreen'    : 70,
	\ 'brightgreen'    : 148,
	\
	\ 'darkestcyan'    : 23,
	\ 'mediumcyan'     : 117,
	\
	\ 'darkestblue'    : 24,
	\ 'darkblue'       : 31,
	\
	\ 'darkestred'     : 52,
	\ 'darkred'        : 88,
	\ 'mediumred'      : 124,
	\ 'brightred'      : 160,
	\ 'brightestred'   : 196,
	\
	\ 'darkestpurple'  : 55,
	\ 'mediumpurple'   : 98,
	\ 'brightpurple'   : 189,
	\
	\ 'brightorange'   : 208,
	\ 'brightestorange': 214,
	\
	\ 'gray0'          : 233,
	\ 'gray1'          : 235,
	\ 'gray2'          : 236,
	\ 'gray3'          : 239,
	\ 'gray4'          : 240,
	\ 'gray5'          : 241,
	\ 'gray6'          : 244,
	\ 'gray7'          : 245,
	\ 'gray8'          : 247,
	\ 'gray9'          : 250,
	\ 'gray10'         : 252,
	\
	\ 'base03'         : [234, 0x002b36],
	\ 'base02'         : [235, 0x073642],
	\ 'base01'         : [240, 0x586e75],
	\ 'base00'         : [241, 0x657b83],
	\ 'base0'          : [244, 0x839496],
	\ 'base1'          : [245, 0x93a1a1],
	\ 'base2'          : [254, 0xeee8d5],
	\ 'base3'          : [230, 0xfdf6e3],
	\ 'yellow'         : [136, 0xb58900],
	\ 'orange'         : [166, 0xcb4b16],
	\ 'red'            : [160, 0xdc322f],
	\ 'magenta'        : [125, 0xd33682],
	\ 'violet'         : [61, 0x6c71c4],
	\ 'blue'           : [33, 0x268bd2],
	\ 'cyan'           : [37, 0x2aa198],
	\ 'green'          : [64, 0x859900],
	\ })

let g:Powerline#Colorschemes#solarized256#colorscheme = Pl#Colorscheme#Init([
	\ Pl#Hi#Segments(['SPLIT'], {
		\ 'n': ['white', 'base02'],
		\ 'N': ['white', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['mode_indicator'], {
		\ 'n': ['darkestgreen', 'brightgreen', ['bold']],
		\ 'i': ['darkestcyan', 'white', ['bold']],
		\ 'v': ['red', 'brightorange', ['bold']],
		\ 'r': ['white', 'violet', ['bold']],
		\ 's': ['white', 'gray5', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['branch', 'raw', 'filesize'], {
		\ 'n': ['base03', 'blue'],
		\ 'N': ['gray5', 'base03'],
		\ }),
	\
	\ Pl#Hi#Segments(['scrollpercent'], {
		\ 'n': ['gray7', 'gray2'],
		\ 'N': ['base2', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['fileinfo', 'filename', 'filepath'], {
		\ 'n': ['base2', 'darkestblue', ['bold']],
		\ 'N': ['base1', 'base02', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['fileinfo.filepath'], {
		\ 'n': ['gray10'],
		\ 'N': ['gray5'],
		\ 'i': ['mediumcyan'],
		\ }),
	\
	\ Pl#Hi#Segments(['static_str'], {
		\ 'n': ['base3', 'violet'],
		\ 'N': ['base1', 'base02'],
		\ 'i': ['white', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['fileinfo.flags'], {
		\ 'n': ['base03', ['bold']],
		\ 'N': ['gray5'],
		\ 'i': ['base03', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['currenttag', 'fullcurrenttag', 'fileformat', 'fileencoding', 'pwd', 'filetype', 'rvm:string', 'rvm:statusline', 'virtualenv:statusline', 'charcode', 'currhigroup'], {
		\ 'n': ['gray5', 'gray2'],
		\ 'i': ['mediumcyan', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['lineinfo'], {
		\ 'n': ['gray2', 'gray10', ['bold']],
		\ 'N': ['gray7', 'gray1', ['bold']],
		\ 'i': ['darkestcyan', 'mediumcyan', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['errors'], {
		\ 'n': ['orange', 'base02', ['bold']],
		\ 'N': ['gray5', 'base03', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['lineinfo.line.tot'], {
		\ 'n': ['gray6'],
		\ 'N': ['gray5'],
		\ 'i': ['darkestcyan'],
		\ }),
	\
	\ Pl#Hi#Segments(['paste_indicator', 'ws_marker'], {
		\ 'n': ['base3', 'red', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['gundo:static_str.name', 'command_t:static_str.name'], {
		\ 'n': ['base3', 'darkblue', ['bold']],
		\ 'N': ['base1', 'base03', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['gundo:static_str.buffer', 'command_t:raw.line'], {
		\ 'n': ['white', 'base02'],
		\ 'N': ['gray5', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['gundo:SPLIT', 'command_t:SPLIT'], {
		\ 'n': ['white', 'base02'],
		\ 'N': ['white', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['lustyexplorer:static_str.name', 'minibufexplorer:static_str.name', 'nerdtree:raw.name', 'tagbar:static_str.name'], {
		\ 'n': ['gray10', 'darkestblue', ['bold']],
		\ 'N': ['gray3', 'base02', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['lustyexplorer:static_str.buffer', 'tagbar:static_str.buffer'], {
		\ 'n': ['base3', 'blue'],
		\ 'N': ['gray5', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['lustyexplorer:SPLIT', 'minibufexplorer:SPLIT', 'nerdtree:SPLIT', 'tagbar:SPLIT'], {
		\ 'n': ['gray3', 'base02'],
		\ 'N': ['gray3', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:focus', 'ctrlp:byfname'], {
		\ 'n': ['green', 'base03'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:prev', 'ctrlp:next', 'ctrlp:pwd'], {
		\ 'n': ['green', 'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:item'], {
		\ 'n': ['base2', 'darkestblue', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:marked'], {
		\ 'n': ['brightgreen', 'base03', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:count'], {
		\ 'n': ['base0', 'base03'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:SPLIT'], {
		\ 'n': ['white', 'base03'],
		\ }),
  \
  \ Pl#Hi#Segments(['status'], {
		\ 'n': ['green', 'base02'],
		\ 'N': ['gray5', 'base02'],
    \ }),
\ ])

" Solarized color scheme for Powerline
" N = no focus
" 16 hex colors as defined on http://ethanschoonover.com/solarized
call Pl#Hi#Allocate({
  \ 'base03'  : [8,   0x002b36],
  \ 'base02'  : [0,   0x073642],
  \ 'base01'  : [10,  0x586e75],
  \ 'base00'  : [11,  0x657b83],
  \ 'base0'   : [12,  0x839496],
  \ 'base1'   : [14,  0x93a1a1],
  \ 'base2'   : [7,   0xeee8d5],
  \ 'base3'   : [15,  0xfdf6e3],
  \ 'yellow'  : [3,   0xb58900],
  \ 'orange'  : [9,   0xcb4b16],
  \ 'red'     : [1,   0xdc322f],
  \ 'magenta' : [5,   0xd33682],
  \ 'violet'  : [13,  0x6c71c4],
  \ 'blue'    : [4,   0x268bd2],
  \ 'cyan'    : [6,   0x2aa198],
  \ 'green'   : [2,   0x859900],
	\ })

let g:Powerline#Colorschemes#solarized#colorscheme = Pl#Colorscheme#Init([
	\ Pl#Hi#Segments(['SPLIT'], {
		\ 'n': ['base3',  'base2'],
		\ 'N': ['base3',  'base2'],
		\ 'i': ['base3',  'base2'],
		\ }),
	\
	\ Pl#Hi#Segments(['mode_indicator'], {
		\ 'n': ['base2',  'blue',     ['bold']],
		\ 'i': ['base3',  'orange',   ['bold']],
		\ 'v': ['base3',  'magenta',  ['bold']],
		\ 'r': ['base3',  'violet',   ['bold']],
		\ 's': ['base3',  'yellow',   ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['branch'], {
		\ 'n': ['base2',   'base02'],
		\ 'N': ['base02',  'base1'],
		\ 'i': ['base2',   'base00'],
		\ }),
	\
  \ Pl#Hi#Segments(['scrollpercent', 'raw', 'filesize'], {
		\ 'n': ['base2',   'base0'],
		\ 'N': ['base00',  'base2'],
		\ 'i': ['base2',   'base1'],
		\ }),
	\
	\ Pl#Hi#Segments(['fileinfo', 'filename'], {
		\ 'n': ['base2',   'base01',   ['bold']],
		\ 'N': ['base01',  'base2' ],
		\ 'i': ['base3',   'base1',    ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['fileinfo.filepath'], {
		\ 'n': ['base1'],
		\ 'N': ['base1'],
		\ 'i': ['base01'],
		\ }),
	\
	\ Pl#Hi#Segments(['static_str'], {
		\ 'n': ['base3',   'green'],
		\ 'N': ['base02',  'base01'],
		\ 'i': ['base3',   'blue'],
		\ }),
	\
	\ Pl#Hi#Segments(['fileinfo.flags'], {
		\ 'n': ['base3'],
		\ 'N': ['base00'],
		\ 'i': ['base3'],
		\ }),
	\
	\ Pl#Hi#Segments(['currenttag', 'fileformat', 'fileencoding', 'pwd', 'filetype', 'rvm:string', 'rvm:statusline', 'virtualenv:statusline', 'charcode', 'currhigroup'], {
		\ 'n': ['base00', 'base2'],
		\ 'i': ['base0', 'base2'],
		\ }),
	\
	\ Pl#Hi#Segments(['lineinfo'], {
		\ 'n': ['base2',   'base01',  ['bold']],
		\ 'N': ['base02',  'base0'],
		\ 'i': ['base2',   'base00',  ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['errors'], {
		\ 'n': ['red',  'base2',  ['bold']],
		\ 'i': ['red',  'base2',  ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['lineinfo.line.tot'], {
		\ 'n': ['base3'],
		\ 'N': ['base02'],
		\ 'i': ['base3'],
		\ }),
	\
	\ Pl#Hi#Segments(['paste_indicator', 'ws_marker'], {
		\ 'n': ['base3', 'red', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['gundo:static_str.name', 'command_t:static_str.name'], {
		\ 'n': ['base3',   'red',     ['bold']],
		\ 'N': ['base02',  'base01',  ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['gundo:static_str.buffer', 'command_t:raw.line'], {
		\ 'n': ['base3',  'base00'],
		\ 'N': ['base0',  'base02'],
		\ }),
	\
	\ Pl#Hi#Segments(['gundo:SPLIT', 'command_t:SPLIT'], {
		\ 'n': ['base3',  'base02'],
		\ 'N': ['base0',  'base03'],
		\ }),
	\
	\ Pl#Hi#Segments(['lustyexplorer:static_str.name', 'minibufexplorer:static_str.name', 'nerdtree:raw.name', 'tagbar:static_str.name'], {
		\ 'n': ['base2',   'green',   ['bold']],
		\ 'N': ['base02',  'base1'],
		\ }),
	\
	\ Pl#Hi#Segments(['lustyexplorer:static_str.buffer', 'tagbar:static_str.buffer'], {
		\ 'n': ['base3',   'base01'],
		\ 'N': ['base02',  'base01'],
		\ }),
	\
	\ Pl#Hi#Segments(['lustyexplorer:SPLIT', 'minibufexplorer:SPLIT', 'nerdtree:SPLIT', 'tagbar:SPLIT'], {
		\ 'n': ['base2',  'base2'],
		\ 'N': ['base2',  'base2'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:focus', 'ctrlp:byfname'], {
		\ 'n': ['base03', 'base01'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:prev', 'ctrlp:next', 'ctrlp:pwd'], {
		\ 'n': ['base3', 'base00'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:item'], {
		\ 'n': ['base3', 'violet', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:marked'], {
		\ 'n': ['base1', 'base01', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:count'], {
		\ 'n': ['base3', 'violet'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:SPLIT'], {
		\ 'n': ['base3', 'base03'],
		\ }),
	\ ])
call Pl#Hi#Allocate({
	\ 'black'          : 16,
	\ 'white'          : 231,
	\
	\ 'darkestgreen'   : 22,
	\ 'darkgreen'      : 28,
	\ 'mediumgreen'    : 70,
	\ 'brightgreen'    : 148,
	\
	\ 'darkestcyan'    : 23,
	\ 'mediumcyan'     : 117,
	\
	\ 'darkestblue'    : 24,
	\ 'darkblue'       : 31,
	\
	\ 'darkestred'     : 52,
	\ 'darkred'        : 88,
	\ 'mediumred'      : 124,
	\ 'brightred'      : 160,
	\ 'brightestred'   : 196,
	\
	\ 'darkestpurple'  : 55,
	\ 'mediumpurple'   : 98,
	\ 'brightpurple'   : 189,
	\
	\ 'brightorange'   : 208,
	\ 'brightestorange': 214,
	\
	\ 'gray0'          : 233,
	\ 'gray1'          : 235,
	\ 'gray2'          : 236,
	\ 'gray3'          : 239,
	\ 'gray4'          : 240,
	\ 'gray5'          : 241,
	\ 'gray6'          : 244,
	\ 'gray7'          : 245,
	\ 'gray8'          : 247,
	\ 'gray9'          : 250,
	\ 'gray10'         : 252,
	\ })

let g:Powerline#Colorschemes#default#colorscheme = Pl#Colorscheme#Init([
	\ Pl#Hi#Segments(['SPLIT'], {
		\ 'n': ['white', 'gray2'],
		\ 'N': ['white', 'gray0'],
		\ 'i': ['white', 'darkestblue'],
		\ }),
	\
	\ Pl#Hi#Segments(['mode_indicator'], {
		\ 'n': ['darkestgreen', 'brightgreen', ['bold']],
		\ 'i': ['darkestcyan', 'white', ['bold']],
		\ 'v': ['darkred', 'brightorange', ['bold']],
		\ 'r': ['white', 'brightred', ['bold']],
		\ 's': ['white', 'gray5', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['branch', 'scrollpercent', 'raw', 'filesize'], {
		\ 'n': ['gray9', 'gray4'],
		\ 'N': ['gray4', 'gray1'],
		\ 'i': ['mediumcyan', 'darkblue'],
		\ }),
	\
	\ Pl#Hi#Segments(['fileinfo', 'filename'], {
		\ 'n': ['white', 'gray4', ['bold']],
		\ 'N': ['gray7', 'gray0', ['bold']],
		\ 'i': ['white', 'darkblue', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['fileinfo.filepath'], {
		\ 'n': ['gray10'],
		\ 'N': ['gray5'],
		\ 'i': ['mediumcyan'],
		\ }),
	\
	\ Pl#Hi#Segments(['static_str'], {
		\ 'n': ['white', 'gray4'],
		\ 'N': ['gray7', 'gray1'],
		\ 'i': ['white', 'darkblue'],
		\ }),
	\
	\ Pl#Hi#Segments(['fileinfo.flags'], {
		\ 'n': ['brightestred', ['bold']],
		\ 'N': ['darkred'],
		\ 'i': ['brightestred', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['currenttag', 'fullcurrenttag', 'fileformat', 'fileencoding', 'pwd', 'filetype', 'rvm:string', 'rvm:statusline', 'virtualenv:statusline', 'charcode', 'currhigroup'], {
		\ 'n': ['gray8', 'gray2'],
		\ 'i': ['mediumcyan', 'darkestblue'],
		\ }),
	\
	\ Pl#Hi#Segments(['lineinfo'], {
		\ 'n': ['gray2', 'gray10', ['bold']],
		\ 'N': ['gray7', 'gray1', ['bold']],
		\ 'i': ['darkestcyan', 'mediumcyan', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['errors'], {
		\ 'n': ['brightestorange', 'gray2', ['bold']],
		\ 'i': ['brightestorange', 'darkestblue', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['lineinfo.line.tot'], {
		\ 'n': ['gray6'],
		\ 'N': ['gray5'],
		\ 'i': ['darkestcyan'],
		\ }),
	\
	\ Pl#Hi#Segments(['paste_indicator', 'ws_marker'], {
		\ 'n': ['white', 'brightred', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['gundo:static_str.name', 'command_t:static_str.name'], {
		\ 'n': ['white', 'mediumred', ['bold']],
		\ 'N': ['brightred', 'darkestred', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['gundo:static_str.buffer', 'command_t:raw.line'], {
		\ 'n': ['white', 'darkred'],
		\ 'N': ['brightred', 'darkestred'],
		\ }),
	\
	\ Pl#Hi#Segments(['gundo:SPLIT', 'command_t:SPLIT'], {
		\ 'n': ['white', 'darkred'],
		\ 'N': ['white', 'darkestred'],
		\ }),
	\
	\ Pl#Hi#Segments(['lustyexplorer:static_str.name', 'minibufexplorer:static_str.name', 'nerdtree:raw.name', 'tagbar:static_str.name'], {
		\ 'n': ['white', 'mediumgreen', ['bold']],
		\ 'N': ['mediumgreen', 'darkestgreen', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['lustyexplorer:static_str.buffer', 'tagbar:static_str.buffer'], {
		\ 'n': ['brightgreen', 'darkgreen'],
		\ 'N': ['mediumgreen', 'darkestgreen'],
		\ }),
	\
	\ Pl#Hi#Segments(['lustyexplorer:SPLIT', 'minibufexplorer:SPLIT', 'nerdtree:SPLIT', 'tagbar:SPLIT'], {
		\ 'n': ['white', 'darkgreen'],
		\ 'N': ['white', 'darkestgreen'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:focus', 'ctrlp:byfname'], {
		\ 'n': ['brightpurple', 'darkestpurple'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:prev', 'ctrlp:next', 'ctrlp:pwd'], {
		\ 'n': ['white', 'mediumpurple'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:item'], {
		\ 'n': ['darkestpurple', 'white', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:marked'], {
		\ 'n': ['brightestred', 'darkestpurple', ['bold']],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:count'], {
		\ 'n': ['darkestpurple', 'white'],
		\ }),
	\
	\ Pl#Hi#Segments(['ctrlp:SPLIT'], {
		\ 'n': ['white', 'darkestpurple'],
		\ }),
	\ ])
" Authors:
"   @stephenmckinney
"
let g:Powerline#Themes#solarized16#theme = Pl#Theme#Create(
	\ Pl#Theme#Buffer(''
		\ , 'fugitive:branch'
		\ , 'fileinfo'
		\ , 'flags.mod'
		\ , 'syntastic:errors'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'sass:status'
		\ , 'rvm:string'
		\ , 'filetype'
		\ , 'scrollpercent'
		\ , 'paste_indicator'
	\ ),
	\
	\ Pl#Theme#Buffer('command_t'
		\ , ['static_str.name', 'Command-T']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , ['raw.line', '%10(Match #%l%)']
	\ ),
	\
	\ Pl#Theme#Buffer('gundo', Pl#Match#Any('gundo_tree')
		\ , ['static_str.name', 'Gundo']
		\ , ['static_str.buffer', 'Undo tree']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('gundo', Pl#Match#Any('gundo_preview')
		\ , ['static_str.name', 'Gundo']
		\ , ['static_str.buffer', 'Diff preview']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('bt_help'
		\ , ['static_str.name', 'Help']
		\ , 'filename'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'scrollpercent'
	\ ),
	\
	\ Pl#Theme#Buffer('ft_vimpager'
		\ , ['static_str.name', 'Pager']
		\ , 'filename'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'scrollpercent'
	\ ),
	\
	\ Pl#Theme#Buffer('lustyexplorer'
		\ , ['static_str.name', 'LustyExplorer']
		\ , ['static_str.buffer', 'Buffer list']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('ft_man'
		\ , ['static_str.name', 'Man page']
		\ , 'filename'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'scrollpercent'
	\ ),
	\
	\ Pl#Theme#Buffer('minibufexplorer'
		\ , ['static_str.name', 'MiniBufExplorer']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('ft_qf'
		\ , ['static_str.name', 'Quickfix']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('tagbar'
		\ , ['static_str.name', 'Tagbar']
		\ , ['static_str.buffer', 'Tree']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('ctrlp', Pl#Theme#Callback('ctrlp_main', 'if ! exists("g:ctrlp_status_func") | let g:ctrlp_status_func = {} | endif | let g:ctrlp_status_func.main = "%s"')
		\ , 'ctrlp:prev'
		\ , 'ctrlp:item'
		\ , 'ctrlp:next'
		\ , 'ctrlp:marked'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'ctrlp:focus'
		\ , 'ctrlp:byfname'
		\ , 'pwd'
	\ ),
	\
	\ Pl#Theme#Buffer('ctrlp', Pl#Theme#Callback('ctrlp_prog', 'if ! exists("g:ctrlp_status_func") | let g:ctrlp_status_func = {} | endif | let g:ctrlp_status_func.prog = "%s"')
		\ , 'ctrlp:count'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'pwd'
	\ ),
	\
	\ Pl#Theme#Buffer('nerdtree'
		\ , ['raw.name', '%{Powerline#Functions#GetShortPath(4)}']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ )
\ )
" Authors:
"   @skwp
"
" Disabled:
" Add the following line into the first theme group to see the highlight
" group
" \ , 'currhigroup'
"
" Line info taken out - I know which line number I'm on from the gutter
"\ , 'lineinfo'
let g:Powerline#Themes#solarized256#theme = Pl#Theme#Create(
	\ Pl#Theme#Buffer(''
		\ , 'fugitive:branch'
		\ , 'fileinfo'
		\ , 'flags.mod'
		\ , 'syntastic:errors'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'sass:status'
		\ , 'rvm:string'
		\ , 'paste_indicator'
	\ ),
	\
	\ Pl#Theme#Buffer('command_t'
		\ , ['static_str.name', 'Command-T']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , ['raw.line', '%10(Match #%l%)']
	\ ),
	\
	\ Pl#Theme#Buffer('gundo', Pl#Match#Any('gundo_tree')
		\ , ['static_str.name', 'Gundo']
		\ , ['static_str.buffer', 'Undo tree']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('gundo', Pl#Match#Any('gundo_preview')
		\ , ['static_str.name', 'Gundo']
		\ , ['static_str.buffer', 'Diff preview']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('bt_help'
		\ , ['static_str.name', 'Help']
		\ , 'filename'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'scrollpercent'
	\ ),
	\
	\ Pl#Theme#Buffer('ft_vimpager'
		\ , ['static_str.name', 'Pager']
		\ , 'filename'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'scrollpercent'
	\ ),
	\
	\ Pl#Theme#Buffer('lustyexplorer'
		\ , ['static_str.name', 'LustyExplorer']
		\ , ['static_str.buffer', 'Buffer list']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('ft_man'
		\ , ['static_str.name', 'Man page']
		\ , 'filename'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'scrollpercent'
	\ ),
	\
	\ Pl#Theme#Buffer('minibufexplorer'
		\ , ['static_str.name', 'MiniBufExplorer']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('ft_qf'
		\ , ['static_str.name', 'Quickfix']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('tagbar'
		\ , ['static_str.name', 'Tagbar']
		\ , ['static_str.buffer', 'Tree']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('ctrlp', Pl#Theme#Callback('ctrlp_main', 'if ! exists("g:ctrlp_status_func") | let g:ctrlp_status_func = {} | endif | let g:ctrlp_status_func.main = "%s"')
		\ , 'ctrlp:prev'
		\ , 'ctrlp:item'
		\ , 'ctrlp:next'
		\ , 'ctrlp:marked'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'ctrlp:focus'
		\ , 'ctrlp:byfname'
		\ , 'pwd'
	\ ),
	\
	\ Pl#Theme#Buffer('ctrlp', Pl#Theme#Callback('ctrlp_prog', 'if ! exists("g:ctrlp_status_func") | let g:ctrlp_status_func = {} | endif | let g:ctrlp_status_func.prog = "%s"')
		\ , 'ctrlp:count'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'pwd'
	\ ),
	\
	\ Pl#Theme#Buffer('nerdtree'
		\ , ['raw.name', '%{Powerline#Functions#GetShortPath(4)}']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ )
\ )
let g:Powerline#Themes#default#theme = Pl#Theme#Create(
	\ Pl#Theme#Buffer(''
		\ , 'paste_indicator'
		\ , 'mode_indicator'
		\ , 'fugitive:branch'
		\ , 'hgrev:branch'
		\ , 'fileinfo'
		\ , 'syntastic:errors'
		\ , Pl#Segment#Truncate()
		\ , 'tagbar:currenttag'
		\ , Pl#Segment#Split()
		\ , 'rvm:string'
		\ , 'virtualenv:statusline'
		\ , 'fileformat'
		\ , 'fileencoding'
		\ , 'filetype'
		\ , 'scrollpercent'
		\ , 'lineinfo'
	\ ),
	\
	\ Pl#Theme#Buffer('command_t'
		\ , ['static_str.name', 'Command-T']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , ['raw.line', '%10(Match #%l%)']
	\ ),
	\
	\ Pl#Theme#Buffer('gundo', Pl#Match#Any('gundo_tree')
		\ , ['static_str.name', 'Gundo']
		\ , ['static_str.buffer', 'Undo tree']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('gundo', Pl#Match#Any('gundo_preview')
		\ , ['static_str.name', 'Gundo']
		\ , ['static_str.buffer', 'Diff preview']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('bt_help'
		\ , ['static_str.name', 'Help']
		\ , 'filename'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'scrollpercent'
	\ ),
	\
	\ Pl#Theme#Buffer('ft_vimpager'
		\ , ['static_str.name', 'Pager']
		\ , 'filename'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'scrollpercent'
	\ ),
	\
	\ Pl#Theme#Buffer('lustyexplorer'
		\ , ['static_str.name', 'LustyExplorer']
		\ , ['static_str.buffer', 'Buffer list']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('ft_man'
		\ , ['static_str.name', 'Man page']
		\ , 'filename'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'scrollpercent'
	\ ),
	\
	\ Pl#Theme#Buffer('minibufexplorer'
		\ , ['static_str.name', 'MiniBufExplorer']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('ft_qf'
		\ , ['static_str.name', 'Quickfix']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('tagbar'
		\ , ['static_str.name', 'Tagbar']
		\ , ['static_str.buffer', 'Tree']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ ),
	\
	\ Pl#Theme#Buffer('ctrlp', Pl#Theme#Callback('ctrlp_main', 'if ! exists("g:ctrlp_status_func") | let g:ctrlp_status_func = {} | endif | let g:ctrlp_status_func.main = "%s"')
		\ , 'ctrlp:prev'
		\ , 'ctrlp:item'
		\ , 'ctrlp:next'
		\ , 'ctrlp:marked'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'ctrlp:focus'
		\ , 'ctrlp:byfname'
		\ , 'pwd'
	\ ),
	\
	\ Pl#Theme#Buffer('ctrlp', Pl#Theme#Callback('ctrlp_prog', 'if ! exists("g:ctrlp_status_func") | let g:ctrlp_status_func = {} | endif | let g:ctrlp_status_func.prog = "%s"')
		\ , 'ctrlp:count'
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
		\ , 'pwd'
	\ ),
	\
	\ Pl#Theme#Buffer('nerdtree'
		\ , ['raw.name', '%{Powerline#Functions#GetShortPath(4)}']
		\ , Pl#Segment#Truncate()
		\ , Pl#Segment#Split()
	\ )
\ )
function! Powerline#Functions#fugitive#GetBranch(symbol) " {{{
	let ret = fugitive#statusline()

	let ret = substitute(ret, '\c\v\[?GIT\(([a-z0-9\-_\./:]+)\)\]?', a:symbol .' \1', 'g')

	return ret
endfunction " }}}
function! Powerline#Functions#ft_man#GetName() " {{{
	let matches = matchlist(getline(1), '\v^([a-zA-Z_\.\-]+)\((\d+)\)')

	if ! len(matches)
		return 'n/a'
	endif

	let file = tolower(matches[1])
	let num = matches[2]

	return file
endfunction " }}}
function! Powerline#Functions#syntastic#GetErrors(line_symbol) " {{{
	if ! exists('g:syntastic_stl_format')
		" Syntastic hasn't been loaded yet
		return ''
	endif

	" Temporarily change syntastic output format
	let old_stl_format = g:syntastic_stl_format
	let g:syntastic_stl_format = '%E{ ERRORS (%e) '. a:line_symbol .' %fe }%W{ WARNINGS (%w) '. a:line_symbol .' %fw }'

	let ret = SyntasticStatuslineFlag()

	let g:syntastic_stl_format = old_stl_format

	return ret
endfunction " }}}
function! Powerline#Functions#hgrev#Status(symbol) " {{{
	if ! exists('*HGRev')
		" HGRev hasn't been loaded yet
		return ''
	endif
	if !exists("b:statusline_hg_status")
		silent execute "RefreshMercurialRev"
	endif
	let b:statusline_hg_status=HGRev()
	if b:statusline_hg_status != '-'
		let ret = "\u26A1". '' . substitute(b:statusline_hg_status, '^[^ ]*', '\1', 'g')
		let ret=substitute(ret,' M$','+','g')
	else
		let ret=''
		endif
	return ret
endfunction " }}}
*Powerline.txt*	For Vim version 7.3.	Last change: 2011 Nov 23

                                            ______
         _________                          \    /__
         \_____   \______  _  _____________ /   /'__' ___   ____
          |    ___/  _ \ \/ \/ / __ \_  ___\   / |  |/   \_/ __ \
          |   |  |  (_) \  _  /  ___/|  |  /  /__|  |  |  \  ___/
          '___'   \____/ \/ \/ \___  |__' /___  /'__'__|  /\___ \
                                   \/        / /        \/     \/
                                            | /
                                            |/
                                            '

==============================================================================
CONTENTS                                                  *Powerline-contents*

    1. Introduction ....................... |Powerline-introduction|
    2. Usage .............................. |Powerline-usage|
    3. Requirements ....................... |Powerline-requirements|
       3.1 Recommended settings ........... |Powerline-recommended-settings|
    4. Configuration ...................... |Powerline-configuration|
       4.1 Powerline_cache_file ........... |Powerline_cache_file|
           4.1.1 Clearing the cache ....... |:PowerlineClearCache|
           4.1.2 Powerline_cache_dir ...... |Powerline_cache_dir|
       4.2 Powerline_cache_enabled ........ |Powerline_cache_enabled|
       4.3 Powerline_symbols .............. |Powerline_symbols|
           4.3.1 Compatible symbols ....... |Powerline-symbols-compatible|
           4.3.2 Fancy symbols ............ |Powerline-symbols-fancy|
           4.3.3 Overriding symbols ....... |Powerline_symbols_override|
           4.3.4 Overriding dividers ...... |Powerline_dividers_override|
       4.4 Powerline_theme ................ |Powerline_theme|
       4.5 Powerline_colorscheme .......... |Powerline_colorscheme|
       4.6 Powerline_stl_path_style ....... |Powerline_stl_path_style|
    5. Fonts .............................. |Powerline-fonts|
    6. Customization ...................... |Powerline-customization|
       6.1 Basic customization ............ |Powerline-basic-customization|
       6.2 Advanced customization ......... |Powerline-advanced-customization|
           6.2.1 Colorschemes ............. |Powerline-cust-colorschemes|
           6.2.2 Functions ................ |Powerline-cust-functions|
           6.2.3 Segments ................. |Powerline-cust-segments|
           6.2.4 Themes ................... |Powerline-cust-themes|
    7. License ............................ |Powerline-license|
    8. Known issues ....................... |Powerline-known-issues|
    9. Contributing ....................... |Powerline-contributing|

==============================================================================
1. Introduction                           *Powerline* *Powerline-introduction*

Powerline is a utility plugin which allows you to create better-looking, more 
functional Vim statuslines.

==============================================================================
2. Usage                                                     *Powerline-usage*

Powerline is automatically enabled when it's installed, either by unzipping 
the provided archive or by adding it as a Pathogen/Vundle bundle.

Powerline replaces the standard Vim 'statusline' with a custom statusline made 
up of Powerline segments.

Powerline ignores any 'statusline' customizations you have defined in your 
|vimrc|. If you remove Powerline, your 'statusline' customizations are 
restored.

==============================================================================
3. Requirements                                       *Powerline-requirements*

Powerline has been developed and tested in Vim 7.3, but it should run without 
any problems in Vim 7.2. The default configuration requires a Unix-like system 
to work properly.

The plugin only works with Vim running in an 88/256-color terminal or Gvim.

Vi-compatible mode must be disabled.

------------------------------------------------------------------------------
3.1 Recommended settings                      *Powerline-recommended-settings*

The following configuration options should be set in your |vimrc|: >

    set nocompatible   " Disable vi-compatibility
    set laststatus=2   " Always show the statusline
    set encoding=utf-8 " Necessary to show Unicode glyphs

Note: If you're using an 88/256-color terminal but still don't see the colored 
statusline, you may have to set the following option as well: >

    set t_Co=256 " Explicitly tell Vim that the terminal supports 256 colors

==============================================================================
4. Configuration                                     *Powerline-configuration*

Powerline will work fine without any user configuration, but default behavior 
can be overridden by setting configuration variables globally in your |vimrc| 
file.

------------------------------------------------------------------------------
4.1 Powerline_cache_file                                *Powerline_cache_file*

By default Powerline caches all the statuslines and colors in a cache file in 
the plugin's directory (or the Vim directory, depending on the installation 
method used).

It's recommended that you enable the cache, as this dramatically improves Vim 
startup time after the cache file has been generated (the plugin usually loads 
within ~100ms without the cache and ~1ms with the cache).

Note: The default cache filename includes the current theme, colorscheme and 
symbol settings in order to tie the cache file to your current configuration, 
so the cache file will be regenerated when you change any settings. This may 
leave several old cache files in your Vim folder, and these may safely be 
deleted.

Defaults: "|Powerline_cache_dir|/Powerline_<theme>_<colorscheme>_<symbols>.cache"

------------------------------------------------------------------------------
4.1.1 Powerline_cache_dir                                *Powerline_cache_dir*

This is the directory used for |Powerline_cache_file|.

Default: Plugin directory: >

    let g:Powerline_cache_dir = simplify(expand('<sfile>:p:h') .'/..')
<
------------------------------------------------------------------------------
4.1.2 Clearing the cache                                *:PowerlineClearCache*

Powerline provides a command to easily clear the cache after changing your 
settings or updating your theme. Simply run the following command to clear 
your cache, and restart Vim afterwards: >

    :PowerlineClearCache
<
------------------------------------------------------------------------------
4.2 Powerline_cache_enabled                          *Powerline_cache_enabled*

It's possible to disable statusline caching by setting this option to 0. This 
is mostly useful when developing statuslines.

Example: >

    let g:Powerline_cache_enabled = 0
<

Default: 1

------------------------------------------------------------------------------
4.3 Powerline_symbols                                      *Powerline_symbols*

This option defines which set of symbols and dividers you want to use. There 
are currently three available options: "compatible", "unicode" and "fancy".

    TYPE           DESCRIPTION ~
    compatible     Doesn't use any special characters.
    unicode        Simulates icons and arrows using similar Unicode glyphs.
    fancy          Custom icons and arrows. Requires a patched font.

Example: >

    let g:Powerline_symbols = 'fancy'
<

Default: "compatible"

Symbols can be inserted into statuslines by using the following variables 
(just insert the variables as text in your segments):

    VARIABLE       DESCRIPTION ~
    $BRANCH        Inserts a branch symbol
    $RO            Inserts a read-only symbol
    $FT            Inserts a filetype symbol
    $LINE          Inserts a line number symbol

------------------------------------------------------------------------------
4.3.1 Compatible symbols                        *Powerline-symbols-compatible*

These symbols will work in any configuration, and do not require a special 
font to work. This option will replace the fancy icons with plain text, and 
the pointy dividers with straight lines.

------------------------------------------------------------------------------
4.3.2 Fancy symbols                                  *Powerline-symbols-fancy*

These symbols require a custom font to work. A font patcher is provided for 
adding the required symbols to any outline font and some bitmap fonts, see 
|Powerline-fonts| and the provided README file for usage details.

------------------------------------------------------------------------------
4.3.3 Overriding symbols                          *Powerline_symbols_override*

You can override symbols by adding your symbols to the 
g:Powerline_symbols_override dictionary. Example: If you want the branch 
symbol to be "∓" (hex code 0x2213) and the line symbol to be "L" you can add 
the following to your |vimrc|: >

    let g:Powerline_symbols_override = {
        \ 'BRANCH': [0x2213],
        \ 'LINE': 'L',
        \ }
<
------------------------------------------------------------------------------
4.3.4 Overriding dividers                        *Powerline_dividers_override*

If you for some reason want to override the dividers then you can set 
g:Powerline_dividers_override to a list with exactly four elements:

    1: Hard right-pointing arrow
    2: Soft right-pointing arrow
    3: Hard left-pointing arrow
    4: Soft left-pointing arrow

Example: >

    let g:Powerline_dividers_override = ['>>', '>', '<<', '<']
<

------------------------------------------------------------------------------
4.3.5 Overriding mode names                                   *Powerline_mode*

You can change the names used for modes at the far left by setting some
variables in your |vimrc|. For example you can change "N" to "NORMAL" with: >

    let g:Powerline_mode_n = 'NORMAL'
<
The variables are all named beginning with 'g:Powerline_mode_', as follows:

mode                name    default       note ~
Normal              n       ' N '         (surrounded by spaces)
Insert              i       INSERT
Replace             R       REPLACE       |Replace-mode|
Visual              v       VISUAL        |Visual-mode|
Visual linewise     V       V⋅LINE
Visual blockwise    cv      V⋅BLOCK
Select              s       SELECT        |Select-mode|
Select linewise     S       S⋅LINE
Select blockwise    cs      S⋅BLOCK

-----------------------------------------------------------------------------
4.4 Powerline_theme                                          *Powerline_theme*

This option defines the theme Powerline uses. The available themes are located 
in autoload/Powerline/Themes/. A theme is a pre-defined set of Powerline 
segments which make up the statusline.

Example: >

    let g:Powerline_theme = 'solarized256'
<

Default: "default"

------------------------------------------------------------------------------
4.5 Powerline_colorscheme                              *Powerline_colorscheme*

This option defines the colorscheme Powerline uses. The available colorschemes 
are located in autoload/Powerline/Colorschemes/.

Example: >

    let g:Powerline_colorscheme = 'solarized256'
<

Default: "default"

------------------------------------------------------------------------------
4.6 Powerline_stl_path_style                        *Powerline_stl_path_style*

There are currently four ways to display the current path and file name. The 
default is to only display the file name like the %t statusline item. By 
setting this configuration value you can choose from the following ways 
display the current path and file name:

    VALUE      DESCRIPTION ~
    filename   Display only the file name using the %t statusline item.
    short      Display a short path. The home directory is substituted with
               "~", the first directory is displayed with its full name, and
               subsequent directories are shortened to their first letter.
               I.e. "/home/user/foo/bar/baz.vim" becomes "~/f/b/baz.vim" and
               "long/relative/path/foo/bar/baz.vim becomes
               "long/r/p/f/b/baz.vim".
    relative   Display a relative path, similar to the %f statusline item.
    full       Display the full path, similar to the %F statusline item.

Example: >

    let g:Powerline_stl_path_style = 'full'
<

Default: "relative"

==============================================================================
5. Fonts                                                     *Powerline-fonts*

TODO

==============================================================================
6. Customization                                     *Powerline-customization*

There are currently two ways of customizing Powerline: Basic customization 
using a couple of functions to insert and remove existing segments from the 
statusline, and advanced customization using your own autoload files. The 
customization features of Powerline allow you to create your own statuslines 
without ever touching the original source code.

------------------------------------------------------------------------------
6.1 Basic customization                        *Powerline-basic-customization*

Powerline provides the following functions to alter the default statusline 
look. These functions should be called from your |vimrc| file or another file 
which is sourced at Vim startup.

Note: These functions are currently applied to all statuslines, so if you 
insert a segment after a segment which is present in many statuslines (e.g.  
the "filename" segment), all the statuslines will have the inserted segment.  
This behavior may be changed in a future version of Powerline.

Note: Remember to clear your cache with |:PowerlineClearCache| after changing 
your statusline!

Example: >

    " Insert the charcode segment after the filetype segment
    call Pl#Theme#InsertSegment('charcode', 'after', 'filetype')

    " Replace the scrollpercent segment with the charcode segment
    call Pl#Theme#ReplaceSegment('scrollpercent', 'fileinfo')
<
                                                      *Pl#Theme#InsertSegment*
Pl#Theme#InsertSegment({newsegment}, {location}, {targetsegment})

This function inserts {newsegment} before or after {targetsegment}. The 
{location} parameter specifies the location of the new segment, valid values 
are "before" and "after". You can see all the available segments in 
autoload/Powerline/Segments.vim and the files specified in 
|Powerline-cust-segments|.

Pl#Theme#RemoveSegment({targetsegment})               *Pl#Theme#RemoveSegment*

This function removes the {targetsegment} segment entirely.

Pl#Theme#ReplaceSegment({oldsegment}, {newsegment})  *Pl#Theme#ReplaceSegment*

This function replaces {oldsegment} with {newsegment}.

------------------------------------------------------------------------------
6.2 Advanced customization                  *Powerline-advanced-customization*

Because Powerline utilizes Vim's autoload functionality, you can easily create 
your own segments, themes, functions and colorschemes without touching the 
original source code. This is a bit more complex than using the utility 
functions, but it allows you to do a lot more with your statusline.

Your custom autoload files should be stored in your |runtimepath| (usually in 
"~/.vim/autoload/Powerline/*").

Note: Remember to clear your cache with |:PowerlineClearCache| after changing 
your statusline!

6.2.1 Colorschemes                               *Powerline-cust-colorschemes*
------------------------------------------------------------------------------

Colorschemes should be stored as separate files in 
{runtimepath}/autoload/Powerline/Colorschemes/.

SYNTAX ~

TODO

EXAMPLE ~

TODO

6.2.2 Functions                                     *Powerline-cust-functions*
------------------------------------------------------------------------------

Functions should be stored as separate files in 
{runtimepath}/autoload/Powerline/Functions/.

SYNTAX ~

TODO

EXAMPLE ~

TODO

6.2.3 Segments                                       *Powerline-cust-segments*
------------------------------------------------------------------------------

Segments should be stored as separate files in 
{runtimepath}/autoload/Powerline/Segments/.

SYNTAX ~

TODO

EXAMPLE ~

TODO

6.2.4 Themes                                           *Powerline-cust-themes*
------------------------------------------------------------------------------

Themes should be stored as separate files in 
{runtimepath}/autoload/Powerline/Themes/.

SYNTAX ~

TODO

EXAMPLE ~

TODO

==============================================================================
7. License                                                 *Powerline-license*

Creative Commons Attribution-ShareAlike 3.0 Unported

http://creativecommons.org/licenses/by-sa/3.0/

==============================================================================
8. Known issues                                       *Powerline-known-issues*

See the issue tracker at
https://github.com/Lokaltog/vim-powerline/issues

==============================================================================
9. Contributing                                       *Powerline-contributing*

If you experience any bugs or have feature requests, please open an issue on
GitHub. Fork the source repository on GitHub and send a pull request if you
have any code improvements.

Author: Kim Silkebækken <kim.silkebaekken+vim@gmail.com>
Source repository: https://github.com/Lokaltog/vim-powerline

==============================================================================
vim:tw=78:sw=4:ts=8:ft=help:norl:
SplineFontDB: 3.0
FontName: PowerlineSymbols
FullName: PowerlineSymbols
FamilyName: PowerlineSymbols
Weight: Medium
Copyright: 
UComments: "2011-11-21: Created." 
Version: 001.000
ItalicAngle: 0
UnderlinePosition: -98.6328
UnderlineWidth: 48.8281
Ascent: 800
Descent: 200
LayerCount: 2
Layer: 0 0 "Back"  1
Layer: 1 0 "Fore"  0
XUID: [1021 211 26716215 11021609]
FSType: 0
OS2Version: 0
OS2_WeightWidthSlopeOnly: 0
OS2_UseTypoMetrics: 1
CreationTime: 1321867751
ModificationTime: 1326665029
OS2TypoAscent: 0
OS2TypoAOffset: 1
OS2TypoDescent: 0
OS2TypoDOffset: 1
OS2TypoLinegap: 90
OS2WinAscent: 0
OS2WinAOffset: 1
OS2WinDescent: 0
OS2WinDOffset: 1
HheadAscent: 0
HheadAOffset: 1
HheadDescent: 0
HheadDOffset: 1
OS2Vendor: 'PfEd'
MarkAttachClasses: 1
DEI: 91125
Encoding: UnicodeFull
Compacted: 1
UnicodeInterp: none
NameList: Adobe Glyph List
DisplaySize: -24
AntiAlias: 1
FitToEm: 1
WinInfo: 0 31 18
BeginPrivate: 0
EndPrivate
BeginChars: 1114112 9

StartChar: uni2B80
Encoding: 11136 11136 0
Width: 621
Flags: HMW
LayerCount: 2
Fore
SplineSet
0 1000 m 1
 621 379 l 1
 0 -243 l 1
 0 1000 l 1
EndSplineSet
EndChar

StartChar: uni2B81
Encoding: 11137 11137 1
Width: 621
Flags: HMW
LayerCount: 2
Fore
SplineSet
10 991 m 0
 16 997 23 1000 32 1000 c 0
 41 1000 48 996 54 990 c 2
 613 400 l 2
 619 394 621 386 621 378 c 0
 621 370 618 362 613 357 c 2
 54 -233 l 2
 48 -239 41 -242 32 -242 c 0
 23 -242 16 -240 10 -234 c 0
 4 -228 0 -221 0 -212 c 0
 0 -203 3 -196 8 -190 c 2
 547 379 l 1
 8 948 l 2
 3 954 0 961 0 970 c 0
 0 979 4 985 10 991 c 0
EndSplineSet
EndChar

StartChar: uni2B82
Encoding: 11138 11138 2
Width: 621
Flags: HMW
LayerCount: 2
Fore
SplineSet
621 1000 m 5
 621 -243 l 5
 0 379 l 5
 621 1000 l 5
EndSplineSet
EndChar

StartChar: uni2B83
Encoding: 11139 11139 3
Width: 621
Flags: HMW
LayerCount: 2
Fore
SplineSet
612 991 m 0
 618 985 621 979 621 970 c 0
 621 961 619 954 613 948 c 2
 74 379 l 1
 613 -190 l 2
 619 -196 621 -203 621 -212 c 0
 621 -221 618 -228 612 -234 c 0
 606 -240 598 -242 589 -242 c 0
 580 -242 574 -239 568 -233 c 2
 8 357 l 2
 3 362 0 370 0 378 c 0
 0 386 3 394 8 400 c 2
 568 990 l 2
 574 996 580 1000 589 1000 c 0
 598 1000 606 997 612 991 c 0
EndSplineSet
EndChar

StartChar: uni2B61
Encoding: 11105 11105 4
Width: 555
VWidth: 0
Flags: HMW
LayerCount: 2
Fore
SplineSet
0 800 m 5
 92 800 l 5
 92 513 l 5
 253 513 l 5
 253 444 l 5
 0 444 l 5
 0 800 l 5
236 312 m 5
 339 312 l 5
 468 67 l 5
 468 312 l 5
 555 312 l 5
 555 -44 l 5
 453 -44 l 5
 323 200 l 5
 323 -44 l 5
 236 -44 l 5
 236 312 l 5
EndSplineSet
EndChar

StartChar: uni2B60
Encoding: 11104 11104 5
Width: 676
Flags: HMW
LayerCount: 2
Fore
SplineSet
0 197 m 1
 94 207 419 279 419 384 c 2
 419 537 l 1
 278 501 l 1
 478 794 l 1
 677 501 l 1
 536 537 l 1
 536 384 l 2
 536 196 208 126 208 21 c 2
 208 -244 l 1
 0 -244 l 1
 0 197 l 1
0 288 m 1
 0 405 0 944 0 944 c 1
 208 944 l 1
 208 944 208 451 208 334 c 1
 185 311 12 288 0 288 c 1
EndSplineSet
EndChar

StartChar: uni2B62
Encoding: 11106 11106 6
Width: 428
VWidth: 0
Flags: HMW
LayerCount: 2
Fore
SplineSet
88 677 m 2
 429 677 l 1
 429 589 l 1
 88 589 l 1
 88 162 l 1
 198 162 l 1
 198 343 l 1
 374 343 l 1
 374 427 l 1
 198 427 l 1
 198 506 l 1
 429 506 l 1
 429 274 l 1
 416 263 391 255 374 255 c 2
 286 255 l 1
 286 162 l 2
 286 114 246 74 198 74 c 2
 88 74 l 2
 40 74 0 114 0 162 c 2
 0 589 l 2
 0 637 40 677 88 677 c 2
EndSplineSet
EndChar

StartChar: uni2B63
Encoding: 11107 11107 7
Width: 428
VWidth: 0
Flags: HMW
LayerCount: 2
Fore
SplineSet
0 677 m 5
 341 677 l 6
 389 677 429 637 429 589 c 6
 429 506 l 6
 429 458 389 418 341 418 c 6
 287 418 l 5
 287 162 l 6
 287 114 247 74 199 74 c 6
 89 74 l 6
 41 74 1 114 1 162 c 6
 1 274 l 6
 0 274 l 6
 0 506 l 5
 89 506 l 5
 89 162 l 5
 199 162 l 5
 199 506 l 5
 341 506 l 5
 341 589 l 5
 0 589 l 5
 0 677 l 5
EndSplineSet
EndChar

StartChar: uni2B64
Encoding: 11108 11108 8
Width: 546
VWidth: 0
Flags: HMW
LayerCount: 2
Fore
SplineSet
273 733 m 4
 429 733 430 538 430 538 c 5
 430 420 l 5
 547 420 l 5
 547 303 l 5
 547 303 546 -9 273 -9 c 4
 0 -9 0 303 0 303 c 5
 0 420 l 5
 117 420 l 5
 117 538 l 5
 117 538 117 733 273 733 c 4
273 655 m 4
 195 655 195 576 195 420 c 5
 352 420 l 5
 352 576 351 655 273 655 c 4
273 342 m 4
 195 342 195 147 273 147 c 4
 351 147 351 342 273 342 c 4
EndSplineSet
EndChar
EndChars
BitmapFont: 10 10 8 2 1 
BDFChar: 0 11136 6 0 4 -2 7
JAC+4q"X@:^jlCb
BDFChar: 1 11137 6 0 4 -2 7
J3Y4g#RCta5_&h7
BDFChar: 2 11138 6 1 5 -2 7
#T,OGq"T(n(^L*A
BDFChar: 3 11139 6 1 5 -2 7
#S8+DJ:Km-&-r79
BDFChar: 4 11105 6 1 4 -1 7
J:N1>!0GR3O8o7\
BDFChar: 5 11104 7 0 5 -2 7
^rY<PaN2`d^q]pM
BDFChar: 6 11106 4 1 5 -1 6
G^u0KJ=)F+
BDFChar: 7 11107 4 0 5 -1 6
p]QtGOH>Q3
BDFChar: 8 11108 5 0 5 0 6
0M"b4bku\c
EndBitmapFont
BitmapFont: 12 10 10 2 1 
BDFChar: 0 11136 7 0 6 -2 11
!!%Pbi:-O>r:od>^jlCb
BDFChar: 1 11137 7 0 6 -3 11
!!%O7+:ne]":,P]5_&h7
BDFChar: 2 11138 7 0 6 -2 11
!!!-1*'AWHr-UUH$j6P1
BDFChar: 3 11139 7 0 6 -2 11
!!!--&0O5gJ3Y4g#Qt,-
BDFChar: 4 11105 7 0 5 0 8
J:N1>!$jBP,QIfE
BDFChar: 5 11104 8 0 8 -3 11
z^];.Ma8juqa8j9]a8jQehuLOm^];.Mz
BDFChar: 6 11106 5 1 6 0 8
!-j$]R"1Qc?iU0,
BDFChar: 7 11107 5 0 5 0 7
p]QtGOH>Q3
BDFChar: 8 11108 7 0 5 0 8
0M"`*r63C_GQ7^D
EndBitmapFont
EndSplineFont
======================
Powerline font patcher
======================

:Author: Kim Silkebækken (kim.silkebaekken+vim@gmail.com)

Description
-----------

This font patcher creates dividers and symbols for use with Powerline. The 
script requires Python 2 and FontForge compiled with Python bindings.

Patched fonts are renamed by default (" for Powerline" is added to the font 
name) so they don't conflict with existing fonts. Use the ``--no-rename`` 
option to disable font renaming.

Glyph table
-----------

All the glyphs are stored in the ``U+2B60``-``U+2BFF`` range ("Misc symbols 
and arrows").

+------------+-------------------+
| Code point | Description       |
+============+===================+
| ``U+2B60`` | Branch symbol     |
+------------+-------------------+
| ``U+2B61`` | LN (line) symbol  |
+------------+-------------------+
| ``U+2B62`` | FT symbol, part 1 |
+------------+-------------------+
| ``U+2B63`` | FT symbol, part 2 |
+------------+-------------------+
| ``U+2B64`` | Padlock (closed)  |
+------------+-------------------+
| ``U+2B80`` | Hard right arrow  |
+------------+-------------------+
| ``U+2B81`` | Soft right arrow  |
+------------+-------------------+
| ``U+2B82`` | Hard left arrow   |
+------------+-------------------+
| ``U+2B83`` | Soft left arrow   |
+------------+-------------------+

===================
Font patching guide
===================

There's a `GitHub wiki page`_ dedicated to community-contributed patched 
fonts. You may download one of the fonts on that page if you don't want to 
patch the fonts yourself.

If you do patch a font that's not included in the wiki (and you have 
permission to distribute it), please include it on the wiki page.

**Note:** The fonts in the wiki may be outdated, and may have different 
glyphs than the ones provided in the latest version of Powerline. It's 
recommended that you always patch your fonts yourself if you have the 
required software.

.. _`GitHub wiki page`: https://github.com/Lokaltog/vim-powerline/wiki/Patched-fonts

Linux
-----

1. Install fontforge with Python bindings. For Ubuntu users the required 
   package is ``python-fontforge``, for Arch Linux users the required 
   package is ``fontforge``. It should be something similar for other 
   distros.

2. Run the font patcher::

       $ /path/to/fontpatcher MyFontFile.ttf

3. Copy the font file into ``~/.fonts`` (or another X font directory)::

       $ cp MyFontFile-Powerline.otf ~/.fonts

   **Note:** If the font is a pure bitmap font (e.g. a PCF font) it will be 
   stored in the BDF format. This is usually not a problem, and you may 
   convert the font back to the PCF format using ``bdftopcf`` if you want 
   to. All other fonts will be stored in the OTF format regardless of the 
   original format.

4. Update your font cache::

       $ sudo fc-cache -vf

   **Note:** If you use vim in rxvt-unicode in the client/daemon mode, you 
   may need to close all running terminals as well for the font to be 
   updated.

5. **For gvim users:** Update the GUI font in your ``vimrc`` file::

       set guifont=MyFont\ for\ Powerline

   **For terminal users:** Update your terminal configuration to use the 
   patched font.

6. Update your ``vimrc`` configuration to use the new symbols::

       let g:Powerline_symbols = 'fancy'

7. Make sure that the cache file is deleted::

       $ rm /tmp/Powerline.cache

8. Start vim and enjoy your new statusline!

OS X
----

1. Check if you have a FontForge version with Python support by running 
   ``fontforge -version``. You should see something like this::

       $ fontforge -version
       Copyright (c) 2000-2011 by George Williams.
       Executable based on sources from 13:48 GMT 22-Feb-2011-D.
       Library based on sources from 13:48 GMT 22-Feb-2011.
       fontforge 20110222
       libfontforge 20110222

   Make sure that the executable version number doesn't have ``NoPython`` in 
   it. If everything looks OK, skip ahead to step 4.

2. If you have FontForge but with ``NoPython`` in the version number, please 
   try to update to a later version::

       $ brew uninstall fontforge
       $ brew update
       $ brew install --use-gcc fontforge

   **Note:** You may have to use ``--use-clang`` instead of ``--use-gcc`` 
   when compiling FontForge.

3. If you don't have FontForge, install it with Homebrew::

       $ brew update
       $ brew install --use-gcc fontforge

4. Patch your fonts by passing the ``fontpatcher`` script as a parameter to 
   FontForge::

       $ fontforge -script /path/to/fontpatcher MyFontFile.ttf

5. Install the font by double-clicking the font file in Finder and click 
   "Install this font" from the preview window.

6. **For gvim users:** Update the GUI font in your ``vimrc`` file::

       set guifont=MyFont\ for\ Powerline

   **For terminal users:** Update your terminal configuration to use the 
   patched font.

7. Update your ``vimrc`` configuration to use the new symbols::

       let g:Powerline_symbols = 'fancy'

8. Make sure that the cache file is deleted::

       $ rm /tmp/Powerline.cache

9. Start vim and enjoy your new statusline!
#!/usr/bin/env python

"""Font patcher for Powerline.

Creates dividers and symbols for use with Powerline. Requires FontForge with Python bindings.

Stores glyphs in the 2b60-2bff Unicode range ("Misc symbols and arrows").

[2b60] Branch symbol
[2b61] LN (line) symbol
[2b62] FT symbol 1
[2b63] FT symbol 2
[2b64] Padlock (closed) symbol
[2b80] Hard right arrow
[2b81] Soft right arrow
[2b82] Hard left arrow
[2b83] Soft left arrow
"""

from __future__ import division

import argparse
import os
import sys
import re

try:
	import fontforge
	import psMat
except ImportError:
	sys.stderr.write('The required FontForge modules could not be loaded.\n\n')

	if sys.version_info.major > 2:
		sys.stderr.write('FontForge only supports Python 2. Please run this script with the Python 2 executable - e.g. "python2 {0}"\n'.format(sys.argv[0]))
	else:
		sys.stderr.write('You need FontForge with Python bindings for this script to work.\n')

	sys.exit(1)

# Handle command-line arguments
parser = argparse.ArgumentParser(description='Font patcher for Powerline. Creates dividers and symbols in FontForge-compatible font files. Requires FontForge with Python bindings. Stores glyphs in the U+2B80-U+2BFF range ("Miscellaneous symbols and arrows"). Stores the patched font as a new, renamed font file by default.')

parser.add_argument('fonts', help='font file to patch', metavar='font', nargs='+')
parser.add_argument('--no-rename', help='don\'t add " for Powerline" to the font name', default=True, action='store_false', dest='rename')
parser.add_argument('--symbol-font', help='font file with symbols', metavar='font', dest='symbol_font', default='{0}/PowerlineSymbols.sfd'.format(sys.path[0]))
parser.add_argument('--fix-mono', help='fixes some mono-fonts which have glyphs of 0 widths', default=False, action='store_true', dest='fixmono')
parser.add_argument('--fix-win', help='modifies font names such that Windows correctly recognizes font families', default=False, action='store_true', dest='fixwin')

args = parser.parse_args()

SYM_ATTR = {
	# Right/left-aligned glyphs will have their advance width reduced in order to overlap the next glyph slightly
	0x2b60: { 'align': 'c', 'stretch': 'y' , 'overlap': False },
	0x2b61: { 'align': 'c', 'stretch': ''  , 'overlap': False },
	0x2b62: { 'align': 'r', 'stretch': ''  , 'overlap': False },
	0x2b63: { 'align': 'l', 'stretch': ''  , 'overlap': False },
	0x2b64: { 'align': 'c', 'stretch': ''  , 'overlap': False },
	0x2b80: { 'align': 'l', 'stretch': 'xy', 'overlap': True  },
	0x2b81: { 'align': 'l', 'stretch': 'xy', 'overlap': True  },
	0x2b82: { 'align': 'r', 'stretch': 'xy', 'overlap': True  },
	0x2b83: { 'align': 'r', 'stretch': 'xy', 'overlap': True  },
}

# Open symbol font
try:
	symbols = fontforge.open(args.symbol_font)
except EnvironmentError:
	sys.exit(1)

# Patch provided fonts
for font_path in args.fonts:
	try:
		font = fontforge.open(font_path)
	except EnvironmentError:
		sys.exit(1)

	# Rename font
	if args.rename:
		font.familyname += ' for Powerline'
		font.fullname += ' for Powerline'
		font.fontname += 'ForPowerline'
		font.appendSFNTName('English (US)', 'Preferred Family', font.familyname)
		font.appendSFNTName('English (US)', 'Compatible Full', font.fullname)
	if args.fixwin:
		font.fontname = re.sub(r'\W', '', font.familyname)

	# Force the em size to be equal
	symbols.em = font.em

	# Initial font dimensions
	font_dim = {
		'xmin'  :    0,
		'ymin'  :    -font.descent,
		'xmax'  :    0,
		'ymax'  :    font.ascent,

		'width' :    0,
		'height':    0,
	}

	# Find the biggest char width and height
	#
	# 0x00-0x17f is the Latin Extended-A range
	# 0x2500-0x2600 is the box drawing range
	for glyph in range(0x00, 0x17f) + range(0x2500, 0x2600):
		try:
			(xmin, ymin, xmax, ymax) = font[glyph].boundingBox()
		except TypeError:
			continue

		if font_dim['width'] == 0:
			font_dim['width'] = font[glyph].width

		if ymin < font_dim['ymin']: font_dim['ymin'] = ymin
		if ymax > font_dim['ymax']: font_dim['ymax'] = ymax
		if xmax > font_dim['xmax']: font_dim['xmax'] = xmax

	# Calculate font height
	font_dim['height'] = abs(font_dim['ymin']) + font_dim['ymax']

	# Update the font encoding to ensure that the Unicode glyphs are available
	font.encoding = 'ISO10646'

	# Fetch this property before adding outlines
	onlybitmaps = font.onlybitmaps

	def get_dim(glyph):
		bbox = glyph.boundingBox()

		return  {
			'xmin'  : bbox[0],
			'ymin'  : bbox[1],
			'xmax'  : bbox[2],
			'ymax'  : bbox[3],

			'width' : bbox[2] + (-bbox[0]),
			'height': bbox[3] + (-bbox[1]),
		}

	# Create glyphs from symbol font
	for sym_glyph in symbols.glyphs():
		sym_attr = SYM_ATTR[sym_glyph.unicode]

		# Prepare symbol glyph dimensions
		sym_dim = get_dim(sym_glyph)

		# Select and copy symbol from its encoding point
		symbols.selection.select(sym_glyph.encoding)
		symbols.copy()

		# Select and paste symbol to its unicode code point
		font.selection.select(sym_glyph.unicode)
		font.paste()

		# Now that we have copy/pasted the glyph, it's time to scale and move it

		# Handle glyph stretching
		if 'x' in sym_attr['stretch']:
			# Stretch the glyph horizontally
			scale_ratio = font_dim['width'] / sym_dim['width']

			font.transform(psMat.scale(scale_ratio, 1))
		if 'y' in sym_attr['stretch']:
			# Stretch the glyph vertically
			scale_ratio = font_dim['height'] / sym_dim['height']

			font.transform(psMat.scale(1, scale_ratio))

		# Use the dimensions from the pasted and stretched glyph
		sym_dim = get_dim(font[sym_glyph.unicode])

		# Center-align the glyph vertically
		font_ycenter = font_dim['height'] / 2
		sym_ycenter  = sym_dim['height'] / 2

		# First move it to the ymax (top)
		font.transform(psMat.translate(0, font_dim['ymax'] - sym_dim['ymax']))

		# Then move it the y center difference
		font.transform(psMat.translate(0, sym_ycenter - font_ycenter))

		# Ensure that the glyph doesn't extend outside the font's bounding box
		if sym_dim['width'] > font_dim['width']:
			# The glyph is too wide, scale it down to fit
			scale_matrix = psMat.scale(font_dim['width'] / sym_dim['width'], 1)

			font.transform(scale_matrix)

			# Use the dimensions from the stretched glyph
			sym_dim = get_dim(font[sym_glyph.unicode])

		# Handle glyph alignment
		if sym_attr['align'] == 'c':
			# Center align
			align_matrix = psMat.translate(font_dim['width'] / 2 - sym_dim['width'] / 2 , 0)
		elif sym_attr['align'] == 'r':
			# Right align
			align_matrix = psMat.translate(font_dim['width'] - sym_dim['width'], 0)
		else:
			# No alignment (left alignment)
			align_matrix = psMat.translate(0, 0)

		font.transform(align_matrix)

		if sym_attr['overlap'] is True:
			overlap_width = font.em / 48

			# Stretch the glyph slightly horizontally if it should overlap
			font.transform(psMat.scale((sym_dim['width'] + overlap_width) / sym_dim['width'], 1))

			if sym_attr['align'] == 'l':
				# The glyph should be left-aligned, so it must be moved overlap_width to the left
				# This only applies to left-aligned glyphs because the glyph is scaled to the right
				font.transform(psMat.translate(-overlap_width, 0))

		# Ensure the font is considered monospaced on Windows
		font[sym_glyph.unicode].width = font_dim['width']

	if font.bitmapSizes and not onlybitmaps:
		# If this is an outline font with bitmaps, regenerate bitmaps for the changed glyphs
		font.selection.changed()

		for size in font.bitmapSizes:
			font.regenBitmaps((size, ))

	output_name, extension = os.path.split(font_path)[1].rsplit('.', 1)
	if extension.lower() not in ['ttf', 'otf']:
		# Default to OpenType if input is not TrueType/OpenType
		extension = 'otf'
	if args.fixmono:
		for glyph in font.glyphs():
			if glyph.width == 0: glyph.width = font_dim['width']

	if onlybitmaps:
		# Generate BDF font
		font.generate('{0}-Powerline.bdf'.format(output_name, bitmap_type='bdf'))
	else:
		# Generate OTF/TTF font
		font.generate('{0}-Powerline.{1}'.format(output_name, extension))

" Powerline - The ultimate statusline utility
"
" Author: Kim Silkebækken <kim.silkebaekken+vim@gmail.com>
" Source repository: https://github.com/Lokaltog/vim-powerline

" Script initialization {{{
	if exists('g:Powerline_loaded') || &compatible || version < 702
		finish
	endif

	let g:Powerline_loaded = 1
" }}}
" Commands {{{
	command! PowerlineClearCache call Pl#ClearCache()
	command! PowerlineReloadColorscheme call Pl#ReloadColorscheme()
" }}}
" Set default options {{{
	for [s:key, s:value] in items({
		\   'theme'            : 'default'
		\ , 'colorscheme'      : 'default'
		\ , 'symbols'          : 'compatible'
		\ , 'symbols_override' : {}
		\ , 'dividers_override': []
		\ , 'stl_path_style'   : 'relative'
		\ , 'cache_enabled'    : 1
		\ })

		if ! exists('g:Powerline_' . s:key)
			exec printf('let g:Powerline_%s = %s', s:key, string(s:value))
		endif

		unlet! s:key s:value
	endfor

	if ! exists('g:Powerline_cache_dir')
		let g:Powerline_cache_dir = simplify(expand('<sfile>:p:h') .'/..')
	endif

	if ! exists('g:Powerline_cache_file')
		exec 'let g:Powerline_cache_file = '. string(printf('%s/Powerline_%s_%s_%s.cache'
			\ , g:Powerline_cache_dir
			\ , g:Powerline_theme
			\ , g:Powerline_colorscheme
			\ , g:Powerline_symbols
			\ ))
	endif
" }}}
" Autocommands {{{
	function! s:Startup()
		augroup PowerlineMain
			autocmd!

			" Reload statuslines when changing color scheme
			autocmd ColorScheme *
				\ call Pl#Load()

			autocmd BufEnter,WinEnter,FileType,BufUnload,CmdWinEnter *
				\ call Pl#UpdateStatusline(1)

			autocmd BufLeave,WinLeave,CmdWinLeave *
				\ call Pl#UpdateStatusline(0)

			autocmd BufWritePost */autoload/Powerline/Colorschemes/*.vim
				\ :PowerlineReloadColorscheme
		augroup END

		let curwindow = winnr()
		for window in range(1, winnr('$'))
			call Pl#UpdateStatusline(window == curwindow, window)
		endfor
	endfunction

	augroup PowerlineStartup
		autocmd!

		autocmd VimEnter * call s:Startup()
	augroup END
" }}}
