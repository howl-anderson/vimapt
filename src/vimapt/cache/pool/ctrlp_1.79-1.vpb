- [vimapt/copyright/ctrlp.yaml, 4]
- [vimapt/control/ctrlp.yaml, 5]
- [autoload/ctrlp.vim, 2113]
- [autoload/ctrlp/utils.vim, 120]
- [autoload/ctrlp/bookmarkdir.vim, 140]
- [autoload/ctrlp/rtscript.vim, 59]
- [autoload/ctrlp/undo.vim, 154]
- [autoload/ctrlp/dir.vim, 93]
- [autoload/ctrlp/tag.vim, 128]
- [autoload/ctrlp/changes.vim, 95]
- [autoload/ctrlp/mixed.vim, 83]
- [autoload/ctrlp/buffertag.vim, 261]
- [autoload/ctrlp/line.vim, 62]
- [autoload/ctrlp/quickfix.vim, 59]
- [autoload/ctrlp/mrufiles.vim, 148]
- [doc/ctrlp.txt, 1406]
- [vimrc/ctrlp.vimrc, 0]
- [plugin/ctrlp.vim, 69]

author: 'Kien <Email>'
license: ''
maintiner: 'Howl Anderson <u1mail2me@gmail.com>'
source: 'https://github.com/kien/ctrlp.vim'
depends: ''
section: ''
version: '1.79'
short-description: ''
long-description: ''
" =============================================================================
" File:          autoload/ctrlp.vim
" Description:   Fuzzy file, buffer, mru, tag, etc finder.
" Author:        Kien Nguyen <github.com/kien>
" Version:       1.79
" =============================================================================

" ** Static variables {{{1
" s:ignore() {{{2
fu! s:ignore()
	let igdirs = [
		\ '\.git',
		\ '\.hg',
		\ '\.svn',
		\ '_darcs',
		\ '\.bzr',
		\ '\.cdv',
		\ '\~\.dep',
		\ '\~\.dot',
		\ '\~\.nib',
		\ '\~\.plst',
		\ '\.pc',
		\ '_MTN',
		\ 'blib',
		\ 'CVS',
		\ 'RCS',
		\ 'SCCS',
		\ '_sgbak',
		\ 'autom4te\.cache',
		\ 'cover_db',
		\ '_build',
		\ ]
	let igfiles = [
		\ '\~$',
		\ '#.+#$',
		\ '[._].*\.swp$',
		\ 'core\.\d+$',
		\ '\.exe$',
		\ '\.so$',
		\ '\.bak$',
		\ '\.png$',
		\ '\.jpg$',
		\ '\.gif$',
		\ '\.zip$',
		\ '\.rar$',
		\ '\.tar\.gz$',
		\ ]
	retu {
		\ 'dir': '\v[\/]('.join(igdirs, '|').')$',
		\ 'file': '\v'.join(igfiles, '|'),
		\ }
endf
" Script local vars {{{2
let [s:pref, s:bpref, s:opts, s:new_opts, s:lc_opts] =
	\ ['g:ctrlp_', 'b:ctrlp_', {
	\ 'abbrev':                ['s:abbrev', {}],
	\ 'arg_map':               ['s:argmap', 0],
	\ 'buffer_func':           ['s:buffunc', {}],
	\ 'by_filename':           ['s:byfname', 0],
	\ 'custom_ignore':         ['s:usrign', s:ignore()],
	\ 'default_input':         ['s:deftxt', 0],
	\ 'dont_split':            ['s:nosplit', 'netrw'],
	\ 'dotfiles':              ['s:showhidden', 0],
	\ 'extensions':            ['s:extensions', []],
	\ 'follow_symlinks':       ['s:folsym', 0],
	\ 'highlight_match':       ['s:mathi', [1, 'CtrlPMatch']],
	\ 'jump_to_buffer':        ['s:jmptobuf', 'Et'],
	\ 'key_loop':              ['s:keyloop', 0],
	\ 'lazy_update':           ['s:lazy', 0],
	\ 'match_func':            ['s:matcher', {}],
	\ 'match_window_bottom':   ['s:mwbottom', 1],
	\ 'match_window_reversed': ['s:mwreverse', 1],
	\ 'max_depth':             ['s:maxdepth', 40],
	\ 'max_files':             ['s:maxfiles', 10000],
	\ 'max_height':            ['s:mxheight', 10],
	\ 'max_history':           ['s:maxhst', exists('+hi') ? &hi : 20],
	\ 'mruf_default_order':    ['s:mrudef', 0],
	\ 'open_func':             ['s:openfunc', {}],
	\ 'open_multi':            ['s:opmul', '1v'],
	\ 'open_new_file':         ['s:newfop', 'v'],
	\ 'prompt_mappings':       ['s:urprtmaps', 0],
	\ 'regexp_search':         ['s:regexp', 0],
	\ 'root_markers':          ['s:rmarkers', []],
	\ 'split_window':          ['s:splitwin', 0],
	\ 'status_func':           ['s:status', {}],
	\ 'tabpage_position':      ['s:tabpage', 'ac'],
	\ 'use_caching':           ['s:caching', 1],
	\ 'use_migemo':            ['s:migemo', 0],
	\ 'user_command':          ['s:usrcmd', ''],
	\ 'working_path_mode':     ['s:pathmode', 'ra'],
	\ }, {
	\ 'open_multiple_files':   's:opmul',
	\ 'regexp':                's:regexp',
	\ 'reuse_window':          's:nosplit',
	\ 'show_hidden':           's:showhidden',
	\ 'switch_buffer':         's:jmptobuf',
	\ }, {
	\ 'root_markers':          's:rmarkers',
	\ 'user_command':          's:usrcmd',
	\ 'working_path_mode':     's:pathmode',
	\ }]

" Global options
let s:glbs = { 'magic': 1, 'to': 1, 'tm': 0, 'sb': 1, 'hls': 0, 'im': 0,
	\ 'report': 9999, 'sc': 0, 'ss': 0, 'siso': 0, 'mfd': 200, 'mouse': 'n',
	\ 'gcr': 'a:blinkon0', 'ic': 1, 'lmap': '', 'mousef': 0, 'imd': 1 }

" Keymaps
let [s:lcmap, s:prtmaps] = ['nn <buffer> <silent>', {
	\ 'PrtBS()':              ['<bs>', '<c-]>'],
	\ 'PrtDelete()':          ['<del>'],
	\ 'PrtDeleteWord()':      ['<c-w>'],
	\ 'PrtClear()':           ['<c-u>'],
	\ 'PrtSelectMove("j")':   ['<c-j>', '<down>'],
	\ 'PrtSelectMove("k")':   ['<c-k>', '<up>'],
	\ 'PrtSelectMove("t")':   ['<Home>', '<kHome>'],
	\ 'PrtSelectMove("b")':   ['<End>', '<kEnd>'],
	\ 'PrtSelectMove("u")':   ['<PageUp>', '<kPageUp>'],
	\ 'PrtSelectMove("d")':   ['<PageDown>', '<kPageDown>'],
	\ 'PrtHistory(-1)':       ['<c-n>'],
	\ 'PrtHistory(1)':        ['<c-p>'],
	\ 'AcceptSelection("e")': ['<cr>', '<2-LeftMouse>'],
	\ 'AcceptSelection("h")': ['<c-x>', '<c-cr>', '<c-s>'],
	\ 'AcceptSelection("t")': ['<c-t>'],
	\ 'AcceptSelection("v")': ['<c-v>', '<RightMouse>'],
	\ 'ToggleFocus()':        ['<s-tab>'],
	\ 'ToggleRegex()':        ['<c-r>'],
	\ 'ToggleByFname()':      ['<c-d>'],
	\ 'ToggleType(1)':        ['<c-f>', '<c-up>'],
	\ 'ToggleType(-1)':       ['<c-b>', '<c-down>'],
	\ 'PrtExpandDir()':       ['<tab>'],
	\ 'PrtInsert("c")':       ['<MiddleMouse>', '<insert>'],
	\ 'PrtInsert()':          ['<c-\>'],
	\ 'PrtCurStart()':        ['<c-a>'],
	\ 'PrtCurEnd()':          ['<c-e>'],
	\ 'PrtCurLeft()':         ['<c-h>', '<left>', '<c-^>'],
	\ 'PrtCurRight()':        ['<c-l>', '<right>'],
	\ 'PrtClearCache()':      ['<F5>'],
	\ 'PrtDeleteEnt()':       ['<F7>'],
	\ 'CreateNewFile()':      ['<c-y>'],
	\ 'MarkToOpen()':         ['<c-z>'],
	\ 'OpenMulti()':          ['<c-o>'],
	\ 'PrtExit()':            ['<esc>', '<c-c>', '<c-g>'],
	\ }]

if !has('gui_running')
	cal add(s:prtmaps['PrtBS()'], remove(s:prtmaps['PrtCurLeft()'], 0))
en

let s:compare_lim = 3000

let s:ficounts = {}

let s:ccex = s:pref.'clear_cache_on_exit'

" Regexp
let s:fpats = {
	\ '^\(\\|\)\|\(\\|\)$': '\\|',
	\ '^\\\(zs\|ze\|<\|>\)': '^\\\(zs\|ze\|<\|>\)',
	\ '^\S\*$': '\*',
	\ '^\S\\?$': '\\?',
	\ }

" Keypad
let s:kprange = {
	\ 'Plus': '+',
	\ 'Minus': '-',
	\ 'Divide': '/',
	\ 'Multiply': '*',
	\ 'Point': '.',
	\ }

" Highlight groups
let s:hlgrps = {
	\ 'NoEntries': 'Error',
	\ 'Mode1': 'Character',
	\ 'Mode2': 'LineNr',
	\ 'Stats': 'Function',
	\ 'Match': 'Identifier',
	\ 'PrtBase': 'Comment',
	\ 'PrtText': 'Normal',
	\ 'PrtCursor': 'Constant',
	\ }
" s:opts() {{{2
fu! s:opts(...)
	unl! s:usrign s:usrcmd s:urprtmaps
	for each in ['byfname', 'regexp', 'extensions'] | if exists('s:'.each)
		let {each} = s:{each}
	en | endfo
	for [ke, va] in items(s:opts)
		let {va[0]} = exists(s:pref.ke) ? {s:pref.ke} : va[1]
	endfo
	unl va
	for [ke, va] in items(s:new_opts)
		let {va} = {exists(s:pref.ke) ? s:pref.ke : va}
	endfo
	unl va
	for [ke, va] in items(s:lc_opts)
		if exists(s:bpref.ke)
			unl {va}
			let {va} = {s:bpref.ke}
		en
	endfo
	if a:0 && a:1 != {}
		unl va
		for [ke, va] in items(a:1)
			let opke = substitute(ke, '\(\w:\)\?ctrlp_', '', '')
			if has_key(s:lc_opts, opke)
				let sva = s:lc_opts[opke]
				unl {sva}
				let {sva} = va
			en
		endfo
	en
	for each in ['byfname', 'regexp'] | if exists(each)
		let s:{each} = {each}
	en | endfo
	if !exists('g:ctrlp_newcache') | let g:ctrlp_newcache = 0 | en
	let s:maxdepth = min([s:maxdepth, 100])
	let s:mxheight = max([s:mxheight, 1])
	let s:glob = s:showhidden ? '.*\|*' : '*'
	let s:igntype = empty(s:usrign) ? -1 : type(s:usrign)
	let s:lash = ctrlp#utils#lash()
	if s:keyloop
		let [s:lazy, s:glbs['imd']] = [0, 0]
	en
	if s:lazy
		cal extend(s:glbs, { 'ut': ( s:lazy > 1 ? s:lazy : 250 ) })
	en
	" Extensions
	if !( exists('extensions') && extensions == s:extensions )
		for each in s:extensions
			exe 'ru autoload/ctrlp/'.each.'.vim'
		endfo
	en
	" Keymaps
	if type(s:urprtmaps) == 4
		cal extend(s:prtmaps, s:urprtmaps)
	en
endf
"}}}1
" * Open & Close {{{1
fu! s:Open()
	cal s:log(1)
	cal s:getenv()
	cal s:execextvar('enter')
	sil! exe 'keepa' ( s:mwbottom ? 'bo' : 'to' ) '1new ControlP'
	cal s:buffunc(1)
	let [s:bufnr, s:winw] = [bufnr('%'), winwidth(0)]
	let [s:focus, s:prompt] = [1, ['', '', '']]
	abc <buffer>
	if !exists('s:hstry')
		let hst = filereadable(s:gethistloc()[1]) ? s:gethistdata() : ['']
		let s:hstry = empty(hst) || !s:maxhst ? [''] : hst
	en
	for [ke, va] in items(s:glbs) | if exists('+'.ke)
		sil! exe 'let s:glb_'.ke.' = &'.ke.' | let &'.ke.' = '.string(va)
	en | endfo
	if s:opmul != '0' && has('signs')
		sign define ctrlpmark text=+> texthl=Search
	en
	cal s:setupblank()
endf

fu! s:Close()
	cal s:buffunc(0)
	try | bun!
	cat | clo! | endt
	cal s:unmarksigns()
	for key in keys(s:glbs) | if exists('+'.key)
		sil! exe 'let &'.key.' = s:glb_'.key
	en | endfo
	if exists('s:glb_acd') | let &acd = s:glb_acd | en
	let g:ctrlp_lines = []
	if s:winres[1] >= &lines && s:winres[2] == winnr('$')
		exe s:winres[0].s:winres[0]
	en
	unl! s:focus s:hisidx s:hstgot s:marked s:statypes s:cline s:init s:savestr
		\ s:mrbs s:did_exp
	cal ctrlp#recordhist()
	cal s:execextvar('exit')
	cal s:log(0)
	let v:errmsg = s:ermsg
	ec
endf
" * Clear caches {{{1
fu! ctrlp#clr(...)
	let [s:matches, g:ctrlp_new{ a:0 ? a:1 : 'cache' }] = [1, 1]
endf

fu! ctrlp#clra()
	let cadir = ctrlp#utils#cachedir()
	if isdirectory(cadir)
		let cafiles = split(s:glbpath(s:fnesc(cadir, 'g', ','), '**', 1), "\n")
		let eval = '!isdirectory(v:val) && fnamemodify(v:val, ":t") !~'
			\ . ' ''\v^<cache>[.a-z]+$|\.log$'''
		sil! cal map(filter(cafiles, eval), 'delete(v:val)')
	en
	cal ctrlp#clr()
endf

fu! s:Reset(args)
	let opts = has_key(a:args, 'opts') ? [a:args['opts']] : []
	cal call('s:opts', opts)
	cal s:autocmds()
	cal ctrlp#utils#opts()
	cal s:execextvar('opts')
endf
" * Files {{{1
fu! ctrlp#files()
	let cafile = ctrlp#utils#cachefile()
	if g:ctrlp_newcache || !filereadable(cafile) || s:nocache(cafile)
		let [lscmd, s:initcwd, g:ctrlp_allfiles] = [s:lsCmd(), s:dyncwd, []]
		" Get the list of files
		if empty(lscmd)
			cal s:GlobPath(s:fnesc(s:dyncwd, 'g', ','), 0)
		el
			sil! cal ctrlp#progress('Indexing...')
			try | cal s:UserCmd(lscmd)
			cat | retu [] | endt
		en
		" Remove base directory
		cal ctrlp#rmbasedir(g:ctrlp_allfiles)
		if len(g:ctrlp_allfiles) <= s:compare_lim
			cal sort(g:ctrlp_allfiles, 'ctrlp#complen')
		en
		cal s:writecache(cafile)
		let catime = getftime(cafile)
	el
		let catime = getftime(cafile)
		if !( exists('s:initcwd') && s:initcwd == s:dyncwd )
			\ || get(s:ficounts, s:dyncwd, [0, catime])[1] != catime
			let s:initcwd = s:dyncwd
			let g:ctrlp_allfiles = ctrlp#utils#readfile(cafile)
		en
	en
	cal extend(s:ficounts, { s:dyncwd : [len(g:ctrlp_allfiles), catime] })
	retu g:ctrlp_allfiles
endf

fu! s:GlobPath(dirs, depth)
	let entries = split(globpath(a:dirs, s:glob), "\n")
	let [dnf, depth] = [ctrlp#dirnfile(entries), a:depth + 1]
	cal extend(g:ctrlp_allfiles, dnf[1])
	if !empty(dnf[0]) && !s:maxf(len(g:ctrlp_allfiles)) && depth <= s:maxdepth
		sil! cal ctrlp#progress(len(g:ctrlp_allfiles), 1)
		cal s:GlobPath(join(map(dnf[0], 's:fnesc(v:val, "g", ",")'), ','), depth)
	en
endf

fu! s:UserCmd(lscmd)
	let [path, lscmd] = [s:dyncwd, a:lscmd]
	if exists('+ssl') && &ssl
		let [ssl, &ssl, path] = [&ssl, 0, tr(path, '/', '\')]
	en
	if has('win32') || has('win64')
		let lscmd = substitute(lscmd, '\v(^|&&\s*)\zscd (/d)@!', 'cd /d ', '')
	en
	let path = exists('*shellescape') ? shellescape(path) : path
	let g:ctrlp_allfiles = split(system(printf(lscmd, path)), "\n")
	if exists('+ssl') && exists('ssl')
		let &ssl = ssl
		cal map(g:ctrlp_allfiles, 'tr(v:val, "\\", "/")')
	en
	if exists('s:vcscmd') && s:vcscmd
		cal map(g:ctrlp_allfiles, 'tr(v:val, "/", "\\")')
	en
	if type(s:usrcmd) == 4 && has_key(s:usrcmd, 'ignore') && s:usrcmd['ignore']
		if !empty(s:usrign)
			let g:ctrlp_allfiles = ctrlp#dirnfile(g:ctrlp_allfiles)[1]
		en
		if &wig != ''
			cal filter(g:ctrlp_allfiles, 'glob(v:val) != ""')
		en
	en
endf

fu! s:lsCmd()
	let cmd = s:usrcmd
	if type(cmd) == 1
		retu cmd
	elsei type(cmd) == 3 && len(cmd) >= 2 && cmd[:1] != ['', '']
		if s:findroot(s:dyncwd, cmd[0], 0, 1) == []
			retu len(cmd) == 3 ? cmd[2] : ''
		en
		let s:vcscmd = s:lash == '\'
		retu cmd[1]
	elsei type(cmd) == 4 && ( has_key(cmd, 'types') || has_key(cmd, 'fallback') )
		let fndroot = []
		if has_key(cmd, 'types') && cmd['types'] != {}
			let [markrs, cmdtypes] = [[], values(cmd['types'])]
			for pair in cmdtypes
				cal add(markrs, pair[0])
			endfo
			let fndroot = s:findroot(s:dyncwd, markrs, 0, 1)
		en
		if fndroot == []
			retu has_key(cmd, 'fallback') ? cmd['fallback'] : ''
		en
		for pair in cmdtypes
			if pair[0] == fndroot[0] | brea | en
		endfo
		let s:vcscmd = s:lash == '\'
		retu pair[1]
	en
endf
" - Buffers {{{1
fu! ctrlp#buffers(...)
	let ids = sort(filter(range(1, bufnr('$')), 'empty(getbufvar(v:val, "&bt"))'
		\ .' && getbufvar(v:val, "&bl") && strlen(bufname(v:val))'), 's:compmreb')
	retu a:0 && a:1 == 'id' ? ids : map(ids, 'fnamemodify(bufname(v:val), ":.")')
endf
" * MatchedItems() {{{1
fu! s:MatchIt(items, pat, limit, exc)
	let [lines, id] = [[], 0]
	let pat =
		\ s:byfname ? map(split(a:pat, '^[^;]\+\\\@<!\zs;', 1), 's:martcs.v:val')
		\ : s:martcs.a:pat
	for item in a:items
		let id += 1
		try | if !( s:ispath && item == a:exc ) && call(s:mfunc, [item, pat]) >= 0
			cal add(lines, item)
		en | cat | brea | endt
		if a:limit > 0 && len(lines) >= a:limit | brea | en
	endfo
	let s:mdata = [s:dyncwd, s:itemtype, s:regexp, s:sublist(a:items, id, -1)]
	retu lines
endf

fu! s:MatchedItems(items, pat, limit)
	let exc = exists('s:crfilerel') ? s:crfilerel : ''
	let items = s:narrowable() ? s:matched + s:mdata[3] : a:items
	if s:matcher != {}
		let argms = [items, a:pat, a:limit, s:mmode(), s:ispath, exc, s:regexp]
		let lines = call(s:matcher['match'], argms, s:matcher)
	el
		let lines = s:MatchIt(items, a:pat, a:limit, exc)
	en
	let s:matches = len(lines)
	unl! s:did_exp
	retu lines
endf

fu! s:SplitPattern(str)
	let str = a:str
	if s:migemo && s:regexp && len(str) > 0 && executable('cmigemo')
		let str = s:migemo(str)
	en
	let s:savestr = str
	if s:regexp
		let pat = s:regexfilter(str)
	el
		let lst = split(str, '\zs')
		if exists('+ssl') && !&ssl
			cal map(lst, 'escape(v:val, ''\'')')
		en
		for each in ['^', '$', '.']
			cal map(lst, 'escape(v:val, each)')
		endfo
	en
	if exists('lst')
		let pat = ''
		if !empty(lst)
			if s:byfname && index(lst, ';') > 0
				let fbar = index(lst, ';')
				let lst_1 = s:sublist(lst, 0, fbar - 1)
				let lst_2 = len(lst) - 1 > fbar ? s:sublist(lst, fbar + 1, -1) : ['']
				let pat = s:buildpat(lst_1).';'.s:buildpat(lst_2)
			el
				let pat = s:buildpat(lst)
			en
		en
	en
	retu escape(pat, '~')
endf
" * BuildPrompt() {{{1
fu! s:Render(lines, pat)
	let [&ma, lines, s:height] = [1, a:lines, min([len(a:lines), s:winh])]
	let pat = s:byfname ? split(a:pat, '^[^;]\+\\\@<!\zs;', 1)[0] : a:pat
	" Setup the match window
	sil! exe '%d _ | res' s:height
	" Print the new items
	if empty(lines)
		let [s:matched, s:lines] = [[], []]
		cal setline(1, ' == NO ENTRIES ==')
		setl noma nocul
		cal s:unmarksigns()
		if s:dohighlight() | cal clearmatches() | en
		retu
	en
	let s:matched = copy(lines)
	" Sorting
	if !s:nosort()
		let s:compat = s:martcs.pat
		cal sort(lines, 's:mixedsort')
		unl s:compat
	en
	if s:mwreverse | cal reverse(lines) | en
	let s:lines = copy(lines)
	cal map(lines, 's:formatline(v:val)')
	cal setline(1, lines)
	setl noma cul
	exe 'keepj norm!' ( s:mwreverse ? 'G' : 'gg' ).'1|'
	cal s:unmarksigns()
	cal s:remarksigns()
	if exists('s:cline') && s:nolim != 1
		cal cursor(s:cline, 1)
	en
	" Highlighting
	if s:dohighlight()
		cal s:highlight(pat, s:mathi[1])
	en
endf

fu! s:Update(str)
	" Get the previous string if existed
	let oldstr = exists('s:savestr') ? s:savestr : ''
	" Get the new string sans tail
	let str = s:sanstail(a:str)
	" Stop if the string's unchanged
	if str == oldstr && !empty(str) && !exists('s:force') | retu | en
	let s:martcs = &scs && str =~ '\u' ? '\C' : ''
	let pat = s:matcher == {} ? s:SplitPattern(str) : str
	let lines = s:nolim == 1 && empty(str) ? copy(g:ctrlp_lines)
		\ : s:MatchedItems(g:ctrlp_lines, pat, s:winh)
	cal s:Render(lines, pat)
endf

fu! s:ForceUpdate()
	sil! cal s:Update(escape(s:getinput(), '\'))
endf

fu! s:BuildPrompt(upd)
	let base = ( s:regexp ? 'r' : '>' ).( s:byfname ? 'd' : '>' ).'> '
	let str = escape(s:getinput(), '\')
	let lazy = str == '' || exists('s:force') || !has('autocmd') ? 0 : s:lazy
	if a:upd && !lazy && ( s:matches || s:regexp || exists('s:did_exp')
		\ || str =~ '\(\\\(<\|>\)\|[*|]\)\|\(\\\:\([^:]\|\\:\)*$\)' )
		sil! cal s:Update(str)
	en
	sil! cal ctrlp#statusline()
	" Toggling
	let [hiactive, hicursor, base] = s:focus
		\ ? ['CtrlPPrtText', 'CtrlPPrtCursor', base]
		\ : ['CtrlPPrtBase', 'CtrlPPrtBase', tr(base, '>', '-')]
	let hibase = 'CtrlPPrtBase'
	" Build it
	redr
	let prt = copy(s:prompt)
	cal map(prt, 'escape(v:val, ''"\'')')
	exe 'echoh' hibase '| echon "'.base.'"
		\ | echoh' hiactive '| echon "'.prt[0].'"
		\ | echoh' hicursor '| echon "'.prt[1].'"
		\ | echoh' hiactive '| echon "'.prt[2].'" | echoh None'
	" Append the cursor at the end
	if empty(prt[1]) && s:focus
		exe 'echoh' hibase '| echon "_" | echoh None'
	en
endf
" - SetDefTxt() {{{1
fu! s:SetDefTxt()
	if s:deftxt == '0' || ( s:deftxt == 1 && !s:ispath ) | retu | en
	let txt = s:deftxt
	if !type(txt)
		let txt = txt && !stridx(s:crfpath, s:dyncwd)
			\ ? ctrlp#rmbasedir([s:crfpath])[0] : ''
		let txt = txt != '' ? txt.s:lash(s:crfpath) : ''
	el
		let txt = expand(txt, 1)
	en
	let s:prompt[0] = txt
endf
" ** Prt Actions {{{1
" Editing {{{2
fu! s:PrtClear()
	if !s:focus | retu | en
	unl! s:hstgot
	let [s:prompt, s:matches] = [['', '', ''], 1]
	cal s:BuildPrompt(1)
endf

fu! s:PrtAdd(char)
	unl! s:hstgot
	let s:act_add = 1
	let s:prompt[0] .= a:char
	cal s:BuildPrompt(1)
	unl s:act_add
endf

fu! s:PrtBS()
	if !s:focus | retu | en
	unl! s:hstgot
	let [s:prompt[0], s:matches] = [substitute(s:prompt[0], '.$', '', ''), 1]
	cal s:BuildPrompt(1)
endf

fu! s:PrtDelete()
	if !s:focus | retu | en
	unl! s:hstgot
	let [prt, s:matches] = [s:prompt, 1]
	let prt[1] = matchstr(prt[2], '^.')
	let prt[2] = substitute(prt[2], '^.', '', '')
	cal s:BuildPrompt(1)
endf

fu! s:PrtDeleteWord()
	if !s:focus | retu | en
	unl! s:hstgot
	let [str, s:matches] = [s:prompt[0], 1]
	let str = str =~ '\W\w\+$' ? matchstr(str, '^.\+\W\ze\w\+$')
		\ : str =~ '\w\W\+$' ? matchstr(str, '^.\+\w\ze\W\+$')
		\ : str =~ '\s\+$' ? matchstr(str, '^.*\S\ze\s\+$')
		\ : str =~ '\v^(\S+|\s+)$' ? '' : str
	let s:prompt[0] = str
	cal s:BuildPrompt(1)
endf

fu! s:PrtInsert(...)
	if !s:focus | retu | en
	let type = !a:0 ? '' : a:1
	if !a:0
		let type = s:insertstr()
		if type == 'cancel' | retu | en
	en
	if type ==# 'r'
		let regcont = s:getregs()
		if regcont < 0 | retu | en
	en
	unl! s:hstgot
	let s:act_add = 1
	let s:prompt[0] .= type ==# 'w' ? s:crword
		\ : type ==# 'f' ? s:crgfile
		\ : type ==# 's' ? s:regisfilter('/')
		\ : type ==# 'v' ? s:crvisual
		\ : type ==# 'c' ? s:regisfilter('+')
		\ : type ==# 'r' ? regcont : ''
	cal s:BuildPrompt(1)
	unl s:act_add
endf

fu! s:PrtExpandDir()
	if !s:focus | retu | en
	let str = s:getinput('c')
	if str =~ '\v^\@(cd|lc[hd]?|chd)\s.+' && s:spi
		let hasat = split(str, '\v^\@(cd|lc[hd]?|chd)\s*\zs')
		let str = get(hasat, 1, '')
	en
	if str == '' | retu | en
	unl! s:hstgot
	let s:act_add = 1
	let [base, seed] = s:headntail(str)
	let dirs = s:dircompl(base, seed)
	if len(dirs) == 1
		let str = dirs[0]
	elsei len(dirs) > 1
		let str .= s:findcommon(dirs, str)
	en
	let s:prompt[0] = exists('hasat') ? hasat[0].str : str
	cal s:BuildPrompt(1)
	unl s:act_add
endf
" Movement {{{2
fu! s:PrtCurLeft()
	if !s:focus | retu | en
	let prt = s:prompt
	if !empty(prt[0])
		let s:prompt = [substitute(prt[0], '.$', '', ''), matchstr(prt[0], '.$'),
			\ prt[1] . prt[2]]
	en
	cal s:BuildPrompt(0)
endf

fu! s:PrtCurRight()
	if !s:focus | retu | en
	let prt = s:prompt
	let s:prompt = [prt[0] . prt[1], matchstr(prt[2], '^.'),
		\ substitute(prt[2], '^.', '', '')]
	cal s:BuildPrompt(0)
endf

fu! s:PrtCurStart()
	if !s:focus | retu | en
	let str = join(s:prompt, '')
	let s:prompt = ['', matchstr(str, '^.'), substitute(str, '^.', '', '')]
	cal s:BuildPrompt(0)
endf

fu! s:PrtCurEnd()
	if !s:focus | retu | en
	let s:prompt = [join(s:prompt, ''), '', '']
	cal s:BuildPrompt(0)
endf

fu! s:PrtSelectMove(dir)
	let wht = winheight(0)
	let dirs = {'t': 'gg','b': 'G','j': 'j','k': 'k','u': wht.'k','d': wht.'j'}
	exe 'keepj norm!' dirs[a:dir]
	if s:nolim != 1 | let s:cline = line('.') | en
	if line('$') > winheight(0) | cal s:BuildPrompt(0) | en
endf

fu! s:PrtSelectJump(char)
	let lines = copy(s:lines)
	if s:byfname
		cal map(lines, 'split(v:val, ''[\/]\ze[^\/]\+$'')[-1]')
	en
	" Cycle through matches, use s:jmpchr to store last jump
	let chr = escape(matchstr(a:char, '^.'), '.~')
	let smartcs = &scs && chr =~ '\u' ? '\C' : ''
	if match(lines, smartcs.'^'.chr) >= 0
		" If not exists or does but not for the same char
		let pos = match(lines, smartcs.'^'.chr)
		if !exists('s:jmpchr') || ( exists('s:jmpchr') && s:jmpchr[0] != chr )
			let [jmpln, s:jmpchr] = [pos, [chr, pos]]
		elsei exists('s:jmpchr') && s:jmpchr[0] == chr
			" Start of lines
			if s:jmpchr[1] == -1 | let s:jmpchr[1] = pos | en
			let npos = match(lines, smartcs.'^'.chr, s:jmpchr[1] + 1)
			let [jmpln, s:jmpchr] = [npos == -1 ? pos : npos, [chr, npos]]
		en
		exe 'keepj norm!' ( jmpln + 1 ).'G'
		if s:nolim != 1 | let s:cline = line('.') | en
		if line('$') > winheight(0) | cal s:BuildPrompt(0) | en
	en
endf
" Misc {{{2
fu! s:PrtFocusMap(char)
	cal call(( s:focus ? 's:PrtAdd' : 's:PrtSelectJump' ), [a:char])
endf

fu! s:PrtClearCache()
	if s:itemtype == 0
		cal ctrlp#clr()
	elsei s:itemtype > 2
		cal ctrlp#clr(s:statypes[s:itemtype][1])
	en
	if s:itemtype == 2
		let g:ctrlp_lines = ctrlp#mrufiles#refresh()
	el
		cal ctrlp#setlines()
	en
	let s:force = 1
	cal s:BuildPrompt(1)
	unl s:force
endf

fu! s:PrtDeleteEnt()
	if s:itemtype == 2
		cal s:PrtDeleteMRU()
	elsei type(s:getextvar('wipe')) == 1
		cal s:delent(s:getextvar('wipe'))
	en
endf

fu! s:PrtDeleteMRU()
	if s:itemtype == 2
		cal s:delent('ctrlp#mrufiles#remove')
	en
endf

fu! s:PrtExit()
	if bufnr('%') == s:bufnr && bufname('%') == 'ControlP'
		if !has('autocmd') | cal s:Close() | en
		exe ( winnr('$') == 1 ? 'bw!' : 'winc p' )
	en
endf

fu! s:PrtHistory(...)
	if !s:focus || !s:maxhst | retu | en
	let [str, hst, s:matches] = [join(s:prompt, ''), s:hstry, 1]
	" Save to history if not saved before
	let [hst[0], hslen] = [exists('s:hstgot') ? hst[0] : str, len(hst)]
	let idx = exists('s:hisidx') ? s:hisidx + a:1 : a:1
	" Limit idx within 0 and hslen
	let idx = idx < 0 ? 0 : idx >= hslen ? hslen > 1 ? hslen - 1 : 0 : idx
	let s:prompt = [hst[idx], '', '']
	let [s:hisidx, s:hstgot, s:force] = [idx, 1, 1]
	cal s:BuildPrompt(1)
	unl s:force
endf
"}}}1
" * Mappings {{{1
fu! s:MapNorms()
	if exists('s:nmapped') && s:nmapped == s:bufnr | retu | en
	let pcmd = "nn \<buffer> \<silent> \<k%s> :\<c-u>cal \<SID>%s(\"%s\")\<cr>"
	let cmd = substitute(pcmd, 'k%s', 'char-%d', '')
	let pfunc = 'PrtFocusMap'
	let ranges = [32, 33, 125, 126] + range(35, 91) + range(93, 123)
	for each in [34, 92, 124]
		exe printf(cmd, each, pfunc, escape(nr2char(each), '"|\'))
	endfo
	for each in ranges
		exe printf(cmd, each, pfunc, nr2char(each))
	endfo
	for each in range(0, 9)
		exe printf(pcmd, each, pfunc, each)
	endfo
	for [ke, va] in items(s:kprange)
		exe printf(pcmd, ke, pfunc, va)
	endfo
	let s:nmapped = s:bufnr
endf

fu! s:MapSpecs()
	if !( exists('s:smapped') && s:smapped == s:bufnr )
		" Correct arrow keys in terminal
		if ( has('termresponse') && v:termresponse =~ "\<ESC>" )
			\ || &term =~? '\vxterm|<k?vt|gnome|screen|linux|ansi'
			for each in ['\A <up>','\B <down>','\C <right>','\D <left>']
				exe s:lcmap.' <esc>['.each
			endfo
		en
	en
	for [ke, va] in items(s:prtmaps) | for kp in va
		exe s:lcmap kp ':<c-u>cal <SID>'.ke.'<cr>'
	endfo | endfo
	let s:smapped = s:bufnr
endf

fu! s:KeyLoop()
	wh exists('s:init') && s:keyloop
		redr
		let nr = getchar()
		let chr = !type(nr) ? nr2char(nr) : nr
		if nr >=# 0x20
			cal s:PrtFocusMap(chr)
		el
			let cmd = matchstr(maparg(chr), ':<C-U>\zs.\+\ze<CR>$')
			exe ( cmd != '' ? cmd : 'norm '.chr )
		en
	endw
endf
" * Toggling {{{1
fu! s:ToggleFocus()
	let s:focus = !s:focus
	cal s:BuildPrompt(0)
endf

fu! s:ToggleRegex()
	let s:regexp = !s:regexp
	cal s:PrtSwitcher()
endf

fu! s:ToggleByFname()
	if s:ispath
		let s:byfname = !s:byfname
		let s:mfunc = s:mfunc()
		cal s:PrtSwitcher()
	en
endf

fu! s:ToggleType(dir)
	let max = len(g:ctrlp_ext_vars) + 2
	let next = s:walker(max, s:itemtype, a:dir)
	cal ctrlp#syntax()
	cal ctrlp#setlines(next)
	cal s:PrtSwitcher()
endf

fu! s:ToggleKeyLoop()
	let s:keyloop = !s:keyloop
	if exists('+imd')
		let &imd = !s:keyloop
	en
	if s:keyloop
		let [&ut, s:lazy] = [0, 0]
		cal s:KeyLoop()
	elsei has_key(s:glbs, 'ut')
		let [&ut, s:lazy] = [s:glbs['ut'], 1]
	en
endf

fu! s:PrtSwitcher()
	let [s:force, s:matches] = [1, 1]
	cal s:BuildPrompt(1)
	unl s:force
endf
" - SetWD() {{{1
fu! s:SetWD(args)
	if has_key(a:args, 'args') && stridx(a:args['args'], '--dir') >= 0
		\ && exists('s:dyncwd')
		cal ctrlp#setdir(s:dyncwd) | retu
	en
	if has_key(a:args, 'dir') && a:args['dir'] != ''
		cal ctrlp#setdir(a:args['dir']) | retu
	en
	let pmode = has_key(a:args, 'mode') ? a:args['mode'] : s:pathmode
	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
	if s:crfile =~ '^.\+://' | retu | en
	if pmode =~ 'c' || ( pmode =~ 'a' && stridx(s:crfpath, s:cwd) < 0 )
		\ || ( !type(pmode) && pmode )
		if exists('+acd') | let [s:glb_acd, &acd] = [&acd, 0] | en
		cal ctrlp#setdir(s:crfpath)
	en
	if pmode =~ 'r' || pmode == 2
		let markers = ['.git', '.hg', '.svn', '.bzr', '_darcs']
		let spath = pmode =~ 'd' ? s:dyncwd : pmode =~ 'w' ? s:cwd : s:crfpath
		if type(s:rmarkers) == 3 && !empty(s:rmarkers)
			if s:findroot(spath, s:rmarkers, 0, 0) != [] | retu | en
			cal filter(markers, 'index(s:rmarkers, v:val) < 0')
		en
		cal s:findroot(spath, markers, 0, 0)
	en
endf
" * AcceptSelection() {{{1
fu! ctrlp#acceptfile(mode, line, ...)
	let [md, filpath] = [a:mode, fnamemodify(a:line, ':p')]
	cal s:PrtExit()
	let [bufnr, tail] = [bufnr('^'.filpath.'$'), s:tail()]
	let j2l = a:0 ? a:1 : matchstr(tail, '^ +\zs\d\+$')
	if ( s:jmptobuf =~ md || ( s:jmptobuf && md =~ '[et]' ) ) && bufnr > 0
		\ && !( md == 'e' && bufnr == bufnr('%') )
		let [jmpb, bufwinnr] = [1, bufwinnr(bufnr)]
		let buftab = ( s:jmptobuf =~# '[tTVH]' || s:jmptobuf > 1 )
			\ ? s:buftab(bufnr, md) : [0, 0]
	en
	" Switch to existing buffer or open new one
	if exists('jmpb') && bufwinnr > 0
		\ && !( md == 't' && ( s:jmptobuf !~# toupper(md) || buftab[0] ) )
		exe bufwinnr.'winc w'
		if j2l | cal ctrlp#j2l(j2l) | en
	elsei exists('jmpb') && buftab[0]
		\ && !( md =~ '[evh]' && s:jmptobuf !~# toupper(md) )
		exe 'tabn' buftab[0]
		exe buftab[1].'winc w'
		if j2l | cal ctrlp#j2l(j2l) | en
	el
		" Determine the command to use
		let useb = bufnr > 0 && buflisted(bufnr) && empty(tail)
		let cmd =
			\ md == 't' || s:splitwin == 1 ? ( useb ? 'tab sb' : 'tabe' ) :
			\ md == 'h' || s:splitwin == 2 ? ( useb ? 'sb' : 'new' ) :
			\ md == 'v' || s:splitwin == 3 ? ( useb ? 'vert sb' : 'vne' ) :
			\ call('ctrlp#normcmd', useb ? ['b', 'bo vert sb'] : ['e'])
		" Reset &switchbuf option
		let [swb, &swb] = [&swb, '']
		" Open new window/buffer
		let [fid, tail] = [( useb ? bufnr : filpath ), ( a:0 ? ' +'.a:1 : tail )]
		let args = [cmd, fid, tail, 1, [useb, j2l]]
		cal call('s:openfile', args)
		let &swb = swb
	en
endf

fu! s:SpecInputs(str)
	if a:str =~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*)$' && s:spi
		let cwd = s:dyncwd
		cal ctrlp#setdir(a:str =~ '^\.\.\.*$' ?
			\ '../'.repeat('../', strlen(a:str) - 2) : a:str)
		if cwd != s:dyncwd | cal ctrlp#setlines() | en
		cal s:PrtClear()
		retu 1
	elsei a:str == s:lash && s:spi
		cal s:SetWD({ 'mode': 'rd' })
		cal ctrlp#setlines()
		cal s:PrtClear()
		retu 1
	elsei a:str =~ '^@.\+' && s:spi
		retu s:at(a:str)
	elsei a:str == '?'
		cal s:PrtExit()
		let hlpwin = &columns > 159 ? '| vert res 80' : ''
		sil! exe 'bo vert h ctrlp-mappings' hlpwin '| norm! 0'
		retu 1
	en
	retu 0
endf

fu! s:AcceptSelection(mode)
	if a:mode != 'e' && s:OpenMulti(a:mode) != -1 | retu | en
	let str = s:getinput()
	if a:mode == 'e' | if s:SpecInputs(str) | retu | en | en
	" Get the selected line
	let line = ctrlp#getcline()
	if a:mode != 'e' && !s:itemtype && line == ''
		\ && str !~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*|/|\\|\?|\@.+)$'
		cal s:CreateNewFile(a:mode) | retu
	en
	if empty(line) | retu | en
	" Do something with it
	if s:openfunc != {} && has_key(s:openfunc, s:ctype)
		let actfunc = s:openfunc[s:ctype]
	el
		let actfunc = s:itemtype < 3 ? 'ctrlp#acceptfile' : s:getextvar('accept')
	en
	cal call(actfunc, [a:mode, line])
endf
" - CreateNewFile() {{{1
fu! s:CreateNewFile(...)
	let [md, str] = ['', s:getinput('n')]
	if empty(str) | retu | en
	if s:argmap && !a:0
		" Get the extra argument
		let md = s:argmaps(md, 1)
		if md == 'cancel' | retu | en
	en
	let str = s:sanstail(str)
	let [base, fname] = s:headntail(str)
	if fname =~ '^[\/]$' | retu | en
	if exists('s:marked') && len(s:marked)
		" Use the first marked file's path
		let path = fnamemodify(values(s:marked)[0], ':p:h')
		let base = path.s:lash(path).base
		let str = fnamemodify(base.s:lash.fname, ':.')
	en
	if base != '' | if isdirectory(ctrlp#utils#mkdir(base))
		let optyp = str | en | el | let optyp = fname
	en
	if !exists('optyp') | retu | en
	let [filpath, tail] = [fnamemodify(optyp, ':p'), s:tail()]
	if !stridx(filpath, s:dyncwd) | cal s:insertcache(str) | en
	cal s:PrtExit()
	let cmd = md == 'r' ? ctrlp#normcmd('e') :
		\ s:newfop =~ '1\|t' || ( a:0 && a:1 == 't' ) || md == 't' ? 'tabe' :
		\ s:newfop =~ '2\|h' || ( a:0 && a:1 == 'h' ) || md == 'h' ? 'new' :
		\ s:newfop =~ '3\|v' || ( a:0 && a:1 == 'v' ) || md == 'v' ? 'vne' :
		\ ctrlp#normcmd('e')
	cal s:openfile(cmd, filpath, tail, 1)
endf
" * OpenMulti() {{{1
fu! s:MarkToOpen()
	if s:bufnr <= 0 || s:opmul == '0'
		\ || ( s:itemtype > 2 && s:getextvar('opmul') != 1 )
		retu
	en
	let line = ctrlp#getcline()
	if empty(line) | retu | en
	let filpath = s:ispath ? fnamemodify(line, ':p') : line
	if exists('s:marked') && s:dictindex(s:marked, filpath) > 0
		" Unmark and remove the file from s:marked
		let key = s:dictindex(s:marked, filpath)
		cal remove(s:marked, key)
		if empty(s:marked) | unl s:marked | en
		if has('signs')
			exe 'sign unplace' key 'buffer='.s:bufnr
		en
	el
		" Add to s:marked and place a new sign
		if exists('s:marked')
			let vac = s:vacantdict(s:marked)
			let key = empty(vac) ? len(s:marked) + 1 : vac[0]
			let s:marked = extend(s:marked, { key : filpath })
		el
			let [key, s:marked] = [1, { 1 : filpath }]
		en
		if has('signs')
			exe 'sign place' key 'line='.line('.').' name=ctrlpmark buffer='.s:bufnr
		en
	en
	sil! cal ctrlp#statusline()
endf

fu! s:OpenMulti(...)
	let has_marked = exists('s:marked')
	if ( !has_marked && a:0 ) || s:opmul == '0' || !s:ispath
		\ || ( s:itemtype > 2 && s:getextvar('opmul') != 1 )
		retu -1
	en
	" Get the options
	let [nr, md] = [matchstr(s:opmul, '\d\+'), matchstr(s:opmul, '[thvi]')]
	let [ur, jf] = [s:opmul =~ 'r', s:opmul =~ 'j']
	let md = a:0 ? a:1 : ( md == '' ? 'v' : md )
	let nopt = exists('g:ctrlp_open_multiple_files')
	if !has_marked
		let line = ctrlp#getcline()
		if line == '' | retu | en
		let marked = { 1 : fnamemodify(line, ':p') }
		let [nr, ur, jf, nopt] = ['1', 0, 0, 1]
	en
	if ( s:argmap || !has_marked ) && !a:0
		let md = s:argmaps(md, !has_marked ? 2 : 0)
		if md == 'c'
			cal s:unmarksigns()
			unl! s:marked
			cal s:BuildPrompt(0)
		elsei !has_marked && md =~ '[axd]'
			retu s:OpenNoMarks(md, line)
		en
		if md =~ '\v^c(ancel)?$' | retu | en
		let nr = nr == '0' ? ( nopt ? '' : '1' ) : nr
		let ur = !has_marked && md == 'r' ? 1 : ur
	en
	let mkd = values(has_marked ? s:marked : marked)
	cal s:sanstail(join(s:prompt, ''))
	cal s:PrtExit()
	if nr == '0' || md == 'i'
		retu map(mkd, "s:openfile('bad', v:val, '', 0)")
	en
	let tail = s:tail()
	let [emptytail, bufnr] = [empty(tail), bufnr('^'.mkd[0].'$')]
	let useb = bufnr > 0 && buflisted(bufnr) && emptytail
	" Move to a replaceable window
	let ncmd = ( useb ? ['b', 'bo vert sb'] : ['e', 'bo vne'] )
		\ + ( ur ? [] : ['ignruw'] )
	let fst = call('ctrlp#normcmd', ncmd)
	" Check if the current window has a replaceable buffer
	let repabl = !( md == 't' && !ur ) && empty(bufname('%')) && empty(&l:ft)
	" Commands for the rest of the files
	let [ic, cmds] = [1, { 'v': ['vert sb', 'vne'], 'h': ['sb', 'new'],
		\ 't': ['tab sb', 'tabe'] }]
	let [swb, &swb] = [&swb, '']
	if md == 't' && ctrlp#tabcount() < tabpagenr()
		let s:tabct = ctrlp#tabcount()
	en
	" Open the files
	for va in mkd
		let bufnr = bufnr('^'.va.'$')
		if bufnr < 0 && getftype(va) == '' | con | en
		let useb = bufnr > 0 && buflisted(bufnr) && emptytail
		let snd = md != '' && has_key(cmds, md) ?
			\ ( useb ? cmds[md][0] : cmds[md][1] ) : ( useb ? 'vert sb' : 'vne' )
		let cmd = ic == 1 && ( !( !ur && fst =~ '^[eb]$' ) || repabl ) ? fst : snd
		let conds = [( nr != '' && nr > 1 && nr < ic ) || ( nr == '' && ic > 1 ),
			\ nr != '' && nr < ic]
		if conds[nopt]
			if !buflisted(bufnr) | cal s:openfile('bad', va, '', 0) | en
		el
			cal s:openfile(cmd, useb ? bufnr : va, tail, ic == 1)
			if jf | if ic == 1
				let crpos = [tabpagenr(), winnr()]
			el
				let crpos[0] += tabpagenr() <= crpos[0]
				let crpos[1] += winnr() <= crpos[1]
			en | en
			let ic += 1
		en
	endfo
	if jf && exists('crpos') && ic > 2
		exe ( md == 't' ? 'tabn '.crpos[0] : crpos[1].'winc w' )
	en
	let &swb = swb
	unl! s:tabct
endf

fu! s:OpenNoMarks(md, line)
	if a:md == 'a'
		let [s:marked, key] = [{}, 1]
		for line in s:lines
			let s:marked = extend(s:marked, { key : fnamemodify(line, ':p') })
			let key += 1
		endfo
		cal s:remarksigns()
		cal s:BuildPrompt(0)
	elsei a:md == 'x'
		cal call(s:openfunc[s:ctype], [a:md, a:line], s:openfunc)
	elsei a:md == 'd'
		let dir = fnamemodify(a:line, ':h')
		if isdirectory(dir)
			cal ctrlp#setdir(dir)
			cal ctrlp#switchtype(0)
			cal ctrlp#recordhist()
			cal s:PrtClear()
		en
	en
endf
" ** Helper functions {{{1
" Sorting {{{2
fu! ctrlp#complen(...)
	" By length
	let [len1, len2] = [strlen(a:1), strlen(a:2)]
	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1
endf

fu! s:compmatlen(...)
	" By match length
	let mln1 = s:shortest(s:matchlens(a:1, s:compat))
	let mln2 = s:shortest(s:matchlens(a:2, s:compat))
	retu mln1 == mln2 ? 0 : mln1 > mln2 ? 1 : -1
endf

fu! s:comptime(...)
	" By last modified time
	let [time1, time2] = [getftime(a:1), getftime(a:2)]
	retu time1 == time2 ? 0 : time1 < time2 ? 1 : -1
endf

fu! s:compmreb(...)
	" By last entered time (bufnr)
	let [id1, id2] = [index(s:mrbs, a:1), index(s:mrbs, a:2)]
	retu id1 == id2 ? 0 : id1 > id2 ? 1 : -1
endf

fu! s:compmref(...)
	" By last entered time (MRU)
	let [id1, id2] = [index(g:ctrlp_lines, a:1), index(g:ctrlp_lines, a:2)]
	retu id1 == id2 ? 0 : id1 > id2 ? 1 : -1
endf

fu! s:comparent(...)
	" By same parent dir
	if !stridx(s:crfpath, s:dyncwd)
		let [as1, as2] = [s:dyncwd.s:lash().a:1, s:dyncwd.s:lash().a:2]
		let [loc1, loc2] = [s:getparent(as1), s:getparent(as2)]
		if loc1 == s:crfpath && loc2 != s:crfpath | retu -1 | en
		if loc2 == s:crfpath && loc1 != s:crfpath | retu 1  | en
		retu 0
	en
	retu 0
endf

fu! s:compfnlen(...)
	" By filename length
	let len1 = strlen(split(a:1, s:lash)[-1])
	let len2 = strlen(split(a:2, s:lash)[-1])
	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1
endf

fu! s:matchlens(str, pat, ...)
	if empty(a:pat) || index(['^', '$'], a:pat) >= 0 | retu {} | en
	let st   = a:0 ? a:1 : 0
	let lens = a:0 >= 2 ? a:2 : {}
	let nr   = a:0 >= 3 ? a:3 : 0
	if nr > 20 | retu {} | en
	if match(a:str, a:pat, st) >= 0
		let [mst, mnd] = [matchstr(a:str, a:pat, st), matchend(a:str, a:pat, st)]
		let lens = extend(lens, { nr : [strlen(mst), mst] })
		let lens = s:matchlens(a:str, a:pat, mnd, lens, nr + 1)
	en
	retu lens
endf

fu! s:shortest(lens)
	retu min(map(values(a:lens), 'v:val[0]'))
endf

fu! s:mixedsort(...)
	let [cln, cml] = [ctrlp#complen(a:1, a:2), s:compmatlen(a:1, a:2)]
	if s:ispath
		let ms = []
		if s:height < 21
			let ms += [s:compfnlen(a:1, a:2)]
			if s:itemtype !~ '^[12]$' | let ms += [s:comptime(a:1, a:2)] | en
			if !s:itemtype | let ms += [s:comparent(a:1, a:2)] | en
		en
		if s:itemtype =~ '^[12]$'
			let ms += [s:compmref(a:1, a:2)]
			let cln = cml ? cln : 0
		en
		let ms += [cml, 0, 0, 0]
		let mp = call('s:multipliers', ms[:3])
		retu cln + ms[0] * mp[0] + ms[1] * mp[1] + ms[2] * mp[2] + ms[3] * mp[3]
	en
	retu cln + cml * 2
endf

fu! s:multipliers(...)
	let mp0 = !a:1 ? 0 : 2
	let mp1 = !a:2 ? 0 : 1 + ( !mp0 ? 1 : mp0 )
	let mp2 = !a:3 ? 0 : 1 + ( !( mp0 + mp1 ) ? 1 : ( mp0 + mp1 ) )
	let mp3 = !a:4 ? 0 : 1 + ( !( mp0 + mp1 + mp2 ) ? 1 : ( mp0 + mp1 + mp2 ) )
	retu [mp0, mp1, mp2, mp3]
endf

fu! s:compval(...)
	retu a:1 - a:2
endf
" Statusline {{{2
fu! ctrlp#statusline()
	if !exists('s:statypes')
		let s:statypes = [
			\ ['files', 'fil'],
			\ ['buffers', 'buf'],
			\ ['mru files', 'mru'],
			\ ]
		if !empty(g:ctrlp_ext_vars)
			cal map(copy(g:ctrlp_ext_vars),
				\ 'add(s:statypes, [ v:val["lname"], v:val["sname"] ])')
		en
	en
	let tps = s:statypes
	let max = len(tps) - 1
	let nxt = tps[s:walker(max, s:itemtype,  1)][1]
	let prv = tps[s:walker(max, s:itemtype, -1)][1]
	let s:ctype = tps[s:itemtype][0]
	let focus   = s:focus ? 'prt'  : 'win'
	let byfname = s:byfname ? 'file' : 'path'
	let marked  = s:opmul != '0' ?
		\ exists('s:marked') ? ' <'.s:dismrk().'>' : ' <->' : ''
	if s:status != {}
		let args = [focus, byfname, s:regexp, prv, s:ctype, nxt, marked]
		let &l:stl = call(s:status['main'], args, s:status)
	el
		let item    = '%#CtrlPMode1# '.s:ctype.' %*'
		let focus   = '%#CtrlPMode2# '.focus.' %*'
		let byfname = '%#CtrlPMode1# '.byfname.' %*'
		let regex   = s:regexp  ? '%#CtrlPMode2# regex %*' : ''
		let slider  = ' <'.prv.'>={'.item.'}=<'.nxt.'>'
		let dir     = ' %=%<%#CtrlPMode2# %{getcwd()} %*'
		let &l:stl  = focus.byfname.regex.slider.marked.dir
	en
endf

fu! s:dismrk()
	retu has('signs') ? len(s:marked) :
		\ '%<'.join(values(map(copy(s:marked), 'split(v:val, "[\\/]")[-1]')), ', ')
endf

fu! ctrlp#progress(enum, ...)
	if has('macunix') || has('mac') | sl 1m | en
	let txt = a:0 ? '(press ctrl-c to abort)' : ''
	let &l:stl = s:status != {} ? call(s:status['prog'], [a:enum], s:status)
		\ : '%#CtrlPStats# '.a:enum.' %* '.txt.'%=%<%#CtrlPMode2# %{getcwd()} %*'
	redraws
endf
" *** Paths {{{2
" Line formatting {{{3
fu! s:formatline(str)
	let str = a:str
	if s:itemtype == 1
		let bfnr = bufnr('^'.fnamemodify(str, ':p').'$')
		let idc = ( bfnr == bufnr('#') ? '#' : '' )
			\ . ( getbufvar(bfnr, '&ma') ? '' : '-' )
			\ . ( getbufvar(bfnr, '&ro') ? '=' : '' )
			\ . ( getbufvar(bfnr, '&mod') ? '+' : '' )
		let str .= idc != '' ? ' '.idc : ''
	en
	let cond = s:ispath && ( s:winw - 4 ) < s:strwidth(str)
	retu '> '.( cond ? s:pathshorten(str) : str )
endf

fu! s:pathshorten(str)
	retu matchstr(a:str, '^.\{9}').'...'
		\ .matchstr(a:str, '.\{'.( s:winw - 16 ).'}$')
endf
" Directory completion {{{3
fu! s:dircompl(be, sd)
	if a:sd == '' | retu [] | en
	let [be, sd] = a:be == '' ? [s:dyncwd, a:sd] : [a:be, a:be.s:lash(a:be).a:sd]
	let dirs = ctrlp#rmbasedir(split(globpath(s:fnesc(be, 'g', ','), a:sd.'*/'), "\n"))
	cal filter(dirs, '!match(v:val, escape(sd, ''~$.\''))'
		\ . ' && v:val !~ ''\v(^|[\/])\.{1,2}[\/]$''')
	retu dirs
endf

fu! s:findcommon(items, seed)
	let [items, id, cmn, ic] = [copy(a:items), strlen(a:seed), '', 0]
	cal map(items, 'strpart(v:val, id)')
	for char in split(items[0], '\zs')
		for item in items[1:]
			if item[ic] != char | let brk = 1 | brea | en
		endfo
		if exists('brk') | brea | en
		let cmn .= char
		let ic += 1
	endfo
	retu cmn
endf
" Misc {{{3
fu! s:headntail(str)
	let parts = split(a:str, '[\/]\ze[^\/]\+[\/:]\?$')
	retu len(parts) == 1 ? ['', parts[0]] : len(parts) == 2 ? parts : []
endf

fu! s:lash(...)
	retu ( a:0 ? a:1 : s:dyncwd ) !~ '[\/]$' ? s:lash : ''
endf

fu! s:ispathitem()
	retu s:itemtype < 3 || ( s:itemtype > 2 && s:getextvar('type') == 'path' )
endf

fu! ctrlp#dirnfile(entries)
	let [items, cwd] = [[[], []], s:dyncwd.s:lash()]
	for each in a:entries
		let etype = getftype(each)
		if s:igntype >= 0 && s:usrign(each, etype) | con | en
		if etype == 'dir'
			if s:showhidden | if each !~ '[\/]\.\{1,2}$'
				cal add(items[0], each)
			en | el
				cal add(items[0], each)
			en
		elsei etype == 'link'
			if s:folsym
				let isfile = !isdirectory(each)
				if s:folsym == 2 || !s:samerootsyml(each, isfile, cwd)
					cal add(items[isfile], each)
				en
			en
		elsei etype == 'file'
			cal add(items[1], each)
		en
	endfo
	retu items
endf

fu! s:usrign(item, type)
	retu s:igntype == 1 ? a:item =~ s:usrign
		\ : s:igntype == 4 && has_key(s:usrign, a:type) && s:usrign[a:type] != ''
		\ ? a:item =~ s:usrign[a:type] : 0
endf

fu! s:samerootsyml(each, isfile, cwd)
	let resolve = fnamemodify(resolve(a:each), ':p:h')
	let resolve .= s:lash(resolve)
	retu !( stridx(resolve, a:cwd) && ( stridx(a:cwd, resolve) || a:isfile ) )
endf

fu! ctrlp#rmbasedir(items)
	let cwd = s:dyncwd.( s:dyncwd !~ '[\/]$' ? s:lash : '' )
	if a:items != [] && !stridx(a:items[0], cwd)
		let idx = strlen(cwd)
		retu map(a:items, 'strpart(v:val, idx)')
	en
	retu a:items
endf
" Working directory {{{3
fu! s:getparent(item)
	let parent = substitute(a:item, '[\/][^\/]\+[\/:]\?$', '', '')
	if parent == '' || parent !~ '[\/]'
		let parent .= s:lash
	en
	retu parent
endf

fu! s:findroot(curr, mark, depth, type)
	let [depth, fnd] = [a:depth + 1, 0]
	if type(a:mark) == 1
		let fnd = s:glbpath(s:fnesc(a:curr, 'g', ','), a:mark, 1) != ''
	elsei type(a:mark) == 3
		for markr in a:mark
			if s:glbpath(s:fnesc(a:curr, 'g', ','), markr, 1) != ''
				let fnd = 1
				brea
			en
		endfo
	en
	if fnd
		if !a:type | cal ctrlp#setdir(a:curr) | en
		retu [exists('markr') ? markr : a:mark, a:curr]
	elsei depth > s:maxdepth
		cal ctrlp#setdir(s:cwd)
	el
		let parent = s:getparent(a:curr)
		if parent != a:curr
			retu s:findroot(parent, a:mark, depth, a:type)
		en
	en
	retu []
endf

fu! ctrlp#setdir(path, ...)
	let cmd = a:0 ? a:1 : 'lc!'
	sil! exe cmd s:fnesc(a:path, 'c')
	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
endf
" Fallbacks {{{3
fu! s:glbpath(...)
	retu call('ctrlp#utils#globpath', a:000)
endf

fu! s:fnesc(...)
	retu call('ctrlp#utils#fnesc', a:000)
endf

fu! ctrlp#setlcdir()
	if exists('*haslocaldir')
		cal ctrlp#setdir(getcwd(), haslocaldir() ? 'lc!' : 'cd!')
	en
endf
" Highlighting {{{2
fu! ctrlp#syntax()
	if ctrlp#nosy() | retu | en
	for [ke, va] in items(s:hlgrps) | cal ctrlp#hicheck('CtrlP'.ke, va) | endfo
	if !hlexists('CtrlPLinePre')
		\ && synIDattr(synIDtrans(hlID('Normal')), 'bg') !~ '^-1$\|^$'
		sil! exe 'hi CtrlPLinePre '.( has("gui_running") ? 'gui' : 'cterm' ).'fg=bg'
	en
	sy match CtrlPNoEntries '^ == NO ENTRIES ==$'
	if hlexists('CtrlPLinePre')
		sy match CtrlPLinePre '^>'
	en
endf

fu! s:highlight(pat, grp)
	if s:matcher != {} | retu | en
	cal clearmatches()
	if !empty(a:pat) && s:ispath
		let pat = s:regexp ? substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g') : a:pat
		if s:byfname
			let pat = substitute(pat, '\[\^\(.\{-}\)\]\\{-}', '[^\\/\1]\\{-}', 'g')
			let pat = substitute(pat, '\$\@<!$', '\\ze[^\\/]*$', 'g')
		en
		cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C' ).pat)
		cal matchadd('CtrlPLinePre', '^>')
	en
endf

fu! s:dohighlight()
	retu s:mathi[0] && exists('*clearmatches') && !ctrlp#nosy()
endf
" Prompt history {{{2
fu! s:gethistloc()
	let utilcadir = ctrlp#utils#cachedir()
	let cache_dir = utilcadir.s:lash(utilcadir).'hist'
	retu [cache_dir, cache_dir.s:lash(cache_dir).'cache.txt']
endf

fu! s:gethistdata()
	retu ctrlp#utils#readfile(s:gethistloc()[1])
endf

fu! ctrlp#recordhist()
	let str = join(s:prompt, '')
	if empty(str) || !s:maxhst | retu | en
	let hst = s:hstry
	if len(hst) > 1 && hst[1] == str | retu | en
	cal extend(hst, [str], 1)
	if len(hst) > s:maxhst | cal remove(hst, s:maxhst, -1) | en
	cal ctrlp#utils#writecache(hst, s:gethistloc()[0], s:gethistloc()[1])
endf
" Signs {{{2
fu! s:unmarksigns()
	if !s:dosigns() | retu | en
	for key in keys(s:marked)
		exe 'sign unplace' key 'buffer='.s:bufnr
	endfo
endf

fu! s:remarksigns()
	if !s:dosigns() | retu | en
	for ic in range(1, len(s:lines))
		let line = s:ispath ? fnamemodify(s:lines[ic - 1], ':p') : s:lines[ic - 1]
		let key = s:dictindex(s:marked, line)
		if key > 0
			exe 'sign place' key 'line='.ic.' name=ctrlpmark buffer='.s:bufnr
		en
	endfo
endf

fu! s:dosigns()
	retu exists('s:marked') && s:bufnr > 0 && s:opmul != '0' && has('signs')
endf
" Lists & Dictionaries {{{2
fu! s:dictindex(dict, expr)
	for key in keys(a:dict)
		if a:dict[key] == a:expr | retu key | en
	endfo
	retu -1
endf

fu! s:vacantdict(dict)
	retu filter(range(1, max(keys(a:dict))), '!has_key(a:dict, v:val)')
endf

fu! s:sublist(l, s, e)
	retu v:version > 701 ? a:l[(a:s):(a:e)] : s:sublist7071(a:l, a:s, a:e)
endf

fu! s:sublist7071(l, s, e)
	let [newlist, id, ae] = [[], a:s, a:e == -1 ? len(a:l) - 1 : a:e]
	wh id <= ae
		cal add(newlist, get(a:l, id))
		let id += 1
	endw
	retu newlist
endf
" Buffers {{{2
fu! s:buftab(bufnr, md)
	for tabnr in range(1, tabpagenr('$'))
		if tabpagenr() == tabnr && a:md == 't' | con | en
		let buflist = tabpagebuflist(tabnr)
		if index(buflist, a:bufnr) >= 0
			for winnr in range(1, tabpagewinnr(tabnr, '$'))
				if buflist[winnr - 1] == a:bufnr | retu [tabnr, winnr] | en
			endfo
		en
	endfo
	retu [0, 0]
endf

fu! s:bufwins(bufnr)
	let winns = 0
	for tabnr in range(1, tabpagenr('$'))
		let winns += count(tabpagebuflist(tabnr), a:bufnr)
	endfo
	retu winns
endf

fu! ctrlp#normcmd(cmd, ...)
	if a:0 < 2 && s:nosplit() | retu a:cmd | en
	let norwins = filter(range(1, winnr('$')),
		\ 'empty(getbufvar(winbufnr(v:val), "&bt"))')
	for each in norwins
		let bufnr = winbufnr(each)
		if empty(bufname(bufnr)) && empty(getbufvar(bufnr, '&ft'))
			let fstemp = each | brea
		en
	endfo
	let norwin = empty(norwins) ? 0 : norwins[0]
	if norwin
		if index(norwins, winnr()) < 0
			exe ( exists('fstemp') ? fstemp : norwin ).'winc w'
		en
		retu a:cmd
	en
	retu a:0 ? a:1 : 'bo vne'
endf

fu! ctrlp#modfilecond(w)
	retu &mod && !&hid && &bh != 'hide' && s:bufwins(bufnr('%')) == 1 && !&cf &&
		\ ( ( !&awa && a:w ) || filewritable(fnamemodify(bufname('%'), ':p')) != 1 )
endf

fu! s:nosplit()
	retu !empty(s:nosplit) && match([bufname('%'), &l:ft, &l:bt], s:nosplit) >= 0
endf

fu! s:setupblank()
	setl noswf nonu nobl nowrap nolist nospell nocuc wfh
	setl fdc=0 fdl=99 tw=0 bt=nofile bh=unload
	if v:version > 702
		setl nornu noudf cc=0
	en
endf

fu! s:leavepre()
	if exists('s:bufnr') && s:bufnr == bufnr('%') | bw! | en
	if !( exists(s:ccex) && !{s:ccex} )
		\ && !( has('clientserver') && len(split(serverlist(), "\n")) > 1 )
		cal ctrlp#clra()
	en
endf

fu! s:checkbuf()
	if !exists('s:init') && exists('s:bufnr') && s:bufnr > 0
		exe s:bufnr.'bw!'
	en
endf

fu! s:iscmdwin()
	let ermsg = v:errmsg
	sil! noa winc p
	sil! noa winc p
	let [v:errmsg, ermsg] = [ermsg, v:errmsg]
	retu ermsg =~ '^E11:'
endf
" Arguments {{{2
fu! s:at(str)
	if a:str =~ '\v^\@(cd|lc[hd]?|chd).*'
		let str = substitute(a:str, '\v^\@(cd|lc[hd]?|chd)\s*', '', '')
		if str == '' | retu 1 | en
		let str = str =~ '^%:.\+' ? fnamemodify(s:crfile, str[1:]) : str
		let path = fnamemodify(expand(str, 1), ':p')
		if isdirectory(path)
			if path != s:dyncwd
				cal ctrlp#setdir(path)
				cal ctrlp#setlines()
			en
			cal ctrlp#recordhist()
			cal s:PrtClear()
		en
		retu 1
	en
	retu 0
endf

fu! s:tail()
	if exists('s:optail') && !empty('s:optail')
		let tailpref = s:optail !~ '^\s*+' ? ' +' : ' '
		retu tailpref.s:optail
	en
	retu ''
endf

fu! s:sanstail(str)
	let str = s:spi ?
		\ substitute(a:str, '^\(@.*$\|\\\\\ze@\|\.\.\zs[.\/]\+$\)', '', 'g') : a:str
	let [str, pat] = [substitute(str, '\\\\', '\', 'g'), '\([^:]\|\\:\)*$']
	unl! s:optail
	if str =~ '\\\@<!:'.pat
		let s:optail = matchstr(str, '\\\@<!:\zs'.pat)
		let str = substitute(str, '\\\@<!:'.pat, '', '')
	en
	retu substitute(str, '\\\ze:', '', 'g')
endf

fu! s:argmaps(md, i)
	let roh = [
		\ ['Open Multiple Files', '/h[i]dden/[c]lear', ['i', 'c']],
		\ ['Create a New File', '/[r]eplace', ['r']],
		\ ['Open Selected', '/[r]eplace', ['r', 'd', 'a']],
		\ ]
	if a:i == 2
		if !buflisted(bufnr('^'.fnamemodify(ctrlp#getcline(), ':p').'$'))
			let roh[2][1] .= '/h[i]dden'
			let roh[2][2] += ['i']
		en
		if s:openfunc != {} && has_key(s:openfunc, s:ctype)
			let roh[2][1] .= '/e[x]ternal'
			let roh[2][2] += ['x']
		en
	en
	let str = roh[a:i][0].': [t]ab/[v]ertical/[h]orizontal'.roh[a:i][1].'? '
	retu s:choices(str, ['t', 'v', 'h'] + roh[a:i][2], 's:argmaps', [a:md, a:i])
endf

fu! s:insertstr()
	let str = 'Insert: c[w]ord/c[f]ile/[s]earch/[v]isual/[c]lipboard/[r]egister? '
	retu s:choices(str, ['w', 'f', 's', 'v', 'c', 'r'], 's:insertstr', [])
endf

fu! s:textdialog(str)
	redr | echoh MoreMsg | echon a:str | echoh None
	retu nr2char(getchar())
endf

fu! s:choices(str, choices, func, args)
	let char = s:textdialog(a:str)
	if index(a:choices, char) >= 0
		retu char
	elsei char =~# "\\v\<Esc>|\<C-c>|\<C-g>|\<C-u>|\<C-w>|\<C-[>"
		cal s:BuildPrompt(0)
		retu 'cancel'
	elsei char =~# "\<CR>" && a:args != []
		retu a:args[0]
	en
	retu call(a:func, a:args)
endf

fu! s:getregs()
	let char = s:textdialog('Insert from register: ')
	if char =~# "\\v\<Esc>|\<C-c>|\<C-g>|\<C-u>|\<C-w>|\<C-[>"
		cal s:BuildPrompt(0)
		retu -1
	elsei char =~# "\<CR>"
		retu s:getregs()
	en
	retu s:regisfilter(char)
endf

fu! s:regisfilter(reg)
	retu substitute(getreg(a:reg), "[\t\n]", ' ', 'g')
endf
" Misc {{{2
fu! s:modevar()
	let s:matchtype = s:mtype()
	let s:ispath = s:ispathitem()
	if !s:ispath | let s:byfname = 0 | en
	let s:mfunc = s:mfunc()
	let s:nolim = s:getextvar('nolim')
	let s:dosort = s:getextvar('sort')
	let s:spi = !s:itemtype || s:getextvar('specinput') > 0
endf

fu! s:nosort()
	retu s:matcher != {} || s:nolim == 1 || ( s:itemtype == 2 && s:mrudef )
		\ || ( s:itemtype =~ '\v^(1|2)$' && s:prompt == ['', '', ''] ) || !s:dosort
endf

fu! s:narrowable()
	retu exists('s:act_add') && exists('s:matched') && s:matched != []
		\ && exists('s:mdata') && s:mdata[:2] == [s:dyncwd, s:itemtype, s:regexp]
		\ && s:matcher == {} && !exists('s:did_exp')
endf

fu! s:getinput(...)
	let [prt, spi] = [s:prompt, ( a:0 ? a:1 : '' )]
	if s:abbrev != {}
		let gmd = has_key(s:abbrev, 'gmode') ? s:abbrev['gmode'] : ''
		let str = ( gmd =~ 't' && !a:0 ) || spi == 'c' ? prt[0] : join(prt, '')
		if gmd =~ 't' && gmd =~ 'k' && !a:0 && matchstr(str, '.$') =~ '\k'
			retu join(prt, '')
		en
		let [pf, rz] = [( s:byfname ? 'f' : 'p' ), ( s:regexp ? 'r' : 'z' )]
		for dict in s:abbrev['abbrevs']
			let dmd = has_key(dict, 'mode') ? dict['mode'] : ''
			let pat = escape(dict['pattern'], '~')
			if ( dmd == '' || ( dmd =~ pf && dmd =~ rz && !a:0 )
				\ || dmd =~ '['.spi.']' ) && str =~ pat
				let [str, s:did_exp] = [join(split(str, pat, 1), dict['expanded']), 1]
			en
		endfo
		if gmd =~ 't' && !a:0
			let prt[0] = str
		el
			retu str
		en
	en
	retu spi == 'c' ? prt[0] : join(prt, '')
endf

fu! s:migemo(str)
	let [str, rtp] = [a:str, s:fnesc(&rtp, 'g')]
	let dict = s:glbpath(rtp, printf("dict/%s/migemo-dict", &enc), 1)
	if !len(dict)
		let dict = s:glbpath(rtp, "dict/migemo-dict", 1)
	en
	if len(dict)
		let [tokens, str, cmd] = [split(str, '\s'), '', 'cmigemo -v -w %s -d %s']
		for token in tokens
			let rtn = system(printf(cmd, shellescape(token), shellescape(dict)))
			let str .= !v:shell_error && strlen(rtn) > 0 ? '.*'.rtn : token
		endfo
	en
	retu str
endf

fu! s:strwidth(str)
	retu exists('*strdisplaywidth') ? strdisplaywidth(a:str) : strlen(a:str)
endf

fu! ctrlp#j2l(nr)
	exe 'norm!' a:nr.'G'
	sil! norm! zvzz
endf

fu! s:maxf(len)
	retu s:maxfiles && a:len > s:maxfiles
endf

fu! s:regexfilter(str)
	let str = a:str
	for key in keys(s:fpats) | if str =~ key
		let str = substitute(str, s:fpats[key], '', 'g')
	en | endfo
	retu str
endf

fu! s:walker(m, p, d)
	retu a:d >= 0 ? a:p < a:m ? a:p + a:d : 0 : a:p > 0 ? a:p + a:d : a:m
endf

fu! s:delent(rfunc)
	if a:rfunc == '' | retu | en
	let [s:force, tbrem] = [1, []]
	if exists('s:marked')
		let tbrem = values(s:marked)
		cal s:unmarksigns()
		unl s:marked
	en
	if tbrem == [] && ( has('dialog_gui') || has('dialog_con') ) &&
		\ confirm("Wipe all entries?", "&OK\n&Cancel") != 1
		unl s:force
		cal s:BuildPrompt(0)
		retu
	en
	let g:ctrlp_lines = call(a:rfunc, [tbrem])
	cal s:BuildPrompt(1)
	unl s:force
endf
" Entering & Exiting {{{2
fu! s:getenv()
	let [s:cwd, s:winres] = [getcwd(), [winrestcmd(), &lines, winnr('$')]]
	let [s:crfile, s:crfpath] = [expand('%:p', 1), expand('%:p:h', 1)]
	let [s:crword, s:crline] = [expand('<cword>', 1), getline('.')]
	let [s:winh, s:crcursor] = [min([s:mxheight, &lines]), getpos('.')]
	let [s:crbufnr, s:crvisual] = [bufnr('%'), s:lastvisual()]
	let [s:mrbs, s:crgfile] = [ctrlp#mrufiles#bufs(), expand('<cfile>', 1)]
endf

fu! s:lastvisual()
	let cview = winsaveview()
	let [ovreg, ovtype] = [getreg('v'), getregtype('v')]
	let [oureg, outype] = [getreg('"'), getregtype('"')]
	sil! norm! gv"vy
	let selected = s:regisfilter('v')
	cal setreg('v', ovreg, ovtype)
	cal setreg('"', oureg, outype)
	cal winrestview(cview)
	retu selected
endf

fu! s:log(m)
	if exists('g:ctrlp_log') && g:ctrlp_log | if a:m
		let cadir = ctrlp#utils#cachedir()
		sil! exe 'redi! >' cadir.s:lash(cadir).'ctrlp.log'
	el
		sil! redi END
	en | en
endf

fu! s:buffunc(e)
	if a:e && has_key(s:buffunc, 'enter')
		cal call(s:buffunc['enter'], [], s:buffunc)
	elsei !a:e && has_key(s:buffunc, 'exit')
		cal call(s:buffunc['exit'], [], s:buffunc)
	en
endf

fu! s:openfile(cmd, fid, tail, chkmod, ...)
	let cmd = a:cmd
	if a:chkmod && cmd =~ '^[eb]$' && ctrlp#modfilecond(!( cmd == 'b' && &aw ))
		let cmd = cmd == 'b' ? 'sb' : 'sp'
	en
	let cmd = cmd =~ '^tab' ? ctrlp#tabcount().cmd : cmd
	let j2l = a:0 && a:1[0] ? a:1[1] : 0
	exe cmd.( a:0 && a:1[0] ? '' : a:tail ) s:fnesc(a:fid, 'f')
	if j2l
		cal ctrlp#j2l(j2l)
	en
	if !empty(a:tail)
		sil! norm! zvzz
	en
	if cmd != 'bad'
		cal ctrlp#setlcdir()
	en
endf

fu! ctrlp#tabcount()
	if exists('s:tabct')
		let tabct = s:tabct
		let s:tabct += 1
	elsei !type(s:tabpage)
		let tabct = s:tabpage
	elsei type(s:tabpage) == 1
		let tabpos =
			\ s:tabpage =~ 'c' ? tabpagenr() :
			\ s:tabpage =~ 'f' ? 1 :
			\ s:tabpage =~ 'l' ? tabpagenr('$') :
			\ tabpagenr()
		let tabct =
			\ s:tabpage =~ 'a' ? tabpos :
			\ s:tabpage =~ 'b' ? tabpos - 1 :
			\ tabpos
	en
	retu tabct < 0 ? 0 : tabct
endf

fu! s:settype(type)
	retu a:type < 0 ? exists('s:itemtype') ? s:itemtype : 0 : a:type
endf
" Matching {{{2
fu! s:matchfname(item, pat)
	let parts = split(a:item, '[\/]\ze[^\/]\+$')
	let mfn = match(parts[-1], a:pat[0])
	retu len(a:pat) == 1 ? mfn : len(a:pat) == 2 ?
		\ ( mfn >= 0 && ( len(parts) == 2 ? match(parts[0], a:pat[1]) : -1 ) >= 0
		\ ? 0 : -1 ) : -1
	en
endf

fu! s:matchtabs(item, pat)
	retu match(split(a:item, '\t\+')[0], a:pat)
endf

fu! s:matchtabe(item, pat)
	retu match(split(a:item, '\t\+[^\t]\+$')[0], a:pat)
endf

fu! s:buildpat(lst)
	let pat = a:lst[0]
	for item in range(1, len(a:lst) - 1)
		let pat .= '[^'.a:lst[item - 1].']\{-}'.a:lst[item]
	endfo
	retu pat
endf

fu! s:mfunc()
	let mfunc = 'match'
	if s:byfname && s:ispath
		let mfunc = 's:matchfname'
	elsei s:itemtype > 2
		let matchtypes = { 'tabs': 's:matchtabs', 'tabe': 's:matchtabe' }
		if has_key(matchtypes, s:matchtype)
			let mfunc = matchtypes[s:matchtype]
		en
	en
	retu mfunc
endf

fu! s:mmode()
	let matchmodes = {
		\ 'match': 'full-line',
		\ 's:matchfname': 'filename-only',
		\ 's:matchtabs': 'first-non-tab',
		\ 's:matchtabe': 'until-last-tab',
		\ }
	retu matchmodes[s:mfunc]
endf
" Cache {{{2
fu! s:writecache(cafile)
	if ( g:ctrlp_newcache || !filereadable(a:cafile) ) && !s:nocache()
		cal ctrlp#utils#writecache(g:ctrlp_allfiles)
		let g:ctrlp_newcache = 0
	en
endf

fu! s:nocache(...)
	if !s:caching
		retu 1
	elsei s:caching > 1
		if !( exists(s:ccex) && !{s:ccex} ) || has_key(s:ficounts, s:dyncwd)
			retu get(s:ficounts, s:dyncwd, [0, 0])[0] < s:caching
		elsei a:0 && filereadable(a:1)
			retu len(ctrlp#utils#readfile(a:1)) < s:caching
		en
		retu 1
	en
	retu 0
endf

fu! s:insertcache(str)
	let [data, g:ctrlp_newcache, str] = [g:ctrlp_allfiles, 1, a:str]
	if data == [] || strlen(str) <= strlen(data[0])
		let pos = 0
	elsei strlen(str) >= strlen(data[-1])
		let pos = len(data) - 1
	el
		let pos = 0
		for each in data
			if strlen(each) > strlen(str) | brea | en
			let pos += 1
		endfo
	en
	cal insert(data, str, pos)
	cal s:writecache(ctrlp#utils#cachefile())
endf
" Extensions {{{2
fu! s:mtype()
	retu s:itemtype > 2 ? s:getextvar('type') : 'path'
endf

fu! s:execextvar(key)
	if !empty(g:ctrlp_ext_vars)
		cal map(filter(copy(g:ctrlp_ext_vars),
			\ 'has_key(v:val, a:key)'), 'eval(v:val[a:key])')
	en
endf

fu! s:getextvar(key)
	if s:itemtype > 2
		let vars = g:ctrlp_ext_vars[s:itemtype - 3]
		retu has_key(vars, a:key) ? vars[a:key] : -1
	en
	retu -1
endf

fu! ctrlp#getcline()
	retu !empty(s:lines) ? s:lines[line('.') - 1] : ''
endf

fu! ctrlp#getmarkedlist()
	retu exists('s:marked') ? values(s:marked) : []
endf

fu! ctrlp#exit()
	cal s:PrtExit()
endf

fu! ctrlp#prtclear()
	cal s:PrtClear()
endf

fu! ctrlp#switchtype(id)
	cal s:ToggleType(a:id - s:itemtype)
endf

fu! ctrlp#nosy()
	retu !( has('syntax') && exists('g:syntax_on') )
endf

fu! ctrlp#hicheck(grp, defgrp)
	if !hlexists(a:grp)
		exe 'hi link' a:grp a:defgrp
	en
endf

fu! ctrlp#call(func, ...)
	retu call(a:func, a:000)
endf
"}}}1
" * Initialization {{{1
fu! ctrlp#setlines(...)
	if a:0 | let s:itemtype = a:1 | en
	cal s:modevar()
	let types = ['ctrlp#files()', 'ctrlp#buffers()', 'ctrlp#mrufiles#list()']
	if !empty(g:ctrlp_ext_vars)
		cal map(copy(g:ctrlp_ext_vars), 'add(types, v:val["init"])')
	en
	let g:ctrlp_lines = eval(types[s:itemtype])
endf

fu! ctrlp#init(type, ...)
	if exists('s:init') || s:iscmdwin() | retu | en
	let [s:ermsg, v:errmsg] = [v:errmsg, '']
	let [s:matches, s:init] = [1, 1]
	cal s:Reset(a:0 ? a:1 : {})
	noa cal s:Open()
	cal s:SetWD(a:0 ? a:1 : {})
	cal s:MapNorms()
	cal s:MapSpecs()
	cal ctrlp#syntax()
	cal ctrlp#setlines(s:settype(a:type))
	cal s:SetDefTxt()
	cal s:BuildPrompt(1)
	if s:keyloop | cal s:KeyLoop() | en
endf
" - Autocmds {{{1
if has('autocmd')
	aug CtrlPAug
		au!
		au BufEnter ControlP cal s:checkbuf()
		au BufLeave ControlP noa cal s:Close()
		au VimLeavePre * cal s:leavepre()
	aug END
en

fu! s:autocmds()
	if !has('autocmd') | retu | en
	if exists('#CtrlPLazy')
		au! CtrlPLazy
	en
	if s:lazy
		aug CtrlPLazy
			au!
			au CursorHold ControlP cal s:ForceUpdate()
		aug END
	en
endf
"}}}

" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
" =============================================================================
" File:          autoload/ctrlp/utils.vim
" Description:   Utilities
" Author:        Kien Nguyen <github.com/kien>
" =============================================================================

" Static variables {{{1
fu! ctrlp#utils#lash()
	retu &ssl || !exists('+ssl') ? '/' : '\'
endf

fu! s:lash(...)
	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''
endf

fu! ctrlp#utils#opts()
	let s:lash = ctrlp#utils#lash()
	let usrhome = $HOME . s:lash( $HOME )
	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
	let cadir = isdirectory(usrhome.'.ctrlp_cache')
		\ ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
	if exists('g:ctrlp_cache_dir')
		let cadir = expand(g:ctrlp_cache_dir, 1)
		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
		en
	en
	let s:cache_dir = cadir
endf
cal ctrlp#utils#opts()

let s:wig_cond = v:version > 702 || ( v:version == 702 && has('patch051') )
" Files and Directories {{{1
fu! ctrlp#utils#cachedir()
	retu s:cache_dir
endf

fu! ctrlp#utils#cachefile(...)
	let [tail, dir] = [a:0 == 1 ? '.'.a:1 : '', a:0 == 2 ? a:1 : getcwd()]
	let cache_file = substitute(dir, '\([\/]\|^\a\zs:\)', '%', 'g').tail.'.txt'
	retu a:0 == 1 ? cache_file : s:cache_dir.s:lash(s:cache_dir).cache_file
endf

fu! ctrlp#utils#readfile(file)
	if filereadable(a:file)
		let data = readfile(a:file)
		if empty(data) || type(data) != 3
			unl data
			let data = []
		en
		retu data
	en
	retu []
endf

fu! ctrlp#utils#mkdir(dir)
	if exists('*mkdir') && !isdirectory(a:dir)
		sil! cal mkdir(a:dir, 'p')
	en
	retu a:dir
endf

fu! ctrlp#utils#writecache(lines, ...)
	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
	en
endf

fu! ctrlp#utils#glob(...)
	let path = ctrlp#utils#fnesc(a:1, 'g')
	retu s:wig_cond ? glob(path, a:2) : glob(path)
endf

fu! ctrlp#utils#globpath(...)
	retu call('globpath', s:wig_cond ? a:000 : a:000[:1])
endf

fu! ctrlp#utils#fnesc(path, type, ...)
	if exists('*fnameescape')
		if exists('+ssl')
			if a:type == 'c'
				let path = escape(a:path, '%#')
			elsei a:type == 'f'
				let path = fnameescape(a:path)
			elsei a:type == 'g'
				let path = escape(a:path, '?*')
			en
			let path = substitute(path, '[', '[[]', 'g')
		el
			let path = fnameescape(a:path)
		en
	el
		if exists('+ssl')
			if a:type == 'c'
				let path = escape(a:path, '%#')
			elsei a:type == 'f'
				let path = escape(a:path, " \t\n%#*?|<\"")
			elsei a:type == 'g'
				let path = escape(a:path, '?*')
			en
			let path = substitute(path, '[', '[[]', 'g')
		el
			let path = escape(a:path, " \t\n*?[{`$\\%#'\"|!<")
		en
	en
	retu a:0 ? escape(path, a:1) : path
endf

fu! ctrlp#utils#dircompl(...)
	let [hsl, str] = [match(a:1, '[\/]'), '']
	let par = substitute(a:1, '[^\/]*$', '', '')
	let path = !hsl ? par : hsl > 0 ? getcwd().s:lash().par : getcwd()
	for dir in split(globpath(ctrlp#utils#fnesc(path, 'g', ','), '*/'), '\n')
		let str .= par.split(dir, '[\/]')[-1]."\n"
	endfo
	retu str
endf
"}}}

" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
" =============================================================================
" File:          autoload/ctrlp/bookmarkdir.vim
" Description:   Bookmarked directories extension
" Author:        Kien Nguyen <github.com/kien>
" =============================================================================

" Init {{{1
if exists('g:loaded_ctrlp_bookmarkdir') && g:loaded_ctrlp_bookmarkdir
	fini
en
let g:loaded_ctrlp_bookmarkdir = 1

cal add(g:ctrlp_ext_vars, {
	\ 'init': 'ctrlp#bookmarkdir#init()',
	\ 'accept': 'ctrlp#bookmarkdir#accept',
	\ 'lname': 'bookmarked dirs',
	\ 'sname': 'bkd',
	\ 'type': 'tabs',
	\ 'opmul': 1,
	\ 'nolim': 1,
	\ 'wipe': 'ctrlp#bookmarkdir#remove',
	\ })

let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
" Utilities {{{1
fu! s:getinput(str, ...)
	echoh Identifier
	cal inputsave()
	let input = call('input', a:0 ? [a:str] + a:000 : [a:str])
	cal inputrestore()
	echoh None
	retu input
endf

fu! s:cachefile()
	if !exists('s:cadir') || !exists('s:cafile')
		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'bkd'
		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
	en
	retu s:cafile
endf

fu! s:writecache(lines)
	cal ctrlp#utils#writecache(a:lines, s:cadir, s:cafile)
endf

fu! s:getbookmarks()
	retu ctrlp#utils#readfile(s:cachefile())
endf

fu! s:savebookmark(name, cwd)
	let cwds = exists('+ssl') ? [tr(a:cwd, '\', '/'), tr(a:cwd, '/', '\')] : [a:cwd]
	let entries = filter(s:getbookmarks(), 'index(cwds, s:parts(v:val)[1]) < 0')
	cal s:writecache(insert(entries, a:name.'	'.a:cwd))
endf

fu! s:setentries()
	let time = getftime(s:cachefile())
	if !( exists('s:bookmarks') && time == s:bookmarks[0] )
		let s:bookmarks = [time, s:getbookmarks()]
	en
endf

fu! s:parts(str)
	let mlist = matchlist(a:str, '\v([^\t]+)\t(.*)$')
	retu mlist != [] ? mlist[1:2] : ['', '']
endf

fu! s:process(entries, type)
	retu map(a:entries, 's:modify(v:val, a:type)')
endf

fu! s:modify(entry, type)
	let [name, dir] = s:parts(a:entry)
	let dir = fnamemodify(dir, a:type)
	retu name.'	'.( dir == '' ? '.' : dir )
endf

fu! s:msg(name, cwd)
	redr
	echoh Identifier | echon 'Bookmarked ' | echoh Constant
	echon a:name.' ' | echoh Directory | echon a:cwd
	echoh None
endf

fu! s:syntax()
	if !ctrlp#nosy()
		cal ctrlp#hicheck('CtrlPBookmark', 'Identifier')
		cal ctrlp#hicheck('CtrlPTabExtra', 'Comment')
		sy match CtrlPBookmark '^> [^\t]\+' contains=CtrlPLinePre
		sy match CtrlPTabExtra '\zs\t.*\ze$'
	en
endf
" Public {{{1
fu! ctrlp#bookmarkdir#init()
	cal s:setentries()
	cal s:syntax()
	retu s:process(copy(s:bookmarks[1]), ':.')
endf

fu! ctrlp#bookmarkdir#accept(mode, str)
	let parts = s:parts(s:modify(a:str, ':p'))
	cal call('s:savebookmark', parts)
	if a:mode =~ 't\|v\|h'
		cal ctrlp#exit()
	en
	cal ctrlp#setdir(parts[1], a:mode =~ 't\|h' ? 'chd!' : 'lc!')
	if a:mode == 'e'
		cal ctrlp#switchtype(0)
		cal ctrlp#recordhist()
		cal ctrlp#prtclear()
	en
endf

fu! ctrlp#bookmarkdir#add(dir)
	let str = 'Directory to bookmark: '
	let cwd = a:dir != '' ? a:dir : s:getinput(str, getcwd(), 'dir')
	if cwd == '' | retu | en
	let cwd = fnamemodify(cwd, ':p')
	let name = s:getinput('Bookmark as: ', cwd)
	if name == '' | retu | en
	let name = tr(name, '	', ' ')
	cal s:savebookmark(name, cwd)
	cal s:msg(name, cwd)
endf

fu! ctrlp#bookmarkdir#remove(entries)
	cal s:process(a:entries, ':p')
	cal s:writecache(a:entries == [] ? [] :
		\ filter(s:getbookmarks(), 'index(a:entries, v:val) < 0'))
	cal s:setentries()
	retu s:process(copy(s:bookmarks[1]), ':.')
endf

fu! ctrlp#bookmarkdir#id()
	retu s:id
endf
"}}}

" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
" =============================================================================
" File:          autoload/ctrlp/rtscript.vim
" Description:   Runtime scripts extension
" Author:        Kien Nguyen <github.com/kien>
" =============================================================================

" Init {{{1
if exists('g:loaded_ctrlp_rtscript') && g:loaded_ctrlp_rtscript
	fini
en
let [g:loaded_ctrlp_rtscript, g:ctrlp_newrts] = [1, 0]

cal add(g:ctrlp_ext_vars, {
	\ 'init': 'ctrlp#rtscript#init(s:caching)',
	\ 'accept': 'ctrlp#acceptfile',
	\ 'lname': 'runtime scripts',
	\ 'sname': 'rts',
	\ 'type': 'path',
	\ 'opmul': 1,
	\ })

let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)

let s:filecounts = {}
" Utilities {{{1
fu! s:nocache()
	retu g:ctrlp_newrts ||
		\ !s:caching || ( s:caching > 1 && get(s:filecounts, s:cwd) < s:caching )
endf
" Public {{{1
fu! ctrlp#rtscript#init(caching)
	let [s:caching, s:cwd] = [a:caching, getcwd()]
	if s:nocache() ||
		\ !( exists('g:ctrlp_rtscache') && g:ctrlp_rtscache[0] == &rtp )
		sil! cal ctrlp#progress('Indexing...')
		let entries = split(globpath(ctrlp#utils#fnesc(&rtp, 'g'), '**/*.*'), "\n")
		cal filter(entries, 'count(entries, v:val) == 1')
		let [entries, echoed] = [ctrlp#dirnfile(entries)[1], 1]
	el
		let [entries, results] = g:ctrlp_rtscache[2:3]
	en
	if s:nocache() ||
		\ !( exists('g:ctrlp_rtscache') && g:ctrlp_rtscache[:1] == [&rtp, s:cwd] )
		if !exists('echoed')
			sil! cal ctrlp#progress('Processing...')
		en
		let results = map(copy(entries), 'fnamemodify(v:val, '':.'')')
	en
	let [g:ctrlp_rtscache, g:ctrlp_newrts] = [[&rtp, s:cwd, entries, results], 0]
	cal extend(s:filecounts, { s:cwd : len(results) })
	retu results
endf

fu! ctrlp#rtscript#id()
	retu s:id
endf
"}}}

" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
" =============================================================================
" File:          autoload/ctrlp/undo.vim
" Description:   Undo extension
" Author:        Kien Nguyen <github.com/kien>
" =============================================================================

" Init {{{1
if ( exists('g:loaded_ctrlp_undo') && g:loaded_ctrlp_undo )
	fini
en
let g:loaded_ctrlp_undo = 1

cal add(g:ctrlp_ext_vars, {
	\ 'init': 'ctrlp#undo#init()',
	\ 'accept': 'ctrlp#undo#accept',
	\ 'lname': 'undo',
	\ 'sname': 'udo',
	\ 'enter': 'ctrlp#undo#enter()',
	\ 'exit': 'ctrlp#undo#exit()',
	\ 'type': 'line',
	\ 'sort': 0,
	\ 'nolim': 1,
	\ })

let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)

let s:text = map(['second', 'seconds', 'minutes', 'hours', 'days', 'weeks',
	\ 'months', 'years'], '" ".v:val." ago"')
" Utilities {{{1
fu! s:getundo()
	if exists('*undotree')
		\ && ( v:version > 703 || ( v:version == 703 && has('patch005') ) )
		retu [1, undotree()]
	el
		redi => result
		sil! undol
		redi END
		retu [0, split(result, "\n")[1:]]
	en
endf

fu! s:flatten(tree, cur)
	let flatdict = {}
	for each in a:tree
		let saved = has_key(each, 'save') ? 'saved' : ''
		let current = each['seq'] == a:cur ? 'current' : ''
		cal extend(flatdict, { each['seq'] : [each['time'], saved, current] })
		if has_key(each, 'alt')
			cal extend(flatdict, s:flatten(each['alt'], a:cur))
		en
	endfo
	retu flatdict
endf

fu! s:elapsed(nr)
	let [text, time] = [s:text, localtime() - a:nr]
	let mins = time / 60
	let hrs  = time / 3600
	let days = time / 86400
	let wks  = time / 604800
	let mons = time / 2592000
	let yrs  = time / 31536000
	if yrs > 1
		retu yrs.text[7]
	elsei mons > 1
		retu mons.text[6]
	elsei wks > 1
		retu wks.text[5]
	elsei days > 1
		retu days.text[4]
	elsei hrs > 1
		retu hrs.text[3]
	elsei mins > 1
		retu mins.text[2]
	elsei time == 1
		retu time.text[0]
	elsei time < 120
		retu time.text[1]
	en
endf

fu! s:syntax()
	if ctrlp#nosy() | retu | en
	for [ke, va] in items({'T': 'Directory', 'Br': 'Comment', 'Nr': 'String',
		\ 'Sv': 'Comment', 'Po': 'Title'})
		cal ctrlp#hicheck('CtrlPUndo'.ke, va)
	endfo
	sy match CtrlPUndoT '\v\d+ \zs[^ ]+\ze|\d+:\d+:\d+'
	sy match CtrlPUndoBr '\[\|\]'
	sy match CtrlPUndoNr '\[\d\+\]' contains=CtrlPUndoBr
	sy match CtrlPUndoSv 'saved'
	sy match CtrlPUndoPo 'current'
endf

fu! s:dict2list(dict)
	for ke in keys(a:dict)
		let a:dict[ke][0] = s:elapsed(a:dict[ke][0])
	endfo
	retu map(keys(a:dict), 'eval(''[v:val, a:dict[v:val]]'')')
endf

fu! s:compval(...)
	retu a:2[0] - a:1[0]
endf

fu! s:format(...)
	let saved = !empty(a:1[1][1]) ? ' '.a:1[1][1] : ''
	let current = !empty(a:1[1][2]) ? ' '.a:1[1][2] : ''
	retu a:1[1][0].' ['.a:1[0].']'.saved.current
endf

fu! s:formatul(...)
	let parts = matchlist(a:1,
		\ '\v^\s+(\d+)\s+\d+\s+([^ ]+\s?[^ ]+|\d+\s\w+\s\w+)(\s*\d*)$')
	retu parts == [] ? '----'
		\ : parts[2].' ['.parts[1].']'.( parts[3] != '' ? ' saved' : '' )
endf
" Public {{{1
fu! ctrlp#undo#init()
	let entries = s:undos[0] ? s:undos[1]['entries'] : s:undos[1]
	if empty(entries) | retu [] | en
	if !exists('s:lines')
		if s:undos[0]
			let entries = s:dict2list(s:flatten(entries, s:undos[1]['seq_cur']))
			let s:lines = map(sort(entries, 's:compval'), 's:format(v:val)')
		el
			let s:lines = map(reverse(entries), 's:formatul(v:val)')
		en
	en
	cal s:syntax()
	retu s:lines
endf

fu! ctrlp#undo#accept(mode, str)
	let undon = matchstr(a:str, '\[\zs\d\+\ze\]')
	if empty(undon) | retu | en
	cal ctrlp#exit()
	exe 'u' undon
endf

fu! ctrlp#undo#id()
	retu s:id
endf

fu! ctrlp#undo#enter()
	let s:undos = s:getundo()
endf

fu! ctrlp#undo#exit()
	unl! s:lines
endf
"}}}

" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
" =============================================================================
" File:          autoload/ctrlp/dir.vim
" Description:   Directory extension
" Author:        Kien Nguyen <github.com/kien>
" =============================================================================

" Init {{{1
if exists('g:loaded_ctrlp_dir') && g:loaded_ctrlp_dir
	fini
en
let [g:loaded_ctrlp_dir, g:ctrlp_newdir] = [1, 0]

let s:ars = ['s:maxdepth', 's:maxfiles', 's:compare_lim', 's:glob', 's:caching']

cal add(g:ctrlp_ext_vars, {
	\ 'init': 'ctrlp#dir#init('.join(s:ars, ', ').')',
	\ 'accept': 'ctrlp#dir#accept',
	\ 'lname': 'dirs',
	\ 'sname': 'dir',
	\ 'type': 'path',
	\ 'specinput': 1,
	\ })

let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)

let s:dircounts = {}
" Utilities {{{1
fu! s:globdirs(dirs, depth)
	let entries = split(globpath(a:dirs, s:glob), "\n")
	let [dirs, depth] = [ctrlp#dirnfile(entries)[0], a:depth + 1]
	cal extend(g:ctrlp_alldirs, dirs)
	let nr = len(g:ctrlp_alldirs)
	if !empty(dirs) && !s:max(nr, s:maxfiles) && depth <= s:maxdepth
		sil! cal ctrlp#progress(nr)
		cal map(dirs, 'ctrlp#utils#fnesc(v:val, "g", ",")')
		cal s:globdirs(join(dirs, ','), depth)
	en
endf

fu! s:max(len, max)
	retu a:max && a:len > a:max
endf

fu! s:nocache()
	retu !s:caching || ( s:caching > 1 && get(s:dircounts, s:cwd) < s:caching )
endf
" Public {{{1
fu! ctrlp#dir#init(...)
	let s:cwd = getcwd()
	for each in range(len(s:ars))
		let {s:ars[each]} = a:{each + 1}
	endfo
	let cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'dir'
	let cafile = cadir.ctrlp#utils#lash().ctrlp#utils#cachefile('dir')
	if g:ctrlp_newdir || s:nocache() || !filereadable(cafile)
		let [s:initcwd, g:ctrlp_alldirs] = [s:cwd, []]
		cal s:globdirs(ctrlp#utils#fnesc(s:cwd, 'g', ','), 0)
		cal ctrlp#rmbasedir(g:ctrlp_alldirs)
		if len(g:ctrlp_alldirs) <= s:compare_lim
			cal sort(g:ctrlp_alldirs, 'ctrlp#complen')
		en
		cal ctrlp#utils#writecache(g:ctrlp_alldirs, cadir, cafile)
		let g:ctrlp_newdir = 0
	el
		if !( exists('s:initcwd') && s:initcwd == s:cwd )
			let s:initcwd = s:cwd
			let g:ctrlp_alldirs = ctrlp#utils#readfile(cafile)
		en
	en
	cal extend(s:dircounts, { s:cwd : len(g:ctrlp_alldirs) })
	retu g:ctrlp_alldirs
endf

fu! ctrlp#dir#accept(mode, str)
	let path = a:mode == 'h' ? getcwd() : s:cwd.ctrlp#utils#lash().a:str
	if a:mode =~ 't\|v\|h'
		cal ctrlp#exit()
	en
	cal ctrlp#setdir(path, a:mode =~ 't\|h' ? 'chd!' : 'lc!')
	if a:mode == 'e'
		sil! cal ctrlp#statusline()
		cal ctrlp#setlines(s:id)
		cal ctrlp#recordhist()
		cal ctrlp#prtclear()
	en
endf

fu! ctrlp#dir#id()
	retu s:id
endf
"}}}

" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
" =============================================================================
" File:          autoload/ctrlp/tag.vim
" Description:   Tag file extension
" Author:        Kien Nguyen <github.com/kien>
" =============================================================================

" Init {{{1
if exists('g:loaded_ctrlp_tag') && g:loaded_ctrlp_tag
	fini
en
let g:loaded_ctrlp_tag = 1

cal add(g:ctrlp_ext_vars, {
	\ 'init': 'ctrlp#tag#init()',
	\ 'accept': 'ctrlp#tag#accept',
	\ 'lname': 'tags',
	\ 'sname': 'tag',
	\ 'enter': 'ctrlp#tag#enter()',
	\ 'type': 'tabs',
	\ })

let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
" Utilities {{{1
fu! s:findcount(str)
	let [tg, fname] = split(a:str, '\t\+\ze[^\t]\+$')
	let tgs = taglist('^'.tg.'$')
	if len(tgs) < 2
		retu [1, 1]
	en
	let bname = fnamemodify(bufname('%'), ':p')
	let fname = expand(fnamemodify(simplify(fname), ':s?^[.\/]\+??:p:.'), 1)
	let [fnd, ct, pos, idx] = [0, 0, 0, 0]
	wh idx < len(tgs)
		if bname == fnamemodify(tgs[idx]["filename"], ':p')
			cal insert(tgs, remove(tgs, idx))
			brea
		en
		let idx += 1
	endw
	for each in tgs
		let ct += 1
		let fulname = fnamemodify(each["filename"], ':p')
		if stridx(fulname, fname) >= 0
			\ && strlen(fname) + stridx(fulname, fname) == strlen(fulname)
			let fnd += 1
			let pos = ct
		en
		if fnd > 1 | brea | en
	endfo
	retu [fnd, pos]
endf

fu! s:filter(tags)
	let nr = 0
	wh 0 < 1
		if a:tags == [] | brea | en
		if a:tags[nr] =~ '^!' && a:tags[nr] !~# '^!_TAG_'
			let nr += 1
			con
		en
		if a:tags[nr] =~# '^!_TAG_' && len(a:tags) > nr
			cal remove(a:tags, nr)
		el
			brea
		en
	endw
	retu a:tags
endf

fu! s:syntax()
	if !ctrlp#nosy()
		cal ctrlp#hicheck('CtrlPTabExtra', 'Comment')
		sy match CtrlPTabExtra '\zs\t.*\ze$'
	en
endf
" Public {{{1
fu! ctrlp#tag#init()
	if empty(s:tagfiles) | retu [] | en
	let g:ctrlp_alltags = []
	let tagfiles = sort(filter(s:tagfiles, 'count(s:tagfiles, v:val) == 1'))
	for each in tagfiles
		let alltags = s:filter(ctrlp#utils#readfile(each))
		cal extend(g:ctrlp_alltags, alltags)
	endfo
	cal s:syntax()
	retu g:ctrlp_alltags
endf

fu! ctrlp#tag#accept(mode, str)
	cal ctrlp#exit()
	let str = matchstr(a:str, '^[^\t]\+\t\+[^\t]\+\ze\t')
	let [tg, fnd] = [split(str, '^[^\t]\+\zs\t')[0], s:findcount(str)]
	let cmds = {
		\ 't': ['tab sp', 'tab stj'],
		\ 'h': ['sp', 'stj'],
		\ 'v': ['vs', 'vert stj'],
		\ 'e': ['', 'tj'],
		\ }
	let cmd = fnd[0] == 1 ? cmds[a:mode][0] : cmds[a:mode][1]
	let cmd = a:mode == 'e' && ctrlp#modfilecond(!&aw)
		\ ? ( cmd == 'tj' ? 'stj' : 'sp' ) : cmd
	let cmd = a:mode == 't' ? ctrlp#tabcount().cmd : cmd
	if fnd[0] == 1
		if cmd != ''
			exe cmd
		en
		let save_cst = &cst
		set cst&
		cal feedkeys(":".fnd[1]."ta ".tg."\r", 'nt')
		let &cst = save_cst
	el
		cal feedkeys(":".cmd." ".tg."\r", 'nt')
	en
	cal ctrlp#setlcdir()
endf

fu! ctrlp#tag#id()
	retu s:id
endf

fu! ctrlp#tag#enter()
	let tfs = tagfiles()
	let s:tagfiles = tfs != [] ? filter(map(tfs, 'fnamemodify(v:val, ":p")'),
		\ 'filereadable(v:val)') : []
endf
"}}}

" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
" =============================================================================
" File:          autoload/ctrlp/changes.vim
" Description:   Change list extension
" Author:        Kien Nguyen <github.com/kien>
" =============================================================================

" Init {{{1
if exists('g:loaded_ctrlp_changes') && g:loaded_ctrlp_changes
	fini
en
let g:loaded_ctrlp_changes = 1

cal add(g:ctrlp_ext_vars, {
	\ 'init': 'ctrlp#changes#init(s:bufnr, s:crbufnr)',
	\ 'accept': 'ctrlp#changes#accept',
	\ 'lname': 'changes',
	\ 'sname': 'chs',
	\ 'exit': 'ctrlp#changes#exit()',
	\ 'type': 'tabe',
	\ 'sort': 0,
	\ 'nolim': 1,
	\ })

let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
" Utilities {{{1
fu! s:changelist(bufnr)
	sil! exe 'noa hid b' a:bufnr
	redi => result
	sil! changes
	redi END
	retu map(split(result, "\n")[1:], 'tr(v:val, "	", " ")')
endf

fu! s:process(clines, ...)
	let [clines, evas] = [[], []]
	for each in a:clines
		let parts = matchlist(each, '\v^.\s*\d+\s+(\d+)\s+(\d+)\s(.*)$')
		if !empty(parts)
			if parts[3] == '' | let parts[3] = ' ' | en
			cal add(clines, parts[3].'	|'.a:1.':'.a:2.'|'.parts[1].':'.parts[2].'|')
		en
	endfo
	retu reverse(filter(clines, 'count(clines, v:val) == 1'))
endf

fu! s:syntax()
	if !ctrlp#nosy()
		cal ctrlp#hicheck('CtrlPBufName', 'Directory')
		cal ctrlp#hicheck('CtrlPTabExtra', 'Comment')
		sy match CtrlPBufName '\t|\d\+:\zs[^|]\+\ze|\d\+:\d\+|$'
		sy match CtrlPTabExtra '\zs\t.*\ze$' contains=CtrlPBufName
	en
endf
" Public {{{1
fu! ctrlp#changes#init(original_bufnr, bufnr)
	let bufnr = exists('s:bufnr') ? s:bufnr : a:bufnr
	let bufs = exists('s:clmode') && s:clmode ? ctrlp#buffers('id') : [bufnr]
	cal filter(bufs, 'v:val > 0')
	let [swb, &swb] = [&swb, '']
	let lines = []
	for each in bufs
		let fnamet = fnamemodify(bufname(each), ':t')
		cal extend(lines, s:process(s:changelist(each), each, fnamet))
	endfo
	sil! exe 'noa hid b' a:original_bufnr
	let &swb = swb
	cal ctrlp#syntax()
	cal s:syntax()
	retu lines
endf

fu! ctrlp#changes#accept(mode, str)
	let info = matchlist(a:str, '\t|\(\d\+\):[^|]\+|\(\d\+\):\(\d\+\)|$')
	let bufnr = str2nr(get(info, 1))
	if bufnr
		cal ctrlp#acceptfile(a:mode, bufname(bufnr))
		cal cursor(get(info, 2), get(info, 3))
		sil! norm! zvzz
	en
endf

fu! ctrlp#changes#cmd(mode, ...)
	let s:clmode = a:mode
	if a:0 && !empty(a:1)
		let s:bufnr = bufnr('^'.fnamemodify(a:1, ':p').'$')
	en
	retu s:id
endf

fu! ctrlp#changes#exit()
	unl! s:clmode s:bufnr
endf
"}}}

" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
" =============================================================================
" File:          autoload/ctrlp/mixed.vim
" Description:   Mixing Files + MRU + Buffers
" Author:        Kien Nguyen <github.com/kien>
" =============================================================================

" Init {{{1
if exists('g:loaded_ctrlp_mixed') && g:loaded_ctrlp_mixed
	fini
en
let [g:loaded_ctrlp_mixed, g:ctrlp_newmix] = [1, 0]

cal add(g:ctrlp_ext_vars, {
	\ 'init': 'ctrlp#mixed#init(s:compare_lim)',
	\ 'accept': 'ctrlp#acceptfile',
	\ 'lname': 'fil + mru + buf',
	\ 'sname': 'mix',
	\ 'type': 'path',
	\ 'opmul': 1,
	\ 'specinput': 1,
	\ })

let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
" Utilities {{{1
fu! s:newcache(cwd)
	if g:ctrlp_newmix || !has_key(g:ctrlp_allmixes, 'data') | retu 1 | en
	retu g:ctrlp_allmixes['cwd'] != a:cwd
		\ || g:ctrlp_allmixes['filtime'] < getftime(ctrlp#utils#cachefile())
		\ || g:ctrlp_allmixes['mrutime'] < getftime(ctrlp#mrufiles#cachefile())
		\ || g:ctrlp_allmixes['bufs'] < len(ctrlp#mrufiles#bufs())
endf

fu! s:getnewmix(cwd, clim)
	if g:ctrlp_newmix
		cal ctrlp#mrufiles#refresh('raw')
		let g:ctrlp_newcache = 1
	en
	let g:ctrlp_lines = copy(ctrlp#files())
	cal ctrlp#progress('Mixing...')
	let mrufs = copy(ctrlp#mrufiles#list('raw'))
	if exists('+ssl') && &ssl
		cal map(mrufs, 'tr(v:val, "\\", "/")')
	en
	let bufs = map(ctrlp#buffers('id'), 'fnamemodify(bufname(v:val), ":p")')
	let mrufs = bufs + filter(mrufs, 'index(bufs, v:val) < 0')
	if len(mrufs) > len(g:ctrlp_lines)
		cal filter(mrufs, 'stridx(v:val, a:cwd)')
	el
		let cwd_mrufs = filter(copy(mrufs), '!stridx(v:val, a:cwd)')
		let cwd_mrufs = ctrlp#rmbasedir(cwd_mrufs)
		for each in cwd_mrufs
			let id = index(g:ctrlp_lines, each)
			if id >= 0 | cal remove(g:ctrlp_lines, id) | en
		endfo
	en
	cal map(mrufs, 'fnamemodify(v:val, ":.")')
	let g:ctrlp_lines = len(mrufs) > len(g:ctrlp_lines)
		\ ? g:ctrlp_lines + mrufs : mrufs + g:ctrlp_lines
	if len(g:ctrlp_lines) <= a:clim
		cal sort(g:ctrlp_lines, 'ctrlp#complen')
	en
	let g:ctrlp_allmixes = { 'filtime': getftime(ctrlp#utils#cachefile()),
		\ 'mrutime': getftime(ctrlp#mrufiles#cachefile()), 'cwd': a:cwd,
		\ 'bufs': len(ctrlp#mrufiles#bufs()), 'data': g:ctrlp_lines }
endf
" Public {{{1
fu! ctrlp#mixed#init(clim)
	let cwd = getcwd()
	if s:newcache(cwd)
		cal s:getnewmix(cwd, a:clim)
	el
		let g:ctrlp_lines = g:ctrlp_allmixes['data']
	en
	let g:ctrlp_newmix = 0
	retu g:ctrlp_lines
endf

fu! ctrlp#mixed#id()
	retu s:id
endf
"}}}

" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
" =============================================================================
" File:          autoload/ctrlp/buffertag.vim
" Description:   Buffer Tag extension
" Maintainer:    Kien Nguyen <github.com/kien>
" Credits:       Much of the code was taken from tagbar.vim by Jan Larres, plus
"                a few lines from taglist.vim by Yegappan Lakshmanan and from
"                buffertag.vim by Takeshi Nishida.
" =============================================================================

" Init {{{1
if exists('g:loaded_ctrlp_buftag') && g:loaded_ctrlp_buftag
	fini
en
let g:loaded_ctrlp_buftag = 1

cal add(g:ctrlp_ext_vars, {
	\ 'init': 'ctrlp#buffertag#init(s:crfile)',
	\ 'accept': 'ctrlp#buffertag#accept',
	\ 'lname': 'buffer tags',
	\ 'sname': 'bft',
	\ 'exit': 'ctrlp#buffertag#exit()',
	\ 'type': 'tabs',
	\ 'opts': 'ctrlp#buffertag#opts()',
	\ })

let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)

let [s:pref, s:opts] = ['g:ctrlp_buftag_', {
	\ 'systemenc': ['s:enc', &enc],
	\ 'ctags_bin': ['s:bin', ''],
	\ 'types': ['s:usr_types', {}],
	\ }]

let s:bins = [
	\ 'ctags-exuberant',
	\ 'exuberant-ctags',
	\ 'exctags',
	\ '/usr/local/bin/ctags',
	\ '/opt/local/bin/ctags',
	\ 'ctags',
	\ 'ctags.exe',
	\ 'tags',
	\ ]

let s:types = {
	\ 'asm'    : '%sasm%sasm%sdlmt',
	\ 'aspperl': '%sasp%sasp%sfsv',
	\ 'aspvbs' : '%sasp%sasp%sfsv',
	\ 'awk'    : '%sawk%sawk%sf',
	\ 'beta'   : '%sbeta%sbeta%sfsv',
	\ 'c'      : '%sc%sc%sdgsutvf',
	\ 'cpp'    : '%sc++%sc++%snvdtcgsuf',
	\ 'cs'     : '%sc#%sc#%sdtncEgsipm',
	\ 'cobol'  : '%scobol%scobol%sdfgpPs',
	\ 'eiffel' : '%seiffel%seiffel%scf',
	\ 'erlang' : '%serlang%serlang%sdrmf',
	\ 'expect' : '%stcl%stcl%scfp',
	\ 'fortran': '%sfortran%sfortran%spbceiklmntvfs',
	\ 'html'   : '%shtml%shtml%saf',
	\ 'java'   : '%sjava%sjava%spcifm',
	\ 'javascript': '%sjavascript%sjavascript%sf',
	\ 'lisp'   : '%slisp%slisp%sf',
	\ 'lua'    : '%slua%slua%sf',
	\ 'make'   : '%smake%smake%sm',
	\ 'pascal' : '%spascal%spascal%sfp',
	\ 'perl'   : '%sperl%sperl%sclps',
	\ 'php'    : '%sphp%sphp%scdvf',
	\ 'python' : '%spython%spython%scmf',
	\ 'rexx'   : '%srexx%srexx%ss',
	\ 'ruby'   : '%sruby%sruby%scfFm',
	\ 'scheme' : '%sscheme%sscheme%ssf',
	\ 'sh'     : '%ssh%ssh%sf',
	\ 'csh'    : '%ssh%ssh%sf',
	\ 'zsh'    : '%ssh%ssh%sf',
	\ 'slang'  : '%sslang%sslang%snf',
	\ 'sml'    : '%ssml%ssml%secsrtvf',
	\ 'sql'    : '%ssql%ssql%scFPrstTvfp',
	\ 'tcl'    : '%stcl%stcl%scfmp',
	\ 'vera'   : '%svera%svera%scdefgmpPtTvx',
	\ 'verilog': '%sverilog%sverilog%smcPertwpvf',
	\ 'vim'    : '%svim%svim%savf',
	\ 'yacc'   : '%syacc%syacc%sl',
	\ }

cal map(s:types, 'printf(v:val, "--language-force=", " --", "-types=")')

if executable('jsctags')
	cal extend(s:types, { 'javascript': { 'args': '-f -', 'bin': 'jsctags' } })
en

fu! ctrlp#buffertag#opts()
	for [ke, va] in items(s:opts)
		let {va[0]} = exists(s:pref.ke) ? {s:pref.ke} : va[1]
	endfo
	" Ctags bin
	if empty(s:bin)
		for bin in s:bins | if executable(bin)
			let s:bin = bin
			brea
		en | endfo
	el
		let s:bin = expand(s:bin, 1)
	en
	" Types
	cal extend(s:types, s:usr_types)
endf
" Utilities {{{1
fu! s:validfile(fname, ftype)
	if ( !empty(a:fname) || !empty(a:ftype) ) && filereadable(a:fname)
		\ && index(keys(s:types), a:ftype) >= 0 | retu 1 | en
	retu 0
endf

fu! s:exectags(cmd)
	if exists('+ssl')
		let [ssl, &ssl] = [&ssl, 0]
	en
	if &sh =~ 'cmd\.exe'
		let [sxq, &sxq, shcf, &shcf] = [&sxq, '"', &shcf, '/s /c']
	en
	let output = system(a:cmd)
	if &sh =~ 'cmd\.exe'
		let [&sxq, &shcf] = [sxq, shcf]
	en
	if exists('+ssl')
		let &ssl = ssl
	en
	retu output
endf

fu! s:exectagsonfile(fname, ftype)
	let [ags, ft] = ['-f - --sort=no --excmd=pattern --fields=nKs ', a:ftype]
	if type(s:types[ft]) == 1
		let ags .= s:types[ft]
		let bin = s:bin
	elsei type(s:types[ft]) == 4
		let ags = s:types[ft]['args']
		let bin = expand(s:types[ft]['bin'], 1)
	en
	if empty(bin) | retu '' | en
	let cmd = s:esctagscmd(bin, ags, a:fname)
	if empty(cmd) | retu '' | en
	let output = s:exectags(cmd)
	if v:shell_error || output =~ 'Warning: cannot open' | retu '' | en
	retu output
endf

fu! s:esctagscmd(bin, args, ...)
	if exists('+ssl')
		let [ssl, &ssl] = [&ssl, 0]
	en
	let fname = a:0 ? shellescape(a:1) : ''
	let cmd = shellescape(a:bin).' '.a:args.' '.fname
	if &sh =~ 'cmd\.exe'
		let cmd = substitute(cmd, '[&()@^<>|]', '^\0', 'g')
	en
	if exists('+ssl')
		let &ssl = ssl
	en
	if has('iconv')
		let last = s:enc != &enc ? s:enc : !empty( $LANG ) ? $LANG : &enc
		let cmd = iconv(cmd, &enc, last)
	en
	retu cmd
endf

fu! s:process(fname, ftype)
	if !s:validfile(a:fname, a:ftype) | retu [] | endif
	let ftime = getftime(a:fname)
	if has_key(g:ctrlp_buftags, a:fname)
		\ && g:ctrlp_buftags[a:fname]['time'] >= ftime
		let lines = g:ctrlp_buftags[a:fname]['lines']
	el
		let data = s:exectagsonfile(a:fname, a:ftype)
		let [raw, lines] = [split(data, '\n\+'), []]
		for line in raw
			if line !~# '^!_TAG_' && len(split(line, ';"')) == 2
				let parsed_line = s:parseline(line)
				if parsed_line != ''
					cal add(lines, parsed_line)
				en
			en
		endfo
		let cache = { a:fname : { 'time': ftime, 'lines': lines } }
		cal extend(g:ctrlp_buftags, cache)
	en
	retu lines
endf

fu! s:parseline(line)
	let vals = matchlist(a:line,
		\ '\v^([^\t]+)\t(.+)\t[?/]\^?(.{-1,})\$?[?/]\;\"\t(.+)\tline(no)?\:(\d+)')
	if vals == [] | retu '' | en
	let [bufnr, bufname] = [bufnr('^'.vals[2].'$'), fnamemodify(vals[2], ':p:t')]
	retu vals[1].'	'.vals[4].'|'.bufnr.':'.bufname.'|'.vals[6].'| '.vals[3]
endf

fu! s:syntax()
	if !ctrlp#nosy()
		cal ctrlp#hicheck('CtrlPTagKind', 'Title')
		cal ctrlp#hicheck('CtrlPBufName', 'Directory')
		cal ctrlp#hicheck('CtrlPTabExtra', 'Comment')
		sy match CtrlPTagKind '\zs[^\t|]\+\ze|\d\+:[^|]\+|\d\+|'
		sy match CtrlPBufName '|\d\+:\zs[^|]\+\ze|\d\+|'
		sy match CtrlPTabExtra '\zs\t.*\ze$' contains=CtrlPBufName,CtrlPTagKind
	en
endf

fu! s:chknearby(pat)
	if match(getline('.'), a:pat) < 0
		let [int, forw, maxl] = [1, 1, line('$')]
		wh !search(a:pat, 'W'.( forw ? '' : 'b' ))
			if !forw
				if int > maxl | brea | en
				let int += int
			en
			let forw = !forw
		endw
	en
endf
" Public {{{1
fu! ctrlp#buffertag#init(fname)
	let bufs = exists('s:btmode') && s:btmode
		\ ? filter(ctrlp#buffers(), 'filereadable(v:val)')
		\ : [exists('s:bufname') ? s:bufname : a:fname]
	let lines = []
	for each in bufs
		let bname = fnamemodify(each, ':p')
		let tftype = get(split(getbufvar('^'.bname.'$', '&ft'), '\.'), 0, '')
		cal extend(lines, s:process(bname, tftype))
	endfo
	cal s:syntax()
	retu lines
endf

fu! ctrlp#buffertag#accept(mode, str)
	let vals = matchlist(a:str,
		\ '\v^[^\t]+\t+[^\t|]+\|(\d+)\:[^\t|]+\|(\d+)\|\s(.+)$')
	let bufnr = str2nr(get(vals, 1))
	if bufnr
		cal ctrlp#acceptfile(a:mode, bufname(bufnr))
		exe 'norm!' str2nr(get(vals, 2, line('.'))).'G'
		cal s:chknearby('\V\C'.get(vals, 3, ''))
		sil! norm! zvzz
	en
endf

fu! ctrlp#buffertag#cmd(mode, ...)
	let s:btmode = a:mode
	if a:0 && !empty(a:1)
		let s:bufname = fnamemodify(a:1, ':p')
	en
	retu s:id
endf

fu! ctrlp#buffertag#exit()
	unl! s:btmode s:bufname
endf
"}}}

" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
" =============================================================================
" File:          autoload/ctrlp/line.vim
" Description:   Line extension
" Author:        Kien Nguyen <github.com/kien>
" =============================================================================

" Init {{{1
if exists('g:loaded_ctrlp_line') && g:loaded_ctrlp_line
	fini
en
let g:loaded_ctrlp_line = 1

cal add(g:ctrlp_ext_vars, {
	\ 'init': 'ctrlp#line#init()',
	\ 'accept': 'ctrlp#line#accept',
	\ 'lname': 'lines',
	\ 'sname': 'lns',
	\ 'type': 'tabe',
	\ })

let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
" Utilities {{{1
fu! s:syntax()
	if !ctrlp#nosy()
		cal ctrlp#hicheck('CtrlPBufName', 'Directory')
		cal ctrlp#hicheck('CtrlPTabExtra', 'Comment')
		sy match CtrlPBufName '\t|\zs[^|]\+\ze|\d\+:\d\+|$'
		sy match CtrlPTabExtra '\zs\t.*\ze$' contains=CtrlPBufName
	en
endf
" Public {{{1
fu! ctrlp#line#init()
	let [bufs, lines] = [ctrlp#buffers('id'), []]
	for bufnr in bufs
		let [lfb, bufn] = [getbufline(bufnr, 1, '$'), bufname(bufnr)]
		let lfb = lfb == [] ? ctrlp#utils#readfile(fnamemodify(bufn, ':p')) : lfb
		cal map(lfb, 'tr(v:val, ''	'', '' '')')
		let [linenr, len_lfb, buft] = [1, len(lfb), fnamemodify(bufn, ':t')]
		wh linenr <= len_lfb
			let lfb[linenr - 1] .= '	|'.buft.'|'.bufnr.':'.linenr.'|'
			let linenr += 1
		endw
		cal extend(lines, filter(lfb, 'v:val !~ ''^\s*\t|[^|]\+|\d\+:\d\+|$'''))
	endfo
	cal s:syntax()
	retu lines
endf

fu! ctrlp#line#accept(mode, str)
	let info = matchlist(a:str, '\t|[^|]\+|\(\d\+\):\(\d\+\)|$')
	let bufnr = str2nr(get(info, 1))
	if bufnr
		cal ctrlp#acceptfile(a:mode, bufname(bufnr), get(info, 2))
	en
endf

fu! ctrlp#line#id()
	retu s:id
endf
"}}}

" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
" =============================================================================
" File:          autoload/ctrlp/quickfix.vim
" Description:   Quickfix extension
" Author:        Kien Nguyen <github.com/kien>
" =============================================================================

" Init {{{1
if exists('g:loaded_ctrlp_quickfix') && g:loaded_ctrlp_quickfix
	fini
en
let g:loaded_ctrlp_quickfix = 1

cal add(g:ctrlp_ext_vars, {
	\ 'init': 'ctrlp#quickfix#init()',
	\ 'accept': 'ctrlp#quickfix#accept',
	\ 'lname': 'quickfix',
	\ 'sname': 'qfx',
	\ 'type': 'line',
	\ 'sort': 0,
	\ 'nolim': 1,
	\ })

let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)

fu! s:lineout(dict)
	retu printf('%s|%d:%d| %s', bufname(a:dict['bufnr']), a:dict['lnum'],
		\ a:dict['col'], matchstr(a:dict['text'], '\s*\zs.*\S'))
endf
" Utilities {{{1
fu! s:syntax()
	if !ctrlp#nosy()
		cal ctrlp#hicheck('CtrlPqfLineCol', 'Search')
		sy match CtrlPqfLineCol '|\zs\d\+:\d\+\ze|'
	en
endf
" Public {{{1
fu! ctrlp#quickfix#init()
	cal s:syntax()
	retu map(getqflist(), 's:lineout(v:val)')
endf

fu! ctrlp#quickfix#accept(mode, str)
	let vals = matchlist(a:str, '^\([^|]\+\ze\)|\(\d\+\):\(\d\+\)|')
	if vals == [] || vals[1] == '' | retu | en
	cal ctrlp#acceptfile(a:mode, vals[1])
	let cur_pos = getpos('.')[1:2]
	if cur_pos != [1, 1] && cur_pos != map(vals[2:3], 'str2nr(v:val)')
		mark '
	en
	cal cursor(vals[2], vals[3])
	sil! norm! zvzz
endf

fu! ctrlp#quickfix#id()
	retu s:id
endf
"}}}

" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
" =============================================================================
" File:          autoload/ctrlp/mrufiles.vim
" Description:   Most Recently Used Files extension
" Author:        Kien Nguyen <github.com/kien>
" =============================================================================

" Static variables {{{1
let [s:mrbs, s:mrufs] = [[], []]

fu! ctrlp#mrufiles#opts()
	let [pref, opts] = ['g:ctrlp_mruf_', {
		\ 'max': ['s:max', 250],
		\ 'include': ['s:in', ''],
		\ 'exclude': ['s:ex', ''],
		\ 'case_sensitive': ['s:cseno', 1],
		\ 'relative': ['s:re', 0],
		\ 'save_on_update': ['s:soup', 1],
		\ }]
	for [ke, va] in items(opts)
		let [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
	endfo
endf
cal ctrlp#mrufiles#opts()
" Utilities {{{1
fu! s:excl(fn)
	retu !empty({s:ex}) && a:fn =~# {s:ex}
endf

fu! s:mergelists()
	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
	let mrufs = s:mrufs + diskmrufs
	retu s:chop(mrufs)
endf

fu! s:chop(mrufs)
	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
	retu a:mrufs
endf

fu! s:reformat(mrufs)
	let cwd = getcwd()
	let cwd .= cwd !~ '[\/]$' ? ctrlp#utils#lash() : ''
	if {s:re}
		let cwd = exists('+ssl') ? tr(cwd, '/', '\') : cwd
		cal filter(a:mrufs, '!stridx(v:val, cwd)')
	en
	let idx = strlen(cwd)
	if exists('+ssl') && &ssl
		let cwd = tr(cwd, '\', '/')
		cal map(a:mrufs, 'tr(v:val, "\\", "/")')
	en
	retu map(a:mrufs, '!stridx(v:val, cwd) ? strpart(v:val, idx) : v:val')
endf

fu! s:record(bufnr)
	if s:locked | retu | en
	let bufnr = a:bufnr + 0
	let bufname = bufname(bufnr)
	if bufnr > 0 && !empty(bufname)
		cal filter(s:mrbs, 'v:val != bufnr')
		cal insert(s:mrbs, bufnr)
		cal s:addtomrufs(bufname)
	en
endf

fu! s:addtomrufs(fname)
	let fn = fnamemodify(a:fname, ':p')
	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} )
		\ || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
	en
	let idx = index(s:mrufs, fn, 0, !{s:cseno})
	if idx
		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
		cal insert(s:mrufs, fn)
		if {s:soup} && idx < 0
			cal s:savetofile(s:mergelists())
		en
	en
endf

fu! s:savetofile(mrufs)
	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)
endf
" Public {{{1
fu! ctrlp#mrufiles#refresh(...)
	let mrufs = s:mergelists()
	cal filter(mrufs, '!empty(ctrlp#utils#glob(v:val, 1)) && !s:excl(v:val)')
	if exists('+ssl')
		cal map(mrufs, 'tr(v:val, "/", "\\")')
		cal map(s:mrufs, 'tr(v:val, "/", "\\")')
		let cond = 'count(mrufs, v:val, !{s:cseno}) == 1'
		cal filter(mrufs, cond)
		cal filter(s:mrufs, cond)
	en
	cal s:savetofile(mrufs)
	retu a:0 && a:1 == 'raw' ? [] : s:reformat(mrufs)
endf

fu! ctrlp#mrufiles#remove(files)
	let mrufs = []
	if a:files != []
		let mrufs = s:mergelists()
		let cond = 'index(a:files, v:val, 0, !{s:cseno}) < 0'
		cal filter(mrufs, cond)
		cal filter(s:mrufs, cond)
	en
	cal s:savetofile(mrufs)
	retu s:reformat(mrufs)
endf

fu! ctrlp#mrufiles#add(fn)
	if !empty(a:fn)
		cal s:addtomrufs(a:fn)
	en
endf

fu! ctrlp#mrufiles#list(...)
	retu a:0 ? a:1 == 'raw' ? s:mergelists() : 0 : s:reformat(s:mergelists())
endf

fu! ctrlp#mrufiles#bufs()
	retu s:mrbs
endf

fu! ctrlp#mrufiles#cachefile()
	if !exists('s:cadir') || !exists('s:cafile')
		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
	en
	retu s:cafile
endf

fu! ctrlp#mrufiles#init()
	if !has('autocmd') | retu | en
	let s:locked = 0
	aug CtrlPMRUF
		au!
		au BufAdd,BufEnter,BufLeave,BufWritePost * cal s:record(expand('<abuf>', 1))
		au QuickFixCmdPre  *vimgrep* let s:locked = 1
		au QuickFixCmdPost *vimgrep* let s:locked = 0
		au VimLeavePre * cal s:savetofile(s:mergelists())
	aug END
endf
"}}}

" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
*ctrlp.txt*       Fuzzy file, buffer, mru, tag, ... finder. v1.79
*CtrlP* *ControlP* *'ctrlp'* *'ctrl-p'*
===============================================================================
#                                                                             #
#          :::::::: ::::::::::: :::::::::  :::             :::::::::          #
#         :+:    :+:    :+:     :+:    :+: :+:             :+:    :+:         #
#         +:+           +:+     +:+    +:+ +:+             +:+    +:+         #
#         +#+           +#+     +#++:++#:  +#+             +#++:++#+          #
#         +#+           +#+     +#+    +#+ +#+             +#+                #
#         #+#    #+#    #+#     #+#    #+# #+#             #+#                #
#          ########     ###     ###    ### ##########      ###                #
#                                                                             #
===============================================================================
CONTENTS                                                       *ctrlp-contents*

    1. Intro........................................|ctrlp-intro|
    2. Options......................................|ctrlp-options|
    3. Commands.....................................|ctrlp-commands|
    4. Mappings.....................................|ctrlp-mappings|
    5. Input Formats................................|ctrlp-input-formats|
    6. Extensions...................................|ctrlp-extensions|

===============================================================================
INTRO                                                             *ctrlp-intro*

Full path fuzzy file, buffer, mru, tag, ... finder with an intuitive interface.
Written in pure Vimscript for MacVim, gVim and Vim version 7.0+. Has full
support for Vim's |regexp| as search pattern, built-in MRU files monitoring,
project's root finder, and more.

To enable optional extensions (tag, dir, rtscript...), see |ctrlp-extensions|.

===============================================================================
OPTIONS                                                         *ctrlp-options*

Overview:~

  |loaded_ctrlp|................Disable the plugin.
  |ctrlp_map|...................Default mapping.
  |ctrlp_cmd|...................Default command used for the default mapping.
  |ctrlp_by_filename|...........Default to filename mode or not.
  |ctrlp_regexp|................Default to regexp mode or not.
  |ctrlp_match_window_bottom|...Where to show the match window.
  |ctrlp_match_window_reversed|.Sort order in the match window.
  |ctrlp_max_height|............Max height of the match window.
  |ctrlp_switch_buffer|.........Jump to an open buffer if already opened.
  |ctrlp_reuse_window|..........Reuse special windows (help, quickfix, etc).
  |ctrlp_tabpage_position|......Where to put the new tab page.
  |ctrlp_working_path_mode|.....How to set CtrlP's local working directory.
  |ctrlp_root_markers|..........Additional, high priority root markers.
  |ctrlp_use_caching|...........Use per-session caching or not.
  |ctrlp_clear_cache_on_exit|...Keep cache after exiting Vim or not.
  |ctrlp_cache_dir|.............Location of the cache directory.
  |ctrlp_show_hidden|...........Ignore dotfiles and dotdirs or not.
  |ctrlp_custom_ignore|.........Hide stuff when using |globpath()|.
  |ctrlp_max_files|.............Number of files to scan initially.
  |ctrlp_max_depth|.............Directory depth to recurse into when scanning.
  |ctrlp_user_command|..........Use an external scanner.
  |ctrlp_max_history|...........Number of entries saved in the prompt history.
  |ctrlp_open_new_file|.........How to open a file created by <c-y>.
  |ctrlp_open_multiple_files|...How to open files selected by <c-z>.
  |ctrlp_arg_map|...............Intercept <c-y> and <c-o> or not.
  |ctrlp_follow_symlinks|.......Follow symbolic links or not.
  |ctrlp_lazy_update|...........Only update when typing has stopped.
  |ctrlp_default_input|.........Seed the prompt with an initial string.
  |ctrlp_abbrev|................Input abbreviations.
  |ctrlp_key_loop|..............Use input looping for multi-byte input.
  |ctrlp_use_migemo|............Use Migemo patterns for Japanese filenames.
  |ctrlp_prompt_mappings|.......Change the mappings inside the prompt.

  MRU mode:
  |ctrlp_mruf_max|..............Max MRU entries to remember.
  |ctrlp_mruf_exclude|..........Files that shouldn't be remembered.
  |ctrlp_mruf_include|..........Files to be remembered.
  |ctrlp_mruf_relative|.........Show only MRU files in the working directory.
  |ctrlp_mruf_default_order|....Disable sorting.
  |ctrlp_mruf_case_sensitive|...MRU files are case sensitive or not.
  |ctrlp_mruf_save_on_update|...Save to disk whenever a new entry is added.

  Advanced options:
  |ctrlp_open_func|.............Use custom file opening functions.
  |ctrlp_status_func|...........Change CtrlP's two statuslines.
  |ctrlp_buffer_func|...........Call custom functions in the CtrlP buffer.
  |ctrlp_match_func|............Replace the built-in matching algorithm.

-------------------------------------------------------------------------------
Detailed descriptions and default values:~

                                                                *'g:ctrlp_map'*
Use this option to change the mapping to invoke CtrlP in |Normal| mode: >
  let g:ctrlp_map = '<c-p>'
<

                                                                *'g:ctrlp_cmd'*
Set the default opening command to use when pressing the above mapping: >
  let g:ctrlp_cmd = 'CtrlP'
<

                                                             *'g:loaded_ctrlp'*
Use this to disable the plugin completely: >
  let g:loaded_ctrlp = 1
<

                                                        *'g:ctrlp_by_filename'*
Set this to 1 to set searching by filename (as opposed to full path) as the
default: >
  let g:ctrlp_by_filename = 0
<
Can be toggled on/off by pressing <c-d> inside the prompt.

                                                             *'g:ctrlp_regexp'*
Set this to 1 to set regexp search as the default: >
  let g:ctrlp_regexp = 0
<
Can be toggled on/off by pressing <c-r> inside the prompt.

                                                *'g:ctrlp_match_window_bottom'*
Set this to 0 to show the match window at the top of the screen: >
  let g:ctrlp_match_window_bottom = 1
<

                                              *'g:ctrlp_match_window_reversed'*
Change the listing order of the files in the match window. The default setting
(1) is from bottom to top: >
  let g:ctrlp_match_window_reversed = 1
<

                                                         *'g:ctrlp_max_height'*
Set the maximum height of the match window: >
  let g:ctrlp_max_height = 10
<

                                                      *'g:ctrlp_switch_buffer'*
When opening a file, if it's already open in a window somewhere, CtrlP will try
to jump to it instead of opening a new instance: >
  let g:ctrlp_switch_buffer = 'Et'
<
  e - jump when <cr> is pressed, but only to windows in the current tab.
  t - jump when <c-t> is pressed, but only to windows in another tab.
  v - like "e", but jump when <c-v> is pressed.
  h - like "e", but jump when <c-x> is pressed.
  E, T, V, H - like "e", "t", "v", and "h", but jump to windows anywhere.
  0 or <empty> - disable this feature.

                                                       *'g:ctrlp_reuse_window'*
When opening a file with <cr>, CtrlP avoids opening it in windows created by
plugins, help and quickfix. Use this to setup some exceptions: >
  let g:ctrlp_reuse_window = 'netrw'
<
Acceptable values are partial name, filetype or buftype of the special buffers.
Use regexp to specify the pattern.
Example: >
  let g:ctrlp_reuse_window = 'netrw\|help\|quickfix'
<

                                                   *'g:ctrlp_tabpage_position'*
Where to put the new tab page when opening one: >
  let g:ctrlp_tabpage_position = 'ac'
<
  a - after.
  b - before.
  c - the current tab page.
  l - the last tab page.
  f - the first tab page.

                                                  *'g:ctrlp_working_path_mode'*
When starting up, CtrlP sets its local working directory according to this
variable: >
  let g:ctrlp_working_path_mode = 'ra'
<
  c - the directory of the current file.
  a - like "c", but only applies when the current working directory outside of
      CtrlP isn't a direct ancestor of the directory of the current file.
  r - the nearest ancestor that contains one of these directories or files:
      .git .hg .svn .bzr _darcs
  w - begin finding a root from the current working directory outside of CtrlP
      instead of from the directory of the current file (default). Only applies
      when "r" is also present.
  0 or <empty> - disable this feature.

Note #1: if "a" or "c" is included with "r", use the behavior of "a" or "c" (as
a fallback) when a root can't be found.

Note #2: you can use a |b:var| to set this option on a per buffer basis.

                                                       *'g:ctrlp_root_markers'*
Use this to set your own root markers in addition to the default ones (.git,
.hg, .svn, .bzr, and _darcs). Your markers will take precedence: >
  let g:ctrlp_root_markers = ['']
<
Note: you can use a |b:var| to set this option on a per buffer basis.

                                                        *'g:ctrlp_use_caching'*
Enable/Disable per-session caching: >
  let g:ctrlp_use_caching = 1
<
  0 - Disable caching.
  1 - Enable caching.
  n - When bigger than 1, disable caching and use the number as the limit to
      enable caching again.

Note: you can quickly purge the cache by pressing <F5> while inside CtrlP.

                                                *'g:ctrlp_clear_cache_on_exit'*
Set this to 0 to enable cross-session caching by not deleting the cache files
upon exiting Vim: >
  let g:ctrlp_clear_cache_on_exit = 1
<

                                                          *'g:ctrlp_cache_dir'*
Set the directory to store the cache files: >
  let g:ctrlp_cache_dir = $HOME.'/.cache/ctrlp'
<

                                                        *'g:ctrlp_show_hidden'*
Set this to 1 if you want CtrlP to scan for dotfiles and dotdirs: >
  let g:ctrlp_show_hidden = 0
<
Note: does not apply when a command defined with |g:ctrlp_user_command| is
being used.

                                                           *'ctrlp-wildignore'*
You can use Vim's |'wildignore'| to exclude files and directories from the
results.
Examples: >
  " Excluding version control directories
  set wildignore+=*/.git/*,*/.hg/*,*/.svn/*        " Linux/MacOSX
  set wildignore+=*\\.git\\*,*\\.hg\\*,*\\.svn\\*  " Windows ('noshellslash')
<
Note #1: the `*/` in front of each directory glob is required.

Note #2: |wildignore| influences the result of |expand()|, |globpath()| and
|glob()| which many plugins use to find stuff on the system (e.g. VCS related
plugins look for .git/, .hg/,... some other plugins look for external *.exe
tools on Windows). So be a little mindful of what you put in your |wildignore|.

                                                      *'g:ctrlp_custom_ignore'*
In addition to |'wildignore'|, use this for files and directories you want only
CtrlP to not show. Use regexp to specify the patterns: >
  let g:ctrlp_custom_ignore = ''
<
Examples: >
  let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)$'
  let g:ctrlp_custom_ignore = {
    \ 'dir':  '\v[\/]\.(git|hg|svn)$',
    \ 'file': '\v\.(exe|so|dll)$',
    \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
    \ }
  let g:ctrlp_custom_ignore = {
    \ 'file': '\v(\.cpp|\.h|\.hh|\.cxx)@<!$'
    \ }
<
Note #1: by default, |wildignore| and |g:ctrlp_custom_ignore| only apply when
|globpath()| is used to scan for files, thus these options do not apply when a
command defined with |g:ctrlp_user_command| is being used.

Note #2: when changing the option's variable type, remember to |:unlet| it
first or restart Vim to avoid the "E706: Variable type mismatch" error.

                                                          *'g:ctrlp_max_files'*
The maximum number of files to scan, set to 0 for no limit: >
  let g:ctrlp_max_files = 10000
<
Note: does not apply when a command defined with |g:ctrlp_user_command| is
being used.

                                                          *'g:ctrlp_max_depth'*
The maximum depth of a directory tree to recurse into: >
  let g:ctrlp_max_depth = 40
<
Note: does not apply when a command defined with |g:ctrlp_user_command| is
being used.

                                                       *'g:ctrlp_user_command'*
Specify an external tool to use for listing files instead of using Vim's
|globpath()|. Use %s in place of the target directory: >
  let g:ctrlp_user_command = ''
<
Examples: >
  let g:ctrlp_user_command = 'find %s -type f'       " MacOSX/Linux
  let g:ctrlp_user_command = 'dir %s /-n /b /s /a-d' " Windows
<
You can also use 'grep', 'findstr' or something else to filter the results.
Examples: >
  let g:ctrlp_user_command =
    \ 'find %s -type f | grep -v -P "\.jpg$|/tmp/"'          " MacOSX/Linux
  let g:ctrlp_user_command =
    \ 'dir %s /-n /b /s /a-d | findstr /v /l ".jpg \\tmp\\"' " Windows
<
Use a version control listing command when inside a repository, this is faster
when scanning large projects: >
  let g:ctrlp_user_command = [root_marker, listing_command, fallback_command]
  let g:ctrlp_user_command = {
    \ 'types': {
      \ 1: [root_marker_1, listing_command_1],
      \ n: [root_marker_n, listing_command_n],
      \ },
    \ 'fallback': fallback_command,
    \ 'ignore': 0 or 1
    \ }
<
Some examples: >
  " Single VCS, listing command does not list untracked files:
  let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files']
  let g:ctrlp_user_command = ['.hg', 'hg --cwd %s locate -I .']

  " Multiple VCS's:
  let g:ctrlp_user_command = {
    \ 'types': {
      \ 1: ['.git', 'cd %s && git ls-files'],
      \ 2: ['.hg', 'hg --cwd %s locate -I .'],
      \ },
    \ 'fallback': 'find %s -type f'
    \ }

  " Single VCS, listing command lists untracked files (slower):
  let g:ctrlp_user_command =
    \ ['.git', 'cd %s && git ls-files . -co --exclude-standard']

  let g:ctrlp_user_command =
    \ ['.hg', 'hg --cwd %s status -numac -I . $(hg root)'] " MacOSX/Linux

  let g:ctrlp_user_command = ['.hg', 'for /f "tokens=1" %%a in (''hg root'') '
    \ . 'do hg --cwd %s status -numac -I . %%a']           " Windows
<
Note #1: if the fallback_command is empty or the 'fallback' key is not defined,
|globpath()| will then be used when scanning outside of a repository.

Note #2: unless the |Dictionary| format is used and 'ignore' is defined and set
to 1, the |wildignore| and |g:ctrlp_custom_ignore| options do not apply when
these custom commands are being used. When not present, 'ignore' is set to 0 by
default to retain the performance advantage of using external commands.

Note #3: when changing the option's variable type, remember to |:unlet| it
first or restart Vim to avoid the "E706: Variable type mismatch" error.

Note #4: you can use a |b:var| to set this option on a per buffer basis.

                                                        *'g:ctrlp_max_history'*
The maximum number of input strings you want CtrlP to remember. The default
value mirrors Vim's global |'history'| option: >
  let g:ctrlp_max_history = &history
<
Set to 0 to disable prompt's history. Browse the history with <c-n> and <c-p>.

                                                      *'g:ctrlp_open_new_file'*
Use this option to specify how the newly created file is to be opened when
pressing <c-y>: >
  let g:ctrlp_open_new_file = 'v'
<
  t - in a new tab.
  h - in a new horizontal split.
  v - in a new vertical split.
  r - in the current window.

                                                *'g:ctrlp_open_multiple_files'*
If non-zero, this will enable opening multiple files with <c-z> and <c-o>: >
  let g:ctrlp_open_multiple_files = 'v'
<
Example: >
  let g:ctrlp_open_multiple_files = '2vjr'
<
For the number:
  - If given, it'll be used as the maximum number of windows or tabs to create
    when opening the files (the rest will be opened as hidden buffers).
  - If not given, <c-o> will open all files, each in a new window or new tab.

For the letters:
  t - each file in a new tab.
  h - each file in a new horizontal split.
  v - each file in a new vertical split.
  i - all files as hidden buffers.
  j - after opening, jump to the first opened tab or window.
  r - open the first file in the current window, then the remaining files in
      new splits or new tabs depending on which of "h", "v" and "t" is also
      present.

                                                            *'g:ctrlp_arg_map'*
When this is set to 1, the <c-o> and <c-y> mappings will accept one extra key
as an argument to override their default behavior: >
  let g:ctrlp_arg_map = 0
<
Pressing <c-o> or <c-y> will then prompt for a keypress. The key can be:
  t - open in tab(s)
  h - open in horizontal split(s)
  v - open in vertical split(s)
  i - open as hidden buffers (for <c-o> only)
  c - clear the marked files (for <c-o> only)
  r - open in the current window (for <c-y> only)
  <esc>, <c-c>, <c-u> - cancel and go back to the prompt.
  <cr> - use the default behavior specified with |g:ctrlp_open_new_file| and
  |g:ctrlp_open_multiple_files|.

                                                    *'g:ctrlp_follow_symlinks'*
If non-zero, CtrlP will follow symbolic links when listing files: >
  let g:ctrlp_follow_symlinks = 0
<
  0 - don't follow symbolic links.
  1 - follow but ignore looped internal symlinks to avoid duplicates.
  2 - follow all symlinks indiscriminately.

Note: does not apply when a command defined with |g:ctrlp_user_command| is
being used.

                                                        *'g:ctrlp_lazy_update'*
Set this to 1 to enable the lazy-update feature: only update the match window
after typing's been stopped for a certain amount of time: >
  let g:ctrlp_lazy_update = 0
<
If is 1, update after 250ms. If bigger than 1, the number will be used as the
delay time in milliseconds.

                                                      *'g:ctrlp_default_input'*
Set this to 1 to enable seeding the prompt with the current file's relative
path: >
  let g:ctrlp_default_input = 0
<
Instead of 1 or 0, if the value of the option is a string, it'll be used as-is
as the default input: >
  let g:ctrlp_default_input = 'anystring'
<

                                                             *'g:ctrlp_abbrev'*
Define input abbreviations that can be expanded (either internally or visibly)
in the prompt: >
  let g:ctrlp_abbrev = {}
<
Examples: >
  let g:ctrlp_abbrev = {
    \ 'gmode': 'i',
    \ 'abbrevs': [
      \ {
        \ 'pattern': '^cd b',
        \ 'expanded': '@cd ~/.vim/bundle',
        \ 'mode': 'pfrz',
      \ },
      \ {
        \ 'pattern': '\(^@.\+\|\\\@<!:.\+\)\@<! ',
        \ 'expanded': '.\{-}',
        \ 'mode': 'pfr',
      \ },
      \ {
        \ 'pattern': '\\\@<!:.\+\zs\\\@<! ',
        \ 'expanded': '\ ',
        \ 'mode': 'pfz',
      \ },
      \ ]
    \ }
<
The 'pattern' string is regexp matched against the entered input. The expansion
is as if the 'expanded' string was typed into the prompt.

For 'gmode' (optional):
  i - expand internally (default).
  t - insert the expanded results into the prompt as you type.
  k - insert the expanded results when a non-keyword character is typed. Only
      applies when "t" is also present.

For 'mode' (of each entry; optional):
  f - only in filename mode.
  p - only in full path mode.
  r - only in regexp mode.
  z - only in fuzzy mode.
  n - only when creating a new file with <c-y> (use the expanded string in the
      new filename).
  c - only when auto-completing directory names with <tab> (expand the pattern
      immediately before doing the auto-completion).
  <empty> or not defined - always enable.

Note: the abbrev entries are evaluated in sequence, so a later entry can be
evaluated against the expanded result of a previous entry; this includes itself
when 'gmode' is "t".

                                                           *'g:ctrlp_key_loop'*
An experimental feature. Set this to 1 to enable input looping for the typing
of multi-byte characters: >
  let g:ctrlp_key_loop = 0
<
Note #1: when set, this option resets the |g:ctrlp_lazy_update| option.

Note #2: you can toggle this feature inside the prompt with a custom mapping: >
  let g:ctrlp_prompt_mappings = { 'ToggleKeyLoop()': ['<F3>'] }
<

                                                         *'g:ctrlp_use_migemo'*
Set this to 1 to use Migemo Pattern for Japanese filenames. Migemo Search only
works in regexp mode. To split the pattern, separate words with space: >
  let g:ctrlp_use_migemo = 0
<

                                                    *'g:ctrlp_prompt_mappings'*
Use this to customize the mappings inside CtrlP's prompt to your liking. You
only need to keep the lines that you've changed the values (inside []): >
  let g:ctrlp_prompt_mappings = {
    \ 'PrtBS()':              ['<bs>', '<c-]>'],
    \ 'PrtDelete()':          ['<del>'],
    \ 'PrtDeleteWord()':      ['<c-w>'],
    \ 'PrtClear()':           ['<c-u>'],
    \ 'PrtSelectMove("j")':   ['<c-j>', '<down>'],
    \ 'PrtSelectMove("k")':   ['<c-k>', '<up>'],
    \ 'PrtSelectMove("t")':   ['<Home>', '<kHome>'],
    \ 'PrtSelectMove("b")':   ['<End>', '<kEnd>'],
    \ 'PrtSelectMove("u")':   ['<PageUp>', '<kPageUp>'],
    \ 'PrtSelectMove("d")':   ['<PageDown>', '<kPageDown>'],
    \ 'PrtHistory(-1)':       ['<c-n>'],
    \ 'PrtHistory(1)':        ['<c-p>'],
    \ 'AcceptSelection("e")': ['<cr>', '<2-LeftMouse>'],
    \ 'AcceptSelection("h")': ['<c-x>', '<c-cr>', '<c-s>'],
    \ 'AcceptSelection("t")': ['<c-t>'],
    \ 'AcceptSelection("v")': ['<c-v>', '<RightMouse>'],
    \ 'ToggleFocus()':        ['<s-tab>'],
    \ 'ToggleRegex()':        ['<c-r>'],
    \ 'ToggleByFname()':      ['<c-d>'],
    \ 'ToggleType(1)':        ['<c-f>', '<c-up>'],
    \ 'ToggleType(-1)':       ['<c-b>', '<c-down>'],
    \ 'PrtExpandDir()':       ['<tab>'],
    \ 'PrtInsert("c")':       ['<MiddleMouse>', '<insert>'],
    \ 'PrtInsert()':          ['<c-\>'],
    \ 'PrtCurStart()':        ['<c-a>'],
    \ 'PrtCurEnd()':          ['<c-e>'],
    \ 'PrtCurLeft()':         ['<c-h>', '<left>', '<c-^>'],
    \ 'PrtCurRight()':        ['<c-l>', '<right>'],
    \ 'PrtClearCache()':      ['<F5>'],
    \ 'PrtDeleteEnt()':       ['<F7>'],
    \ 'CreateNewFile()':      ['<c-y>'],
    \ 'MarkToOpen()':         ['<c-z>'],
    \ 'OpenMulti()':          ['<c-o>'],
    \ 'PrtExit()':            ['<esc>', '<c-c>', '<c-g>'],
    \ }
<
Note: if pressing <bs> moves the cursor one character to the left instead of
deleting a character for you, add this to your |.vimrc| to disable the plugin's
default <c-h> mapping: >
  let g:ctrlp_prompt_mappings = { 'PrtCurLeft()': ['<left>', '<c-^>'] }
<

----------------------------------------
MRU mode options:~

                                                           *'g:ctrlp_mruf_max'*
Specify the number of recently opened files you want CtrlP to remember: >
  let g:ctrlp_mruf_max = 250
<

                                                       *'g:ctrlp_mruf_exclude'*
Files you don't want CtrlP to remember. Use regexp to specify the patterns: >
  let g:ctrlp_mruf_exclude = ''
<
Examples: >
  let g:ctrlp_mruf_exclude = '/tmp/.*\|/temp/.*' " MacOSX/Linux
  let g:ctrlp_mruf_exclude = '^C:\\dev\\tmp\\.*' " Windows
<

                                                       *'g:ctrlp_mruf_include'*
And if you want CtrlP to only remember some files, specify them here: >
  let g:ctrlp_mruf_include = ''
<
Example: >
  let g:ctrlp_mruf_include = '\.py$\|\.rb$'
<

                                                      *'g:ctrlp_mruf_relative'*
Set this to 1 to show only MRU files in the current working directory: >
  let g:ctrlp_mruf_relative = 0
<

                                                 *'g:ctrlp_mruf_default_order'*
Set this to 1 to disable sorting when searching in MRU mode: >
  let g:ctrlp_mruf_default_order = 0
<

                                                *'g:ctrlp_mruf_case_sensitive'*
Match this with your file system case-sensitivity setting to avoid duplicate
MRU entries: >
  let g:ctrlp_mruf_case_sensitive = 1
<

                                                *'g:ctrlp_mruf_save_on_update'*
Set this to 0 to disable saving of the MRU list to hard drive whenever a new
entry is added, saving will then only occur when exiting Vim: >
  let g:ctrlp_mruf_save_on_update = 1
<

----------------------------------------
Advanced options:~

                                                          *'g:ctrlp_open_func'*
Define a custom function to open the selected file: >
  let g:ctrlp_open_func = {}
<
Example: >
  let g:ctrlp_open_func = {
    \ 'files'     : 'Function_Name_1',
    \ 'buffers'   : 'Function_Name_2',
    \ 'mru files' : 'Function_Name_3',
    \ }
<
Structure of the functions: >
  function! Function_Name(action, line)
    " Arguments:
    " |
    " +- a:action : The opening action:
    " |             + 'e' : user pressed <cr>  (default)
    " |             + 'h' : user pressed <c-x> (default)
    " |             + 'v' : user pressed <c-v> (default)
    " |             + 't' : user pressed <c-t> (default)
    " |             + 'x' : user used the <c-o> console dialog (default) and
    " |                     chose "e[x]ternal".
    " |
    " +- a:line   : The selected line.

  endfunction
<
Note: does not apply when opening multiple files with <c-z> and <c-o>.

Example: open HTML files in the default web browser when <c-t> is pressed and
in Vim otherwise >
  function! HTMLOpenFunc(action, line)
    if a:action =~ '^[tx]$' && fnamemodify(a:line, ':e') =~? '^html\?$'

      " Get the filename
      let filename = fnameescape(fnamemodify(a:line, ':p'))

      " Close CtrlP
      call ctrlp#exit()

      " Open the file
      silent! execute '!xdg-open' filename

    elseif a:action == 'x' && fnamemodify(a:line, ':e') !~? '^html\?$'

      " Not a HTML file, simulate pressing <c-o> again and wait for new input
      call feedkeys("\<c-o>")

    else

      " Use CtrlP's default file opening function
      call call('ctrlp#acceptfile', [a:action, a:line])

    endif
  endfunction

  let g:ctrlp_open_func = { 'files': 'HTMLOpenFunc' }
<

                                                        *'g:ctrlp_status_func'*
Use this to customize the statuslines for the CtrlP window: >
  let g:ctrlp_status_func = {}
<
Example: >
  let g:ctrlp_status_func = {
    \ 'main': 'Function_Name_1',
    \ 'prog': 'Function_Name_2',
    \ }
<
Structure of the functions: >
  " Main statusline
  function! Function_Name_1(focus, byfname, regex, prev, item, next, marked)
    " Arguments:
    " |
    " +- a:focus   : The focus of the prompt: "prt" or "win".
    " |
    " +- a:byfname : In filename mode or in full path mode: "file" or "path".
    " |
    " +- a:regex   : In regex mode: 1 or 0.
    " |
    " +- a:prev    : The previous search mode.
    " |
    " +- a:item    : The current search mode.
    " |
    " +- a:next    : The next search mode.
    " |
    " +- a:marked  : The number of marked files, or a comma separated list of
    "                the marked filenames.

    return full_statusline
  endfunction

  " Progress statusline
  function! Function_Name_2(str)
    " a:str : Either the number of files scanned so far, or a string indicating
    "         the current directory is being scanned with a user_command.

    return full_statusline
  endfunction
<
See https://gist.github.com/1610859 for a working example.

                                                        *'g:ctrlp_buffer_func'*
Specify the functions that will be called after entering and before exiting the
CtrlP buffer: >
  let g:ctrlp_buffer_func = {}
<
Example: >
  let g:ctrlp_buffer_func = {
    \ 'enter': 'Function_Name_1',
    \ 'exit':  'Function_Name_2',
    \ }
<

                                                         *'g:ctrlp_match_func'*
Set an external fuzzy matching function for CtrlP to use: >
  let g:ctrlp_match_func = {}
<
Example: >
  let g:ctrlp_match_func = { 'match': 'Function_Name' }
<
Structure of the function: >
  function! Function_Name(items, str, limit, mmode, ispath, crfile, regex)
    " Arguments:
    " |
    " +- a:items  : The full list of items to search in.
    " |
    " +- a:str    : The string entered by the user.
    " |
    " +- a:limit  : The max height of the match window. Can be used to limit
    " |             the number of items to return.
    " |
    " +- a:mmode  : The match mode. Can be one of these strings:
    " |             + "full-line": match the entire line.
    " |             + "filename-only": match only the filename.
    " |             + "first-non-tab": match until the first tab char.
    " |             + "until-last-tab": match until the last tab char.
    " |
    " +- a:ispath : Is 1 when searching in file, buffer, mru, mixed, dir, and
    " |             rtscript modes. Is 0 otherwise.
    " |
    " +- a:crfile : The file in the current window. Should be excluded from the
    " |             results when a:ispath == 1.
    " |
    " +- a:regex  : In regex mode: 1 or 0.

    return list_of_matched_items
  endfunction
<

===============================================================================
COMMANDS                                                       *ctrlp-commands*

                                                                       *:CtrlP*
:CtrlP [starting-directory]
   Open CtrlP in find file mode.

   If no argument is given, the value of |g:ctrlp_working_path_mode| will be
   used to determine the starting directory.

   You can use <tab> to auto-complete the [starting-directory] when typing it.

                                                                 *:CtrlPBuffer*
:CtrlPBuffer
   Open CtrlP in find buffer mode.

                                                                    *:CtrlPMRU*
:CtrlPMRU
   Open CtrlP in find Most-Recently-Used file mode.

                                                               *:CtrlPLastMode*
:CtrlPLastMode [--dir]
   Open CtrlP in the last mode used. When having the "--dir" argument, also
   reuse the last working directory.

                                                                   *:CtrlPRoot*
:CtrlPRoot
    This acts like |:CtrlP| with |g:ctrlp_working_path_mode| = 'r' and ignores
    the variable's current value.

                                                             *:CtrlPClearCache*
:CtrlPClearCache
   Flush the cache for the current working directory. The same as pressing <F5>
   inside CtrlP.
   To enable or disable caching, use the |g:ctrlp_use_caching| option.

                                                         *:CtrlPClearAllCaches*
:CtrlPClearAllCaches
   Delete all the cache files saved in |g:ctrlp_cache_dir| location.

-------------------------------------------------------------------------------
For commands provided by bundled extensions, see |ctrlp-extensions|.

===============================================================================
MAPPINGS                                                       *ctrlp-mappings*

                                                                *'ctrlp-<c-p>'*
<c-p>
   Default |Normal| mode mapping to open the CtrlP prompt in find file mode.

----------------------------------------
Once inside the prompt:~

  <c-d>
    Toggle between full-path search and filename only search.
    Note: in filename mode, the prompt's base is '>d>' instead of '>>>'

  <c-r>                                                    *'ctrlp-fullregexp'*
    Toggle between the string mode and full regexp mode.
    Note: in full regexp mode, the prompt's base is 'r>>' instead of '>>>'

    See also: |input-formats| (guide) and |g:ctrlp_regexp_search| (option).

  <c-f>, 'forward'
  <c-up>
    Scroll to the 'next' search mode in the sequence.

  <c-b>, 'backward'
  <c-down>
    Scroll to the 'previous' search mode in the sequence.

  <tab>                                                *'ctrlp-autocompletion'*
    Auto-complete directory names under the current working directory inside
    the prompt.

  <s-tab>
    Toggle the focus between the match window and the prompt.

  <esc>,
  <c-c>
    Exit CtrlP.

Moving:~

  <c-j>,
  <down>
    Move selection down.

  <c-k>,
  <up>
    Move selection up.

  <c-a>
    Move the cursor to the 'start' of the prompt.

  <c-e>
    Move the cursor to the 'end' of the prompt.

  <c-h>,
  <left>,
  <c-^>
    Move the cursor one character to the 'left'.

  <c-l>,
  <right>
    Move the cursor one character to the 'right'.

Editing:~

  <c-]>,
  <bs>
    Delete the preceding character.

  <del>
    Delete the current character.

  <c-w>
    Delete a preceding inner word.

  <c-u>
    Clear the input field.

Browsing input history:~

  <c-n>
    Next string in the prompt's history.

  <c-p>
    Previous string in the prompt's history.

Opening/Creating a file:~

  <cr>
    Open the selected file in the 'current' window if possible.

  <c-t>
    Open the selected file in a new 'tab'.

  <c-v>
    Open the selected file in a 'vertical' split.

  <c-x>,
  <c-cr>,
  <c-s>
    Open the selected file in a 'horizontal' split.

  <c-y>
    Create a new file and its parent directories.

Opening multiple files:~

  <c-z>
    - Mark/unmark a file to be opened with <c-o>.
    - Mark/unmark a file to create a new file in its directory using <c-y>.

  <c-o>
    - Open files marked by <c-z>.
    - When no file has been marked by <c-z>, open a console dialog with the
      following options:

      Open the selected file:
        t - in a tab page.
        v - in a vertical split.
        h - in a horizontal split.
        r - in the current window.
        i - as a hidden buffer.
        x - (optional) with the function defined in |g:ctrlp_open_func|.

      Other options (not shown):
        a - mark all files in the match window.
        d - change CtrlP's local working directory to the selected file's
            directory and switch to find file mode.

Function keys:~

  <F5>
    - Refresh the match window and purge the cache for the current directory.
    - Remove deleted files from the MRU list.

  <F7>
    - Wipe the MRU list.
    - Delete MRU entries marked by <c-z>.

Pasting:~

  <Insert>,                                                   *'ctrlp-pasting'*
  <MiddleMouse>
    Paste the clipboard content into the prompt.

  <c-\>
    Open a console dialog to paste <cword>, <cfile>, the content of the search
    register, the last visual selection, the clipboard or any register into the
    prompt.

Choose your own mappings with |g:ctrlp_prompt_mappings|.

----------------------------------------
When inside the match window (press <s-tab> to switch):~

  a-z
  0-9
  ~^-=;`',.+!@#$%&_(){}[]
    Cycle through the lines which have the matching first character.

===============================================================================
INPUT FORMATS                                             *ctrlp-input-formats*

Formats for inputting in the prompt:~

a)  Simple string.

    E.g. 'abc' is understood internally as 'a[^a]\{-}b[^b]\{-}c'

b)  When in regexp mode, the input string's treated as a Vim's regexp |pattern|
    without any modification.

    E.g. 'abc\d*efg' will be read as 'abc\d*efg'.

    See |ctrlp-fullregexp| (keymap) and |g:ctrlp_regexp_search| (option) for
    how to enable regexp mode.

c)  End the string with a colon ':' followed by a Vim command to execute that
    command after opening the file. If you need to use ':' literally, escape it
    with a backslash: '\:'. When opening multiple files, the command will be
    executed on each opening file.

    E.g. Use ':45' to jump to line 45.

         Use ':/any\:string' to jump to the first instance of 'any:string'.

         Use ':+setf\ myfiletype|50' to set the filetype to 'myfiletype', then
         jump to line 50.

         Use ':diffthis' when opening multiple files to run |:diffthis| on the
         first 4 files.

    See also: Vim's |++opt| and |+cmd|.

d)  Submit two dots '..' to go upward the directory tree by 1 level. To go up
    multiple levels, use one extra dot for each extra level:
>
         Raw input    Interpreted as
         ..           ../
         ...          ../../
         ....         ../../../
<
    Note: if the parent directories are large and uncached, this can be slow.

    You can also use '@cd path/' to change CtrlP's local working directory.
    Use '@cd %:h' to change to the directory of the current file.

e)  Similarly, submit '/' or '\' to find and go to the project's root.

    If the project is large, using a VCS listing command to look for files
    might help speeding up the intial scan (see |g:ctrlp_user_command| for more
    details).

    Note: d) and e) only work in file, directory and mixed modes.

f)  Type the name of a non-existent file and press <c-y> to create it. Mark a
    file with <c-z> to create the new file in the same directory as the marked
    file.

    E.g. Using 'newdir/newfile.txt' will create a directory named 'newdir' as
         well as a file named 'newfile.txt'.

         If an entry 'some/old/dirs/oldfile.txt' is marked with <c-z>, then
         'newdir' and 'newfile.txt' will be created under 'some/old/dirs'. The
         final path will then be 'some/old/dirs/newdir/newfile.txt'.

    Note: use '\' in place of '/' on Windows (if |'shellslash'| is not set).

g)  In filename mode (toggle with <c-d>), you can use one primary pattern and
    one refining pattern separated by a semicolon. Both patterns work like (a),
    or (b) when in regexp mode.

h)  Submit ? to open this help file.

===============================================================================
EXTENSIONS                                                   *ctrlp-extensions*

Extensions are optional. To enable an extension, add its name to the variable
g:ctrlp_extensions: >
  let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir', 'rtscript',
                          \ 'undo', 'line', 'changes', 'mixed', 'bookmarkdir']
<
The order of the items will be the order they appear on the statusline and when
using <c-f>, <c-b>.

Available extensions:~

                                                                    *:CtrlPTag*
  * Tag mode:~
    - Name: 'tag'
    - Command: ":CtrlPTag"
    - Search for a tag within a generated central tags file, and jump to the
      definition. Use the Vim's option |'tags'| to specify the names and the
      locations of the tags file(s).
      E.g. set tags+=doc/tags

                                                                 *:CtrlPBufTag*
                                                              *:CtrlPBufTagAll*
  * Buffer Tag mode:~
    - Name: 'buffertag'
    - Commands: ":CtrlPBufTag [buffer]",
                ":CtrlPBufTagAll".
    - Search for a tag within the current buffer or all listed buffers and jump
      to the definition. Requires |exuberant_ctags| or compatible programs.

                                                               *:CtrlPQuickfix*
  * Quickfix mode:~
    - Name: 'quickfix'
    - Command: ":CtrlPQuickfix"
    - Search for an entry in the current quickfix errors and jump to it.

                                                                    *:CtrlPDir*
  * Directory mode:~
    - Name: 'dir'
    - Command: ":CtrlPDir [starting-directory]"
    - Search for a directory and change the working directory to it.
    - Mappings:
      + <cr> change the local working directory for CtrlP and keep it open.
      + <c-t> change the global working directory (exit).
      + <c-v> change the local working directory for the current window (exit).
      + <c-x> change the global working directory to CtrlP's current local
        working directory (exit).

                                                                    *:CtrlPRTS*
  * Runtime script mode:~
    - Name: 'rtscript'
    - Command: ":CtrlPRTS"
    - Search for files (vimscripts, docs, snippets...) in runtimepath.

                                                                   *:CtrlPUndo*
  * Undo mode:~
    - Name: 'undo'
    - Command: ":CtrlPUndo"
    - Browse undo history.

                                                                   *:CtrlPLine*
  * Line mode:~
    - Name: 'line'
    - Command: ":CtrlPLine"
    - Search for a line in all listed buffers.

                                                                 *:CtrlPChange*
                                                              *:CtrlPChangeAll*
  * Change list mode:~
    - Name: 'changes'
    - Commands: ":CtrlPChange [buffer]",
                ":CtrlPChangeAll".
    - Search for and jump to a recent change in the current buffer or in all
      listed buffers.

                                                                  *:CtrlPMixed*
  * Mixed mode:~
    - Name: 'mixed'
    - Command: ":CtrlPMixed"
    - Search in files, buffers and MRU files at the same time.

                                                            *:CtrlPBookmarkDir*
                                                         *:CtrlPBookmarkDirAdd*
  * BookmarkDir mode:~
    - Name: 'bookmarkdir'
    - Commands: ":CtrlPBookmarkDir",
                ":CtrlPBookmarkDirAdd [directory]".
    - Search for a bookmarked directory and change the working directory to it.
    - Mappings:
      + <cr> change the local working directory for CtrlP, keep it open and
        switch to find file mode.
      + <c-x> change the global working directory (exit).
      + <c-v> change the local working directory for the current window (exit).
      + <F7>
        - Wipe bookmark list.
        - Delete entries marked by <c-z>.

----------------------------------------
Buffer Tag mode options:~

                                                   *'g:ctrlp_buftag_ctags_bin'*
If ctags isn't in your $PATH, use this to set its location: >
  let g:ctrlp_buftag_ctags_bin = ''
<

                                                   *'g:ctrlp_buftag_systemenc'*
Match this with your OS's encoding (not Vim's). The default value mirrors Vim's
global |'encoding'| option: >
  let g:ctrlp_buftag_systemenc = &encoding
<

                                                       *'g:ctrlp_buftag_types'*
Use this to set the arguments for ctags, jsctags... for a given filetype: >
  let g:ctrlp_buftag_types = ''
<
Examples: >
  let g:ctrlp_buftag_types = {
    \ 'erlang'     : '--language-force=erlang --erlang-types=drmf',
    \ 'javascript' : {
      \ 'bin': 'jsctags',
      \ 'args': '-f -',
      \ },
    \ }
<

===============================================================================
CUSTOMIZATION                                             *ctrlp-customization*

Highlighting:~
  * For the CtrlP buffer:
    CtrlPNoEntries : the message when no match is found (Error)
    CtrlPMatch     : the matched pattern (Identifier)
    CtrlPLinePre   : the line prefix '>' in the match window
    CtrlPPrtBase   : the prompt's base (Comment)
    CtrlPPrtText   : the prompt's text (|hl-Normal|)
    CtrlPPrtCursor : the prompt's cursor when moving over the text (Constant)

  * In extensions:
    CtrlPTabExtra  : the part of each line that's not matched against (Comment)
    CtrlPBufName   : the buffer name an entry belongs to (|hl-Directory|)
    CtrlPTagKind   : the kind of the tag in buffer-tag mode (|hl-Title|)
    CtrlPqfLineCol : the line and column numbers in quickfix mode (Comment)
    CtrlPUndoT     : the elapsed time in undo mode (|hl-Directory|)
    CtrlPUndoBr    : the square brackets [] in undo mode (Comment)
    CtrlPUndoNr    : the undo number inside [] in undo mode (String)
    CtrlPUndoSv    : the point where the file was saved (Comment)
    CtrlPUndoPo    : the current position in the undo tree (|hl-Title|)
    CtrlPBookmark  : the name of the bookmark (Identifier)

Statuslines:~
  * Highlight groups:
    CtrlPMode1 : 'file' or 'path', and the current mode (Character)
    CtrlPMode2 : 'prt' or 'win', 'regex', the working directory (|hl-LineNr|)
    CtrlPStats : the scanning status (Function)

  For rebuilding the statuslines, see |g:ctrlp_status_func|.

===============================================================================
MISCELLANEOUS CONFIGS                             *ctrlp-miscellaneous-configs*

* Using |wildignore| for |g:ctrlp_user_command|:
>
  function! s:wig2cmd()
    " Change wildignore into space or | separated groups
    " e.g. .aux .out .toc .jpg .bmp .gif
    " or   .aux$\|.out$\|.toc$\|.jpg$\|.bmp$\|.gif$
    let pats = ['[*\/]*\([?_.0-9A-Za-z]\+\)\([*\/]*\)\(\\\@<!,\|$\)','\\\@<!,']
    let subs = has('win32') || has('win64') ? ['\1\3', ' '] : ['\1\2\3', '\\|']
    let expr = substitute(&wig, pats[0], subs[0], 'g')
    let expr = substitute(expr, pats[1], subs[1], 'g')
    let expr = substitute(expr, '\\,', ',', 'g')

    " Set the user_command option
    let g:ctrlp_user_command = has('win32') || has('win64')
      \ ? 'dir %s /-n /b /s /a-d | findstr /V /l "'.expr.'"'
      \ : 'find %s -type f | grep -v "'.expr .'"'
  endfunction

  call s:wig2cmd()
<
(submitted by Rich Alesi <github.com/ralesi>)

* A standalone function to set the working directory to the project's root, or
  to the parent directory of the current file if a root can't be found:
>
  function! s:setcwd()
    let cph = expand('%:p:h', 1)
    if cph =~ '^.\+://' | retu | en
    for mkr in ['.git/', '.hg/', '.svn/', '.bzr/', '_darcs/', '.vimprojects']
      let wd = call('find'.(mkr =~ '/$' ? 'dir' : 'file'), [mkr, cph.';'])
      if wd != '' | let &acd = 0 | brea | en
    endfo
    exe 'lc!' fnameescape(wd == '' ? cph : substitute(wd, mkr.'$', '.', ''))
  endfunction

  autocmd BufEnter * call s:setcwd()
<
(requires Vim 7.1.299+)

* Using a |count| to invoke different commands using the same mapping:
>
  let g:ctrlp_cmd = 'exe "CtrlP".get(["", "Buffer", "MRU"], v:count)'
<

===============================================================================
CREDITS                                                         *ctrlp-credits*

Developed by Kien Nguyen <github.com/kien>.

Project's homepage:   http://kien.github.com/ctrlp.vim
Git repository:       https://github.com/kien/ctrlp.vim
Mercurial repository: https://bitbucket.org/kien/ctrlp.vim

-------------------------------------------------------------------------------
Thanks to everyone that has submitted ideas, bug reports or helped debugging on
gibhub, bitbucket, and through email.

Special thanks:~

    * Woojong Koh <github.com/wjkoh>
    * Simon Ruderich
    * Yasuhiro Matsumoto <github.com/mattn>
    * Ken Earley <github.com/kenearley>
    * Kyo Nagashima <github.com/hail2u>
    * Zak Johnson <github.com/zakj>
    * Diego Viola <github.com/diegoviola>
    * Piet Delport <github.com/pjdelport>
    * Thibault Duplessis <github.com/ornicar>
    * Kent Sibilev <github.com/datanoise>
    * Tacahiroy <github.com/tacahiroy>
    * Luca Pette <github.com/lucapette>
    * Seth Fowler <github.com/sfowler>
    * Lowe Thiderman <github.com/thiderman>
    * Christopher Fredn <github.com/icetan>
    * Zahary Karadjov <github.com/zah>
    * Jo De Boeck <github.com/grimpy>

===============================================================================
CHANGELOG                                                     *ctrlp-changelog*

Before 2012/11/30~

    + New options: |g:ctrlp_abbrev|,
                   |g:ctrlp_key_loop|,
                   |g:ctrlp_open_func|,
                   |g:ctrlp_tabpage_position|,
                   |g:ctrlp_mruf_save_on_update|
    + Rename:
        *g:ctrlp_dotfiles* -> |g:ctrlp_show_hidden|.
    + Change |g:ctrlp_switch_buffer|'s and |g:ctrlp_working_path_mode|'s type
      (old values still work).
    + New key for |g:ctrlp_user_command| when it's a Dictionary: 'ignore'.

Before 2012/06/15~

    + New value for |g:ctrlp_follow_symlinks|: 2.
    + New value for |g:ctrlp_open_multiple_files|: 'j'.
    + Allow using <c-t>, <c-x>, <c-v> to open files marked by <c-z>.
    + Extend '..' (|ctrlp-input-formats| (d))
    + New input format: '@cd' (|ctrlp-input-formats| (d))

Before 2012/04/30~

    + New option: |g:ctrlp_mruf_default_order|
    + New feature: Bookmarked directories extension.
    + New commands: |:CtrlPBookmarkDir|
                    |:CtrlPBookmarkDirAdd|

Before 2012/04/15~

    + New option: |g:ctrlp_buffer_func|, callback functions for CtrlP buffer.
    + Remove: g:ctrlp_mruf_last_entered, make it a default for MRU mode.
    + New commands: |:CtrlPLastMode|, open CtrlP in the last mode used.
                    |:CtrlPMixed|, search in files, buffers and MRU files.

Before 2012/03/31~

    + New options: |g:ctrlp_default_input|, default input when entering CtrlP.
                   |g:ctrlp_match_func|, allow using a custom fuzzy matcher.
    + Rename:
        *ClearCtrlPCache* -> |CtrlPClearCache|
        *ClearAllCtrlPCaches* -> |CtrlPClearAllCaches|
        *ResetCtrlP* -> |CtrlPReload|

Before 2012/03/02~

    + Rename:
        *g:ctrlp_regexp_search* -> |g:ctrlp_regexp|,
        *g:ctrlp_dont_split* -> |g:ctrlp_reuse_window|,
        *g:ctrlp_jump_to_buffer* -> |g:ctrlp_switch_buffer|.
    + Rename and tweak:
        *g:ctrlp_open_multi* -> |g:ctrlp_open_multiple_files|.
    + Deprecate *g:ctrlp_highlight_match*
    + Extend |g:ctrlp_user_command| to support multiple commands.
    + New option: |g:ctrlp_mruf_last_entered| change MRU to Recently-Entered.

Before 2012/01/15~

    + New mapping: Switch <tab> and <s-tab>. <tab> is now used for completion
                   of directory names under the current working directory.
    + New options: |g:ctrlp_arg_map| for <c-y>, <c-o> to accept an argument.
                   |g:ctrlp_status_func| custom statusline.
                   |g:ctrlp_mruf_relative| show only MRU files inside cwd.
    + Extend g:ctrlp_open_multi with new optional values: tr, hr, vr.
    + Extend |g:ctrlp_custom_ignore| to specifically filter dir, file and link.

Before 2012/01/05~

    + New feature: Buffer Tag extension.
    + New commands: |:CtrlPBufTag|, |:CtrlPBufTagAll|.
    + New options: |g:ctrlp_cmd|,
                   |g:ctrlp_custom_ignore|

Before 2011/11/30~

    + New features: Tag, Quickfix and Directory extensions.
    + New commands: |:CtrlPTag|, |:CtrlPQuickfix|, |:CtrlPDir|.
    + New options: |g:ctrlp_use_migemo|,
                   |g:ctrlp_lazy_update|,
                   |g:ctrlp_follow_symlinks|

Before 2011/11/13~

    + New special input: '/' and '\' find root (|ctrlp-input-formats| (e))
    + Remove ctrlp#SetWorkingPath().
    + Remove *g:ctrlp_mru_files* and make MRU mode permanent.
    + Extend g:ctrlp_open_multi, add new ways to open files.
    + New option: g:ctrlp_dont_split,
                  |g:ctrlp_mruf_case_sensitive|

Before 2011/10/30~

    + New feature: Support for custom extensions.
                   <F5> also removes non-existent files from MRU list.
    + New option: g:ctrlp_jump_to_buffer

Before 2011/10/12~

    + New features: Open multiple files.
                    Pass Vim's |++opt| and |+cmd| to the opening file
                    (|ctrlp-input-formats| (c))
                    Auto-complete each dir for |:CtrlP| [starting-directory]
    + New mappings: <c-z> mark/unmark a file to be opened with <c-o>.
                    <c-o> open all marked files.
    + New option: g:ctrlp_open_multi
    + Remove *g:ctrlp_persistent_input* *g:ctrlp_live_update* and <c-^>.

Before 2011/09/29~

    + New mappings: <c-n>, <c-p> next/prev string in the input history.
                    <c-y> create a new file and its parent dirs.
    + New options: |g:ctrlp_open_new_file|,
                   |g:ctrlp_max_history|
    + Added a new open-in-horizontal-split mapping: <c-x>

Before 2011/09/19~

    + New command: ResetCtrlP
    + New options: |g:ctrlp_max_files|,
                   |g:ctrlp_max_depth|,
                   g:ctrlp_live_update
    + New mapping: <c-^>

Before 2011/09/12~

    + Ability to cycle through matched lines in the match window.
    + Extend the behavior of g:ctrlp_persistent_input
    + Extend the behavior of |:CtrlP|
    + New options: |g:ctrlp_dotfiles|,
                   |g:ctrlp_clear_cache_on_exit|,
                   g:ctrlp_highlight_match,
                   |g:ctrlp_user_command|
    + New special input: '..' (|ctrlp-input-formats| (d))
    + New mapping: <F5>.
    + New commands: |:CtrlPCurWD|,
                    |:CtrlPCurFile|,
                    |:CtrlPRoot|

    + New feature: Search in most recently used (MRU) files
    + New mapping: <c-b>.
    + Extended the behavior of <c-f>.
    + New options: g:ctrlp_mru_files,
                   |g:ctrlp_mruf_max|,
                   |g:ctrlp_mruf_exclude|,
                   |g:ctrlp_mruf_include|
    + New command: |:CtrlPMRU|

First public release: 2011/09/06~

===============================================================================
vim:ft=help:et:ts=2:sw=2:sts=2:norl
" =============================================================================
" File:          plugin/ctrlp.vim
" Description:   Fuzzy file, buffer, mru, tag, etc finder.
" Author:        Kien Nguyen <github.com/kien>
" =============================================================================
" GetLatestVimScripts: 3736 1 :AutoInstall: ctrlp.zip

if ( exists('g:loaded_ctrlp') && g:loaded_ctrlp ) || v:version < 700 || &cp
	fini
en
let g:loaded_ctrlp = 1

let [g:ctrlp_lines, g:ctrlp_allfiles, g:ctrlp_alltags, g:ctrlp_alldirs,
	\ g:ctrlp_allmixes, g:ctrlp_buftags, g:ctrlp_ext_vars, g:ctrlp_builtins]
	\ = [[], [], [], [], {}, {}, [], 2]

if !exists('g:ctrlp_map') | let g:ctrlp_map = '<c-p>' | en
if !exists('g:ctrlp_cmd') | let g:ctrlp_cmd = 'CtrlP' | en

com! -n=? -com=custom,ctrlp#utils#dircompl CtrlP
	\ cal ctrlp#init(0, { 'dir': <q-args> })

com! -n=? -com=custom,ctrlp#utils#dircompl CtrlPMRUFiles
	\ cal ctrlp#init(2, { 'dir': <q-args> })

com! -bar CtrlPBuffer   cal ctrlp#init(1)
com! -n=? CtrlPLastMode cal ctrlp#init(-1, { 'args': <q-args> })

com! -bar CtrlPClearCache     cal ctrlp#clr()
com! -bar CtrlPClearAllCaches cal ctrlp#clra()

com! -bar ClearCtrlPCache     cal ctrlp#clr()
com! -bar ClearAllCtrlPCaches cal ctrlp#clra()

com! -bar CtrlPCurWD   cal ctrlp#init(0, { 'mode': '' })
com! -bar CtrlPCurFile cal ctrlp#init(0, { 'mode': 'c' })
com! -bar CtrlPRoot    cal ctrlp#init(0, { 'mode': 'r' })

if g:ctrlp_map != '' && !hasmapto(':<c-u>'.g:ctrlp_cmd.'<cr>', 'n')
	exe 'nn <silent>' g:ctrlp_map ':<c-u>'.g:ctrlp_cmd.'<cr>'
en

cal ctrlp#mrufiles#init()

com! -bar CtrlPTag      cal ctrlp#init(ctrlp#tag#id())
com! -bar CtrlPQuickfix cal ctrlp#init(ctrlp#quickfix#id())

com! -n=? -com=custom,ctrlp#utils#dircompl CtrlPDir
	\ cal ctrlp#init(ctrlp#dir#id(), { 'dir': <q-args> })

com! -n=? -com=buffer CtrlPBufTag
	\ cal ctrlp#init(ctrlp#buffertag#cmd(0, <q-args>))

com! -bar CtrlPBufTagAll cal ctrlp#init(ctrlp#buffertag#cmd(1))
com! -bar CtrlPRTS       cal ctrlp#init(ctrlp#rtscript#id())
com! -bar CtrlPUndo      cal ctrlp#init(ctrlp#undo#id())
com! -bar CtrlPLine      cal ctrlp#init(ctrlp#line#id())

com! -n=? -com=buffer CtrlPChange
	\ cal ctrlp#init(ctrlp#changes#cmd(0, <q-args>))

com! -bar CtrlPChangeAll   cal ctrlp#init(ctrlp#changes#cmd(1))
com! -bar CtrlPMixed       cal ctrlp#init(ctrlp#mixed#id())
com! -bar CtrlPBookmarkDir cal ctrlp#init(ctrlp#bookmarkdir#id())

com! -n=? -com=custom,ctrlp#utils#dircompl CtrlPBookmarkDirAdd
	\ cal ctrlp#call('ctrlp#bookmarkdir#add', <q-args>)

" vim:ts=2:sw=2:sts=2
